Optimization
==============

Univariate function optimization
-------------------------------------------------------------------------------

Example function to be maximized
++++++++++++++++++++++++++++++++++++++++


.. code:: python

    import numpy as np
    import matplotlib.pyplot as plt
    import math as m
    from scipy import stats as st
    from scipy import optimize
    #
    import time  # Imports system time module to time your script
    
    plt.close('all')  # close all open figures
    



Here we want to optimize a univariate function: ``f1``


.. code:: python

    def f1simple(x):
        # gamma(2,3) density
        if (x < 0):
            return (0)
        if (x == 0):
            return (np.nan)
        y = np.exp(-2*x)
        return (4 * x**2 * y)
    



Next we define the same function but return :math:`f(x)`, :math:`f'(x)`, and
:math:`f''(x)`.


.. code:: python

    def f1(x):
        # gamma(2,3) density
        if (x < 0):
            return np.array([0, 0, 0])
        if (x == 0):
            return np.array([0, 0, np.nan])
        y = np.exp(-2.0*x)
        return np.array([4.0 * x**2.0 * y, 8.0 * x*(1.0-x)*y, 8.0*(1.0 -
    2.0 * x**2.0)*y])
    



Some algorithms that we'll encounter later will minimize a function. So if we
want to maximize our function we have to define it as a negate function, that
is: :math:`g(x) = -f(x)` then :math:`min(g(x))` is the same as
:math:`max(f(x))`.


.. code:: python

    def f1simpleNeg(x):
        # gamma(2,3) density
        if (x < 0):
            return (0)
        if (x == 0):
            return (np.nan)
        y = np.exp(-2*x)
        return (-(4 * x**2 * y))
    



Plotting the function is always a good idea!


.. code:: python

    xmin = 0.0
    xmax = 6.0
    xv = np.arange(xmin, xmax, (xmax - xmin)/200.0)
    fx = np.zeros(len(xv),float) # define column vector
    for i in range(len(xv)):
        fx[i] = f1(xv[i])[0]
    
    print("fx= ", fx)
    
    fig, ax = plt.subplots()
    ax.plot(xv, fx)
    ax.plot(xv, np.zeros(len(xv)))
    plt.show()
    

.. code::

    fx=  [ 0.    0.    0.01  0.03  0.05  0.07  0.09  0.12  0.14  0.17  0.2
    0.23
      0.25  0.28  0.3   0.33  0.35  0.38  0.4   0.42  0.43  0.45  0.47
    0.48
      0.49  0.5   0.51  0.52  0.53  0.53  0.54  0.54  0.54  0.54  0.54
    0.54
      0.54  0.54  0.53  0.53  0.52  0.52  0.51  0.5   0.5   0.49  0.48
    0.47
      0.47  0.46  0.45  0.44  0.43  0.42  0.41  0.4   0.39  0.38  0.37
    0.36
      0.35  0.34  0.34  0.33  0.32  0.31  0.3   0.29  0.28  0.27  0.26
    0.26
      0.25  0.24  0.23  0.22  0.22  0.21  0.2   0.2   0.19  0.18  0.18
    0.17
      0.16  0.16  0.15  0.15  0.14  0.14  0.13  0.13  0.12  0.12  0.11
    0.11
      0.1   0.1   0.1   0.09  0.09  0.09  0.08  0.08  0.08  0.07  0.07
    0.07
      0.06  0.06  0.06  0.06  0.05  0.05  0.05  0.05  0.05  0.04  0.04
    0.04
      0.04  0.04  0.04  0.03  0.03  0.03  0.03  0.03  0.03  0.03  0.02
    0.02
      0.02  0.02  0.02  0.02  0.02  0.02  0.02  0.02  0.02  0.02  0.01
    0.01
      0.01  0.01  0.01  0.01  0.01  0.01  0.01  0.01  0.01  0.01  0.01
    0.01
      0.01  0.01  0.01  0.01  0.01  0.01  0.01  0.01  0.01  0.    0.    0.
    0.
      0.    0.    0.    0.    0.    0.    0.    0.    0.    0.    0.    0.
    0.
      0.    0.    0.    0.    0.    0.    0.    0.    0.    0.    0.    0.
    0.
      0.    0.    0.    0.    0.  ]
    
    

.. image:: figures/Slides_Optimization_figure5_1.png
   :width: 15 cm



Optimization methods
-------------------------------------------------------------------------------

Newton's method
+++++++++++++++++++++++++

In order to implement the Newton method we basically look for the root of a
first derivative so that :math:`f'(x) = 0`. We then use the root finding
algorithm from the previous section to find this point, or: :math:`x(n+1) =
x(n) - \frac{f'(x(x))}{f''(x(n))}`


.. code:: python

    def newton(f3, x0, tol = 1e-9, nmax = 100):
        # Newton's method for optimization, starting at x0
        # f3 is a function that given x returns the vector
        # (f(x), f'(x), f''(x)), for some f
        x = x0
        f3x = f3(x)
        n = 0
        while ((abs(f3x[1]) > tol) and (n < nmax)):
            x = x - f3x[1]/f3x[2]
            f3x = f3(x)
            n = n + 1
        if (n == nmax):
            print("newton failed to converge")
        else:
            return(x)
    



Golden section method
+++++++++++++++++++++++++++++++

The golden-section method works in one dimension only, but does not need the derivatives of the function.
This method is very similar to the bisection method (root bracketing) from the previous section.
The algorithm proceeds in the following way:
Start with :math:`x_l<x_m<x_r` such that :math:`f(x_l) \le (x_m)` and :math:`f(x_r) \le f(x_m)` and :math:`\rho = \frac{1+\sqrt{5}}{2}`.

1. if :math:`x_r - x_l \le \epsilon` then stop
2. if :math:`x_r-x_m > x_m-x_l` then do :math:`(a)` otherwise do :math:`(b)`

  * (a) let :math:`y=x_m+(x_r-x_m)/(1+\rho)` if :math:`f(y) \ge  f(x_m)` then put :math:`x_l=x_m` and :math:`x_m=y` otherwise put :math:`x_r=y`
  * (b) let :math:`y=x_m+(x_m-x_l)/(1+\rho)` if :math:`f(y) \ge  f(x_m)` then put :math:`x_r=x_m` and :math:`x_m=y` otherwise put :math:`x_l=y`

3. go back to step 1


.. code:: python

    def gsection(ftn, xl, xr, xm, tol = 1e-9):
        # applies the golden-section algorithm to maximise ftn
        # we assume that ftn is a function of a single variable
        # and that x.l < x.m < x.r and ftn(x.l), ftn(x.r) <= ftn(x.m)
        #
        # the algorithm iteratively refines x.l, x.r, and x.m and
    terminates
        # when x.r - x.l <= tol, then returns x.m
        # golden ratio plus one
        gr1 = 1 + (1 + np.sqrt(5))/2
        #
        # successively refine x.l, x.r, and x.m
        fl = ftn(xl)
        fr = ftn(xr)
        fm = ftn(xm)
        while ((xr - xl) > tol):
            if ((xr - xm) > (xm - xl)):
                y = xm + (xr - xm)/gr1
                fy = ftn(y)
                if (fy >= fm):
                    xl = xm
                    fl = fm
                    xm = y
                    fm = fy
                else:
                    xr = y
                    fr = fy
            else:
                y = xm - (xm - xl)/gr1
                fy = ftn(y)
                if (fy >= fm):
                    xr = xm
                    fr = fm
                    xm = y
                    fm = fy
                else:
                    xl = y
                    fl = fy
        return(xm)
    



Built in 'optimize.fmin' function
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The function 'optimize.fmin' is in scipy.optimize as optimize

Maximize function: f1
++++++++++++++++++++++++++++

Maximizing using the Newton method
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


.. code:: python

    print(" -----------------------------------")
    print(" Newton results ")
    print(" -----------------------------------")
    print(newton(f1, 0.25))
    print(newton(f1, 0.5))
    print(newton(f1, 0.75))
    print(newton(f1, 1.75))
    

.. code::

     -----------------------------------
     Newton results
     -----------------------------------
    1.97865578347e-12
    0.0
    1.00000000001
    1.0
    
    



Maximizing using the Secant method
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


.. code:: python

    print(" -----------------------------------")
    print(" Golden section results ")
    print(" -----------------------------------")
    print(gsection(f1simple, 0.1, 0.25, 1.3))
    print(gsection(f1simple, 0.25, 0.5, 1.7))
    print(gsection(f1simple, 0.6, 0.75, 1.8))
    print(gsection(f1simple, 0.0, 2.75, 5.0))
    

.. code::

     -----------------------------------
     Golden section results
     -----------------------------------
    0.99999999879
    0.999999992411
    0.999999997487
    0.999999999283
    
    



Maximizing using the built in optimize function
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code:: python

    print(" -----------------------------------")
    print(" optimize.fmin ")
    print(" -----------------------------------")
    print(optimize.fmin(f1simpleNeg, 0.25))
    print(optimize.fmin(f1simpleNeg, 0.5))
    print(optimize.fmin(f1simpleNeg, 0.75))
    print(optimize.fmin(f1simpleNeg, 1.75))
    

.. code::

     -----------------------------------
     optimize.fmin
     -----------------------------------
    Optimization terminated successfully.
             Current function value: -0.541341
             Iterations: 18
             Function evaluations: 36
    [ 1.]
    Optimization terminated successfully.
             Current function value: -0.541341
             Iterations: 16
             Function evaluations: 32
    [ 1.]
    Optimization terminated successfully.
             Current function value: -0.541341
             Iterations: 14
             Function evaluations: 28
    [ 1.]
    Optimization terminated successfully.
             Current function value: -0.541341
             Iterations: 16
             Function evaluations: 32
    [ 1.]
    
    



Multivariate optimization
-------------------------------------------------------------------------------

Define multivariate (i.e. bivariate) example functions
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Here we want to optimize the following functions: f3, f4

Function f3
~~~~~~~~~~~~~~~~~~~~~~


.. code:: python

    def f3simple(x):
        a = x[0]**2/2.0 - x[1]**2/4.0
        b = 2*x[0] - np.exp(x[1])
        f = np.sin(a)*np.cos(b)
        return(f)
    



Its negative version:


.. code:: python

    def f3simpleNeg(x):
        a = x[0]**2/2.0 - x[1]**2/4.0
        b = 2*x[0] - np.exp(x[1])
        f = -np.sin(a)*np.cos(b)
        return(f)
    



And the version that returns :math:`f(x)`, :math:`f'(x)` (i.e. the gradient),
and :math:`f''(x)` (i.e. the Hessian):


.. code:: python

    def f3(x):
        a = x[0]**2/2.0 - x[1]**2/4.0
        b = 2*x[0] - np.exp(x[1])
        f = np.sin(a)*np.cos(b)
        f1 = np.cos(a)*np.cos(b)*x[0] - np.sin(a)*np.sin(b)*2
        f2 = -np.cos(a)*np.cos(b)*x[1]/2 +
    np.sin(a)*np.sin(b)*np.exp(x[1])
        f11 = -np.sin(a)*np.cos(b)*(4 + x[0]**2) + np.cos(a)*np.cos(b) \
            - np.cos(a)*np.sin(b)*4*x[0]
        f12 = np.sin(a)*np.cos(b)*(x[0]*x[1]/2.0 + 2*np.exp(x[1])) \
            + np.cos(a)*np.sin(b)*(x[0]*np.exp(x[1]) + x[1])
        f22 = -np.sin(a)*np.cos(b)*(x[1]**2/4.0 + np.exp(2*x[1])) \
            - np.cos(a)*np.cos(b)/2.0 -
    np.cos(a)*np.sin(b)*x[1]*np.exp(x[1]) \
            + np.sin(a)*np.sin(b)*np.exp(x[1])
        # Function f3 returns: f(x), f'(x), and f''(x)
        return (f, np.array([f1, f2]), np.array([[f11, f12], [f12, f22]]))
    



Plot function f3:


.. code:: python

    from mpl_toolkits.mplot3d import Axes3D
    
    fig = plt.figure(figsize=(14, 16))
    ax = plt.gca(projection='3d')
    
    X = np.arange(-3, 3, .1)
    Y = np.arange(-3, 3, .1)
    X, Y = np.meshgrid(X, Y)
    
    Z = np.zeros((len(X),len(Y)),float)
    for i in range(len(X)):
        for j in range(len(Y)):
            Z[i][j] = f3simple([X[i][j],Y[i][j]])
    
    surf = ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=plt.cm.jet,
    \
           linewidth=0, antialiased=False)
    plt.show()
    

.. image:: figures/Slides_Optimization_Fig_Surface_1.png
   :width: 12 cm




Function f4
~~~~~~~~~~~~~~~~~~~~~~

This is the same function, so we won't repeat it here.


Multivariate optimization methods
++++++++++++++++++++++++++++++++++++++++

2.2.1 Newton
~~~~~~~~~~~~~~~~


.. code:: python

    def newtonMult(f3, x0, tol = 1e-9, nmax = 100):
        # Newton's method for optimisation, starting at x0
        # f3 is a function that given x returns the list
        # {f(x), grad f(x), Hessian f(x)}, for some f
        x = x0
        f3x = f3(x)
        n = 0
        while ((max(abs(f3x[1])) > tol) and (n < nmax)):
            x = x - np.linalg.solve(f3x[2], f3x[1])
            f3x = f3(x)
            n = n + 1
        if (n == nmax):
            print("newton failed to converge")
        else:
            return(x)
    



Built in 'fmin_tnc' in scipy.optimize.tnc
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Maximize multivariate function
+++++++++++++++++++++++++++++++++++++

We use various starting values to see whether we can find more than one optimum.


.. code:: python

    for x0 in np.arange(1.4, 1.6, 0.1):
        for y0 in np.arange(0.4, 0.7, 0.1):
            # This algorithm requires f(x), f'(x), and f''(x)
            print("Newton: f3  " + str([x0,y0]) + ' --> ' +
    str(newtonMult(f3, \
                np. array([x0,y0]))))
            print("optimize.fmin: f3 " + str([x0,y0]) + ' --> ' \
                + str(optimize.fmin(f3simpleNeg, np.array([x0,y0]))))
            print(" ----------------------------------------- ")
    

.. code::

    Newton: f3  [1.3999999999999999, 0.40000000000000002] --> [ 0.04
    -2.51]
    Optimization terminated successfully.
             Current function value: -1.000000
             Iterations: 47
             Function evaluations: 89
    optimize.fmin: f3 [1.3999999999999999, 0.40000000000000002] --> [ 2.03
    1.4 ]
     -----------------------------------------
    Newton: f3  [1.3999999999999999, 0.5] --> [ 0.12  3.34]
    Optimization terminated successfully.
             Current function value: -1.000000
             Iterations: 50
             Function evaluations: 93
    optimize.fmin: f3 [1.3999999999999999, 0.5] --> [ 2.03  1.4 ]
     -----------------------------------------
    Newton: f3  [1.3999999999999999, 0.59999999999999998] --> [-1.55
    6.02]
    Optimization terminated successfully.
             Current function value: -1.000000
             Iterations: 43
             Function evaluations: 82
    optimize.fmin: f3 [1.3999999999999999, 0.59999999999999998] --> [ 2.03
    1.4 ]
     -----------------------------------------
    Newton: f3  [1.5, 0.40000000000000002] --> [ 2.84  5.35]
    Optimization terminated successfully.
             Current function value: -1.000000
             Iterations: 48
             Function evaluations: 90
    optimize.fmin: f3 [1.5, 0.40000000000000002] --> [ 2.03  1.4 ]
     -----------------------------------------
    Newton: f3  [1.5, 0.5] --> [ 0.04 -2.51]
    Optimization terminated successfully.
             Current function value: -1.000000
             Iterations: 42
             Function evaluations: 82
    optimize.fmin: f3 [1.5, 0.5] --> [ 2.03  1.4 ]
     -----------------------------------------
    Newton: f3  [1.5, 0.59999999999999998] --> [  9.90e-10   1.37e-09]
    Optimization terminated successfully.
             Current function value: -1.000000
             Iterations: 43
             Function evaluations: 82
    optimize.fmin: f3 [1.5, 0.59999999999999998] --> [ 2.03  1.4 ]
     -----------------------------------------
    Newton: f3  [1.6000000000000001, 0.40000000000000002] --> [-0.56
    -0.79]
    Optimization terminated successfully.
             Current function value: -1.000000
             Iterations: 47
             Function evaluations: 88
    optimize.fmin: f3 [1.6000000000000001, 0.40000000000000002] --> [ 2.03
    1.4 ]
     -----------------------------------------
    Newton: f3  [1.6000000000000001, 0.5] --> [-0.29 -0.23]
    Optimization terminated successfully.
             Current function value: -1.000000
             Iterations: 44
             Function evaluations: 80
    optimize.fmin: f3 [1.6000000000000001, 0.5] --> [ 2.03  1.4 ]
     -----------------------------------------
    Newton: f3  [1.6000000000000001, 0.59999999999999998] --> [-1.55
    -3.33]
    Optimization terminated successfully.
             Current function value: -1.000000
             Iterations: 42
             Function evaluations: 80
    optimize.fmin: f3 [1.6000000000000001, 0.59999999999999998] --> [ 2.03
    1.4 ]
     -----------------------------------------
    
    



Homework
-------------------------------------------------------------------------------

:doc:`./Lecture_Optimization/Homework/Homework_Optimization`

