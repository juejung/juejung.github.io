Vectors and matrices
===============================================================================

Definitions of vectors and matrices
-------------------------------------------------------------------------------

.. index:: array, numpy array, numpy

A vector is a list of numbers that we can do "math" with. The numbers in the
vector are indexed, so that we can access them.  Note that vector indexing in
Python zero, not with 1. So Python counts the first element in a vector as
element 0, the second as element 1, etc.  We first need to import some
important packages so that Python understands basic numerical procedures and
definitions, like vectors and matrices and not with a list. The command
**np.array** from the **numpy** package does just that.

Here are some examples. Vectors ``x`` ``y`` ``year`` and ``names`` are assigned
as follows:


.. code:: python

    import numpy as np
    
    # You can document your script files using the ``#`` symbol.
    # This allows you to add commentary to your codes.
    xv = np.array([1, 3.3333, 4.8976, 9])
    yv = np.array([9.233, 0.3453, 3.29999, 2.8])
    
    print("xv = {}".format(xv))
    print("yv = {}".format(yv))
    print("xv[0] = {}".format(xv[0]))
    print("xv[1] = {}".format(xv[1]))
    print("xv[2] = {}".format(xv[2]))
    

.. code::

    xv = [ 1.      3.3333  4.8976  9.    ]
    yv = [ 9.233    0.3453   3.29999  2.8    ]
    xv[0] = 1.0
    xv[1] = 3.3333
    xv[2] = 4.8976
    
    



Remember that Python starts numbering the elements with 0 and not 1! So if
you want to access the first element in a vector ``x`` you'd need to type:
``xv[0]``.

If you would like to print the vector formatted, you need to set the format
option of the ``numpy`` object as:


.. code:: python

    np.set_printoptions(precision=2)
    print("xv= {}".format(xv))
    print("yv= {}".format(yv))
    

.. code::

    xv= [ 1.    3.33  4.9   9.  ]
    yv= [ 9.23  0.35  3.3   2.8 ]
    
    



Note that if you like a vector: 2000,2001,2002,2003 you need to
write the arange command with the upper limit+1.


.. code:: python

    year  = np.arange(2000,2004,1)   # np.arange(from, to, stepsize)
    print("year= {}".format(year))
    

.. code::

    year= [2000 2001 2002 2003]
    
    



If you would like to generate a certain number of elements between two boundary
points you can use ``np.linspace()``.


.. code:: python

    somev = np.linspace(2000,2003,5) # np.linspace(from, to, nr. of steps)
    print("somev= {}".format(somev))
    

.. code::

    somev= [ 2000.    2000.75  2001.5   2002.25  2003.  ]
    
    



Remember from the previous chapter how it is very similar to lists and tuples.


.. code:: python

    # A list of strings is simply:
    names_list = ["Tom", "Dick", "Harry", "Patrick"]
    
    # A tuple of strings is simply:
    names_tuple = ("Tom", "Dick", "Harry", "Patrick")
    
    print("names_list= {}".format(names_list))
    print("names_tuple= {}".format(names_tuple))
    
    print("names_list[1]= {}".format(names_list[1]))
    print("names_list[3]= {}".format(names_list[3]))
    

.. code::

    names_list= ['Tom', 'Dick', 'Harry', 'Patrick']
    names_tuple= ('Tom', 'Dick', 'Harry', 'Patrick')
    names_list[1]= Dick
    names_list[3]= Patrick
    
    




Simple calculations with vectors and matrices
-------------------------------------------------------------------------------


.. code:: python

    import numpy as np
    # Element-by-element operations
    x1 = np.array([1,3,4,9])
    x2 = np.array([2,5,6,3])
    #
    print(" --- OUTPUT: --- ")
    print("x1= {}".format(x1))
    print("x2= {}".format(x2))
    print(" ---------------- ")
    print("x1+x2= {}".format(x1+x2))
    print("x1*x2= {}".format(x1*x2))
    

.. code::

     --- OUTPUT: ---
    x1= [1 3 4 9]
    x2= [2 5 6 3]
     ----------------
    x1+x2= [ 3  8 10 12]
    x1*x2= [ 2 15 24 27]
    
    



Matrices are "two dimensional" vectors. In **Python** we write


.. code:: python

    import numpy as np
    a = np.array([[2,3],[4,5]])
    b = np.array([[2,6],[1,3]])
    #
    print(" --- OUTPUT: --- ")
    print("a= \n {}".format(a))
    print("b= \n {}".format(b))
    print(" ---------------- ")
    print("a*b= \n {}".format(a*b))
    print("a-b= \n {}".format(a-b))
    print(" ---------------- ")
    

.. code::

     --- OUTPUT: ---
    a=
     [[2 3]
     [4 5]]
    b=
     [[2 6]
     [1 3]]
     ----------------
    a*b=
     [[ 4 18]
     [ 4 15]]
    a-b=
     [[ 0 -3]
     [ 3  2]]
     ----------------
    
    



If you want to generate matrices filled with either zeros or ones of a
particular size in **Python** you can use the following:


.. code:: python

    import numpy as np
    a = np.zeros((3,5),float)
    b = np.ones((4,3),float)
    c = np.identity(3)
    
    print(" --- OUTPUT: --- ")
    print("a= \n {}".format(a))
    print(" ---------------- ")
    print("b= \n {}".format(b))
    print(" ---------------- ")
    print("c= \n {}".format(c))
    

.. code::

     --- OUTPUT: ---
    a=
     [[ 0.  0.  0.  0.  0.]
     [ 0.  0.  0.  0.  0.]
     [ 0.  0.  0.  0.  0.]]
     ----------------
    b=
     [[ 1.  1.  1.]
     [ 1.  1.  1.]
     [ 1.  1.  1.]
     [ 1.  1.  1.]]
     ----------------
    c=
     [[ 1.  0.  0.]
     [ 0.  1.  0.]
     [ 0.  0.  1.]]
    
    



Vector manipulation
-------------------------------------------------------------------------------

A vector of order :math:`n>0` is a set of ordered numbers.
:math:`a = \left[ \begin{array}{c} 4 \\ 3 \end{array} \right], \:
e_{1} = \left[ \begin{array}{c} 1 \\ 0 \\ 0 \end{array} \right], \: ...`

These are column vectors. Row vectors are transposed column vectors, that is
:math:`a'=[4 \: 3], \: e'_{1}=[1 \: 0 \: 0], \: ...`

Transposing vectors
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

In **Python** vectors are formed as column vectors by default. We can simply
transpose vectors using the transpose function ``t()`` as follows:


.. code:: python

    import numpy as np
    import matplotlib.pyplot as plt
    import math as m
    from scipy import stats as st
    import time  # Imports system time module to time your script
    
    plt.close('all')  # close all open figures
    




.. code:: python

    a = np.array([4,3])      # column vector
    aprime = a.transpose()   # row vector
    print("a= {}".format(a))
    print("a'= {}".format(aprime))
    

.. code::

    a= [4 3]
    a'= [4 3]
    
    



Length of vectors
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

A vector (at least a two dimensional one) has a convenient geometric
representation. It is an arrow, where the two coordinates indicate the
direction and length of this arrow. Vector :math:`a = \left[ \begin{array}{c} 4
\\ 3 \end{array} \right]` points to the upper right (i.e. 4 over, 3 up). The
length of a vector can be calculated using the Pythagoras theorem for the
triangle. The length of vector :math:`a = \left[ \begin{array}{c} a_1 \\ a_2
\end{array} \right]` where :math:`a_1` and :math:`a_2` are simply numbers, can
be calculated as :math:`\|a\| = \sqrt{a_1^2 + a_2^2}.` For our example, the
vector norm for :math:`a = \left[ \begin{array}{c} 4 \\ 3 \end{array} \right]
\text{ is } \rightarrow \|a\| = \sqrt{4^2 + 3^2} = 5.` In **Python** we can
simply define a vector and calculate its norm (or length) as


.. code:: python

    a = np.array([4,3])
    norma = np.sqrt(np.sum(a**2))
    print("norm(a) = ", norma)
    print("norm(a) = ", np.linalg.norm(a))   # built in norm() command
    

.. code::

    norm(a) =  5.0
    norm(a) =  5.0
    
    



Adding two vectors
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Adding vectors is simple. We just add all numbers of two vectors
'element-by-element'. So that  :math:`a + b = \left[ \begin{array}{c} a_1  + b_1 \\
a_2+b_2 \end{array} \right].` In **Python** this is done with


.. code:: python

    a = np.array([4,3])
    b = np.array([12,5])
    print("a= ", a)
    print("b= ", b)
    print("a+b=", a+b)   # adding up vectors element-by-element
    

.. code::

    a=  [4 3]
    b=  [12  5]
    a+b= [16  8]
    
    



Multiplication of vectors
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

A vector can be multiplied by a number (we call it a scalar denoted as :math:`
\lambda` to distinguish it from vectors and the numbers that it contains). The
scalar is multiplied with all numbers of the vector. If we multiply the vector
with :math:`\lambda > 1` then the arrow that the vector symbolizes is becoming
longer. If we multiply the vector with :math:`0 < \lambda < 1` the arrow gets
shorter. If we multiply the vector with a negative number :math:`\lambda < 0`
then the arrow changes direction. More formally this is :math:`\lambda * a =
\left[ \begin{array}{c} \lambda *a_1 \\ \lambda *a_2 \end{array} \right].`

In **Python** it's simply


.. code:: python

    a = np.array([4,3])
    anorm  = np.sqrt(np.sum(a**2)) # norm of vector a
    print("a=", a)
    print("anorm=", anorm)
    b = 5*a
    bnorm = np.sqrt(np.sum(b**2)) # norm of longer vector
    print("b=", b)
    print("bnorm=", bnorm)
    c = 0.5*a
    cnorm = np.sqrt(np.sum(c**2)) # norm of shorter vector
    print("c=", c)
    print("cnorm=", cnorm )
    d = -3*a       # vector changes direction
    dnorm = np.sqrt(np.sum(d**2))
    print("d=", d)
    print("dnorm=", dnorm)
    

.. code::

    a= [4 3]
    anorm= 5.0
    b= [20 15]
    bnorm= 25.0
    c= [ 2.   1.5]
    cnorm= 2.5
    d= [-12  -9]
    dnorm= 15.0
    
    



When multiplying two vectors we form a so called 'inner product' as follows:
:math:`a*b = \sum_{i=1}^{n}a_i*b_i.`

The following example shows this with numbers:

:math:`a = \left[ \begin{array}{c} 4 \\ 3 \end{array} \right] \text{ and }  b =
\left[ \begin{array}{c} 12 \\ 5 \end{array} \right]`

then

:math:`ax*b = 4*12 + 3*5.` In **Python** the inner product is simply:


.. code:: python

    a = np.array([4,3])
    b = np.array([12,5])
    print("a= ", a)
    print("b= ", b)
    print("a*b =", np.sum(a*b))   # inner product
    

.. code::

    a=  [4 3]
    b=  [12  5]
    a*b = 63
    
    



Matrix manipulation
-------------------------------------------------------------------------------

Matrices are "two dimensional" vectors. In **Python** we define a matrix as


.. code:: python

    A = np.array([[2,3],[4,5]])
    B = np.array([[2,6],[1,3]])
    print("A=", A)
    print("B=", B)
    

.. code::

    A= [[2 3]
     [4 5]]
    B= [[2 6]
     [1 3]]
    
    



Transposing matrices
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Transposing matrices requires again the ``t()`` command. It writes each column as row of a new matrix. So that the transpose of matrix :math:`A` in the above example becomes:


.. code:: python

    A = np.array([[2,3],[4,5]])
    B = np.array([[2,6],[1,3]])
    Atrans = A.transpose()
    print("A=", A)
    print("A'=", Atrans)
    

.. code::

    A= [[2 3]
     [4 5]]
    A'= [[2 4]
     [3 5]]
    
    



If we transpose the transpose of matrix A, we get the original matrix A back.

Adding matrices
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

When adding two matrices :math:`A` and :math:`B` we simply add all the elements
of each matrix 'element-by-element'. Note that the dimensions (i.e. the number
of rows and columns) of the two matrices have to be identical. So if matrix
:math:`A` has dimension :math:`m \times n`, that is :math:`m` rows and
:math:`n` columns, then matrix :math:`B` needs to be of dimensions :math:`m
\times n` as well.


.. code:: python

    A = np.array([[2,3],[4,5]])
    B = np.array([[2,6],[1,3]])
    C =  A+B
    print("A=", A)
    print("B=", B)
    print("C=", C)
    

.. code::

    A= [[2 3]
     [4 5]]
    B= [[2 6]
     [1 3]]
    C= [[4 9]
     [5 8]]
    
    



Multiplying matrices
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

When multiplying two matrices :math:`A` and :math:`B` we need to make sure that
the number of columns of matrix :math:`A` is equal the number of rows of matrix
:math:`B`. So if :math:`A` has dimension :math:`m \times n` then :math:`B`
needs to have dimension :math:`n \times r` since matrix multiplication implies
that we form the 'inner product' of each row of :math:`A` with each column of
:math:`B`. This results in a new matrix of dimension :math:`m \times r`.  Here
is an example. Given matrices :math:`A = \left[ \begin{array}{ccc} 12 & 3 &6 \\
9 &-1 & -4 \end{array} \right] \text{ and } B = \left[ \begin{array}{cc} 7 & 8
\\ -2 &0 \\ 1 & 11 \end{array} \right]`

the product of :math:`A` :math:`(2 \times 3)` and :math:`B` of dimension
:math:`(3 \times 2)` is a matrix :math:`C` with dimension :math:`(2 \times 2)`:

:math:`AB = \left[ \begin{array}{cc} 12*7+3*(-2)+6*1 & 12*8+3*0+6*11 \\
9*7+(-1)*(-2)+(-4)*1 & 9*8+(-1)*0+(-4)*11 \end{array} \right].`

In **Python** matrix multiplication is achieved using the command ``dot()``.


.. code:: python

    A = np.array([[12,3,6],[3,-1,-4]])
    B = np.array([[7,8],[-2,0],[1,11]])
    C = np.dot(A,B) # matrix multiplication
    
    print("A=", A)
    print("B=", B)
    print("C=", C)
    

.. code::

    A= [[12  3  6]
     [ 3 -1 -4]]
    B= [[ 7  8]
     [-2  0]
     [ 1 11]]
    C= [[ 84 162]
     [ 19 -20]]
    
    



Multiplying a matrix with a vector
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Vectors are simply :math:`n \times 1` or :math:`1 \times n` dimensional
matrices so that the same rules as above apply for multiplying a matrix with a
vector.


.. code:: python

    A = np.array([[12,3,6],[3,-1,-4]])
    b = np.array([7,-2,1])
    C = np.dot(A,b) # matrix multiplied by vector: (m x n) x (n x 1) = (m
    x 1)
    print("A=", A)
    print("b=", b)
    print("C=", C)
    

.. code::

    A= [[12  3  6]
     [ 3 -1 -4]]
    b= [ 7 -2  1]
    C= [84 19]
    
    



Indexing and accessing elements of a matrix
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


.. code:: python

    A = np.array([[11,12,13,14],[21,22,23,24],[31,32,33,34]])
    
    print("A=", A)
    print("---------------")
    print()
    
    # Element row 2, column 3 (remember Python starts indexing at 0!!)
    print("A[1,2] = ", A[1,2])
    print("---------------")
    print("A[0,:] = ", A[0,:])   # First row
    print("---------------")
    print("A[:,0] = ", A[:,0])   # First column
    print("---------------")
    print("A[1:,:] = ", A[1:,])  # All, except first row
    

.. code::

    A= [[11 12 13 14]
     [21 22 23 24]
     [31 32 33 34]]
    ---------------
    
    A[1,2] =  23
    ---------------
    A[0,:] =  [11 12 13 14]
    ---------------
    A[:,0] =  [11 21 31]
    ---------------
    A[1:,:] =  [[21 22 23 24]
     [31 32 33 34]]
    
    



If you want to remove columns or rows you can use the ``take`` method and
assign the result to a new matrix. Let's say you would like to eliminate the
second column from a matrix ``A``.


.. code:: python

    print("A=", A)
    print("---------------")
    
    # Remove column 2 (or take column 1, 3, and 4)
    B = A.take([0,2,3], axis=1)
    print("B =", B )
    

.. code::

    A= [[11 12 13 14]
     [21 22 23 24]
     [31 32 33 34]]
    ---------------
    B = [[11 13 14]
     [21 23 24]
     [31 33 34]]
    
    



If you want to replace matrix elements based on certain criteria you can use
the criteria as a logical statement in combination with the ``choose`` method.
In the next example we replace all the elements of the matrix that are larger
than 90 with the number 90. We start by setting some elements of the matrix
equal to 99.


.. code:: python

    A[:,0] = 99 # Fill first column with 99
    print("A = ", A)
    print("---------------")
    
    # Replace all elements > 90 with number 90
    B = (A>90).choose(A,90)
    print("(A>90).choose(A,90) = ", B)
    

.. code::

    A =  [[99 12 13 14]
     [99 22 23 24]
     [99 32 33 34]]
    ---------------
    (A>90).choose(A,90) =  [[90 12 13 14]
     [90 22 23 24]
     [90 32 33 34]]
    
    



If you want to run a loop "through" a matrix you can first find out the
dimensions of the matrix using the ``shape`` method and then write nested
loops, one for each dimension. Note the indentation of the various ``print``
statements in the next example!


.. code:: python

    A = np.array([[11,12,13,14],[21,22,23,24],[31,32,33,34]])
    print("A=", A)
    print("---------------")
    print(" Start loops ")
    print("---------------")
    
    nrRows, nrCols = A.shape
    for i in range(nrRows):
        print("Row {}".format(i+1))
        print("---------------")
    
        for j in range(nrCols):
            print("The element in row {} and column {} is: {}".format(i+1,
    j+1, A[i,j]))
    
        print("Done with row {}".format(i+1))
        print("---------------")
    
    print("---------------")
    print(" All Done ")
    print("---------------")
    

.. code::

    A= [[11 12 13 14]
     [21 22 23 24]
     [31 32 33 34]]
    ---------------
     Start loops
    ---------------
    Row 1
    ---------------
    The element in row 1 and column 1 is: 11
    The element in row 1 and column 2 is: 12
    The element in row 1 and column 3 is: 13
    The element in row 1 and column 4 is: 14
    Done with row 1
    ---------------
    Row 2
    ---------------
    The element in row 2 and column 1 is: 21
    The element in row 2 and column 2 is: 22
    The element in row 2 and column 3 is: 23
    The element in row 2 and column 4 is: 24
    Done with row 2
    ---------------
    Row 3
    ---------------
    The element in row 3 and column 1 is: 31
    The element in row 3 and column 2 is: 32
    The element in row 3 and column 3 is: 33
    The element in row 3 and column 4 is: 34
    Done with row 3
    ---------------
    ---------------
     All Done
    ---------------
    
    



In class exercises
-------------------------------------------------------------------------------

1. Generate a vector with entries from 1 to 20, stepsize 0.5
2. Divide the first 10 entries by 5
3. Replace the last entry with the value from the first entry
4. Sort the vector from largest to smallest element

