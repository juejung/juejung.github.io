A Simple OLG model
====================

.. index:: OLG, Overlapping generations

* OLG stands for overlapping generations
* This model allows for young and old agents
* We start with

    * Preferences
    * Technology
    * Government
    * Equilibrium

Formal Definition of the Model
--------------------------------------------------------------------------------

**Preferences**

* Agents live for 2 periods: young and old
* There are :math:`N_y` young households and :math:`N_o` old households
* They value consumption when young :math:`c_y` and consumption when old :math:`c_o`
* Their preferences are given via utility functions: :math:`u_t(c_t)`
* Agents discount time with factor :math:`\beta`
* Their life-time utility is:

.. math::
  V(c_y, c_o) = u(c_y) + \beta \times u(c_o)

**Technology**

* Firms produce output :math:`Y` using input capital :math:`K` and labor :math:`L`:

.. math::

    Y = F(K,L) = A K^{\alpha} L^{(1-\alpha)}

* Firms maximize profits:

  .. math::
    max_{\left\{K,L\right\}} F(K,L) - wL - qK

* :math:`w` are wages and :math:`q` is the factor price of capital


**Government**

* The government collects taxes on labor :math:`\tau_L` and capital :math:`\tau_K`
* The government pays for gov't consumption :math:`G` and transfers to households :math:`T_y` and :math:`T_o`

  .. math::
    G + T_y + T_o =  \tau_L \times wL + \tau_K \times rK

**Household problem**

* HHs maximize :math:`V(c_y,c_o)` subject to their budget constraint in each period

  .. math::
    c_y + s = (1-\tau_L) w + t_y
    c_o = Rs + t_o

where :math:`R = (1 +(1-\tau_K)r)` is the after tax gross interest rate.

Equilibrium definition
--------------------------------------------------------------------------------

* Given sequences of
    * prices :math:`\left\{w_t, R_t \right\}`
    * government policies :math:`\left\{\tau_K, \tau_{L} \right\}` and equilibrium is defined as an allocation of:
* sequences of :math:`\left\{c_{y,t},c_{o,t},s_t\right\}` so that
    * the HH max problem is solved
    * the firm maximization problem is solved, so that:
        * :math:`q = F_K`
        * :math:`w = F_L`
        * :math:`r = q - \delta` is the interest rate
        * :math:`R = (1 +(1-\tau_K)(q - \delta))` is the after tax gross interest rate
    * the gov't budget constraint clears
    * Markets clear:
        * :math:`K=S = N_y * s^*`
        * :math:`ARC: C + S +G = Y - (1-\delta) K`

Functional forms and solutions
--------------------------------------------------------------------------------

* Preferences are given as: :math:`u(c_y) = log(c_y)` and :math:`u(c_o)=log(c_o)`
* We can either set up a Lagrangian with two constraints or simply substitute consumption out of the utilities using the BC.
* We follow the second approach, since the form of the utility functions guarantees interior solutions
* Therefor we don't have to worry about corner solutions a la Kuhn-Tucker

**Substitute the budget set into preferences**

.. math::
  max_s log( (1-\tau_L)w + t_y - s)  + \beta  log(R s + t_o)

* This is now a function in 1 choice variable :math:`s`
* Derive this function w.r.t. :math:`s`

.. math::
  \frac{\partial V}{\partial s}: \frac{1}{ (1-\tau_L)w + t_y - s} =
    \frac{\beta R}{R  s + t_o}

**Solve for optimal household savings: :math:`s^*`**

.. math::
  s^* = \frac{\beta R ((1-\tau_L)w + t_y) - t_o}{(1+\beta)R}

* In equilibrium household savings equals the capital stock: :math:`S = K`
* Aggregate capital stock is therefore: :math:`K = S = N_y \times s^*`
* Given parameter :math:`\beta`, gov't policies :math:`\tau_K, \tau_L, t_y, t_o`
* Measures of young and old agents :math:`N_y, N_o` we can now solve for a steady
  state equilibrium
* The solution is represented by the following equation system
* We will try to reduce the equation system into as few equations as possible,
  ideally into one non-linear equation that we can then solve with a ``Newton
  Algorithm``

**Equation system**

* For starters we assume that government is completely exogenous.
* Assume :math:`L=1` we have the following unknowns: :math:`K,Y,R,w,q` and the following
  equation.
* A solution exists if the number of unknowns is equal to the number of
  equations:

  .. math::
    K=N_y s^* = N_y \frac{\beta R ((1-\tau_L)w + t_y) - t_o}{(1+\beta)R}

  .. math::
    \alpha*Y/K = q

  .. math::
    (1-\alpha)*Y/L = w

  .. math::
    F(K,L) = A K^{\alpha} L^{(1-\alpha)}

  .. math::
    R = (1 + (1-\tau_K)q - \delta)

Method 1: Substituting everything
--------------------------------------------------------------------------------

* Note that :math:`L=1`
* Substitute :math:`Y` out and get :math:`q(K)` and :math:`w(K)`.
* Use :math:`q(K)` in :math:`R` and get :math:`R(K)`

  .. math::
    w = (1-\alpha)*A K^{\alpha}
    R = 1 + (1-\tau_K)(\alpha* A K^{\alpha-1} - \delta)

* Plug :math:`w(K)` and :math:`R(K)` into :math:`K`-equation

* We now have one equation in :math:`K` only

**One equation in K**

We have

.. math::
  K= N_y \frac{\beta (1 + (1-\tau_K)(\alpha* A K^{\alpha-1} - \delta))
  ((1-\tau_L)((1-\alpha)*A K^{\alpha}) + t_y) - t_o}
  {(1+\beta)(1 + (1-\tau_K)(\alpha A K^{\alpha-1} - \delta))}

* Model parameters: :math:`N_y=N_o=1`, :math:`\alpha=0.3`, :math:`A=1`, :math:`\beta = 0.9`, :math:`\delta=0.1`
* We assumed that government was exogenous, so here are some government
  parameters: :math:`\tau_L=0.2`, :math:`\tau_K=0.15`, :math:`T_y=T_o=t_y=t_o=0`
* Solve for :math:`K^*` and then back out :math:`q^*(K^*),w^*(K^*),R^*(K^*), Y^*(K^*)` which are all functions of :math:`K^*`

**Aggregate resource constraint (ARC)**

* Aggregate consumption is:

  .. math::
    C = N_y*c_y + N_o*c_o

* Aggregate government consumption is:

  .. math::
    G = \tau_L \times wL + \tau_K \times rK - N_y*t_y - N_o*t_o

* The aggregate resource constraint (or goods market clearing condition) is:

  .. math::
    C + N_y*s + G = Y + (1-\delta)K


**Python Program 1**


.. code-block:: python

    import numpy as np
    import matplotlib.pyplot as plt
    import math as m
    from scipy import stats as st
    from scipy.optimize import fsolve
    import time            # Imports system time module to time your
    script
    
    plt.close('all')  # close all open figures
    




.. code-block:: python

    # -----------------------------------------------
    # Root finding
    # -----------------------------------------------
    
    # Set parameter values
    N_y     = 1.0
    N_o     = 1.0
    alpha   = 0.3
    A       = 1
    beta    = 0.9
    delta   = 0.0
    tau_L   = 0.2
    tau_K   = 0.15
    t_y     = 0.0
    t_o     = 0.0
    #
    L       = 1
    
    # -------------------------------------------------------------
    # Method 1: Root finding
    # -------------------------------------------------------------
    # Define function of capital K
    
    def func(K):
        s = - K + N_y\
        *((beta*(1+(1-tau_K)*(alpha*A*K**(alpha-1) - delta))* \
        ((1-tau_L)*((1-alpha)*A*K**alpha) + t_y) - t_o) \
        /((1+beta)*(1. + (1-tau_K)*(alpha*A*K**(alpha-1) - delta))))
    
        return s
    
    # Plot the function
    Kmin = 0.0001
    Kmax = 0.3
    # Span grid with gridpoints between Kmin and Kmax
    Kv = np.arange(Kmin, Kmax, (Kmax - Kmin)/200.0)
    # Output vector prefilled with zeros
    fKv = np.zeros(len(Kv),float) # define column vector
    
    for i,K in enumerate(Kv):
        fKv[i] = func(K)
    
    #print("fK=", fK)
    




.. code-block:: python

    fig, ax = plt.subplots()
    ax.plot(Kv, fKv)
    # Plot horizontal line at zero in red
    ax.plot(Kv, np.zeros(len(Kv)), 'r')
    ax.set_title('Capital')
    plt.show()
    

.. image:: _static/Slides_OLG_I_Capital_1.*
   :width: 12 cm




.. code-block:: python

    # Use built in 'fsolve'
    print(" ")
    print(" -------------- Fsolve ------------")
    solutionK = fsolve(func, 2) # starting from K = 2
    
    # Kstar is a numpy array which does not print well
    # We therefore change it into a 'pure' number
    # so we can use the print format to create a nice
    # looking output
    Kstar = solutionK[0]
    
    Ystar = A*Kstar**alpha*L**(1-alpha)
    qstar = alpha*A*Kstar**(alpha-1)
    rstar = qstar - delta
    Rstar = 1. + (1-tau_K)*(qstar - delta)
    wstar = (1.-alpha)*A*Kstar**alpha
    
    # Back out solutions for the rest of the Economy
    # ----------------------------------------------
    # Household values
    sstar = Kstar/N_y
    cystar= (1.-tau_L)*wstar + t_y - sstar
    costar= Rstar*sstar + t_o
    
    # Residual gov't consumption, thrown in the ocean
    Gstar = N_y*tau_L*wstar + N_o*tau_K*rstar*sstar
    
    # Aggregate consumption
    Cstar = N_y*cystar + N_o*costar
    
    # Check the goods market condition or Aggregate resource constraint
    ARC = Ystar - delta*Kstar - Cstar - Gstar
    
    # Print results
    print(" -------------------------------------")
    print(" Root finding ")
    print(" -------------------------------------")
    print("K* = {:6.4f}".format(Kstar))
    print("Y* = {:6.4f}".format(Ystar))
    print("q* = {:6.4f}".format(qstar))
    print("r* = {:6.4f}".format(rstar))
    print("R* = {:6.4f}".format(Rstar))
    print("w* = {:6.4f}".format(wstar))
    print(" -------------------------------------")
    print("ARC = {:6.4f}".format(ARC))
    

::

    
     -------------- Fsolve ------------
     -------------------------------------
     Root finding
     -------------------------------------
    K* = 0.1502
    Y* = 0.5662
    q* = 1.1310
    r* = 1.1310
    R* = 1.9613
    w* = 0.3964
     -------------------------------------
    ARC = 0.0000
    
    



Method 2: Gauss-Seidl Algorithm
--------------------------------------------------------------------------------

.. index:: Gauss-Seidl algorithm

Instead of substituting and solving for one equation in one unknown we can use
the so called **Gauss-Seidl** method

 1. For this method we start with a guess for capital :math:`K_{old}`

 2. We then solve for prices :math:`w,R,q`

 3. We then solve for optimal household savings :math:`s^*`

 4. We then aggregate over all households and get the new capital stock :math:`K_{new}`

 5. We then update capital :math:`K_{old} = \lambda * K_{new} + (1-\lambda) * K_{old}` and repeat from point 1 (:math:`\lambda` is an updating parameter)

**Python Program 2**


.. code-block:: python

    # Guess capital stock
    glamda  = 0.5   # updating parameter
    Kold    = 0.4
    jerror  = 100
    iter    = 1
    while (iter<200) or (jerror>0.001):
        # Solve for prices using expressions for w(K) and q(K)
        q = alpha*A*Kold**(alpha-1)
        w = (1-alpha)*A*Kold**alpha
        R = 1 + (1-tau_K)*(q - delta)
        Knew = N_y* (beta*R*((1-tau_L)*w + t_y) - t_o)/((1+beta)*R)
        # Calculate discrepancy between old and new capital stock
        jerror = abs(Kold-Knew)/Kold
        # Update capital stock
        Kold    = glamda*Knew + (1-glamda)*Kold
        iter = iter +1
    
    # Print results
    Kstar = Knew
    Ystar = A*Kstar**alpha*L**(1-alpha)
    wstar = w
    qstar = q
    Rstar = R
    rstar = qstar - delta
    
    # ------------------------------------
    # Back out solutions for the rest of the Economy
    
    # Household values
    sstar = Kstar/N_y
    cystar= (1-tau_L)*wstar + t_y - sstar
    costar= Rstar*sstar + t_o
    
    # Residual gov't consumption, thrown in the ocean
    Gstar = N_y*tau_L*wstar + N_o*tau_K*rstar*sstar
    
    # Aggregate consumption
    Cstar = N_y*cystar + N_o*costar
    
    # Check the goods market condition or Aggregate resource constraint
    ARC = Ystar - delta*Kstar - Cstar - Gstar
    
    print(" -------------------------------------")
    print(" Gauss-Seidl ")
    print(" -------------------------------------")
    print("Nr. of iterations = " +str(iter))
    print("K* = {:6.4f}".format(Kstar))
    print("Y* = {:6.4f}".format(Ystar))
    print("q* = {:6.4f}".format(qstar))
    print("r* = {:6.4f}".format(rstar))
    print("R* = {:6.4f}".format(Rstar))
    print("w* = {:6.4f}".format(wstar))
    print(" -------------------------------------")
    print("ARC = {:6.4f}".format(ARC))
    

::

     -------------------------------------
     Gauss-Seidl
     -------------------------------------
    Nr. of iterations = 200
    K* = 0.1502
    Y* = 0.5662
    q* = 1.1310
    r* = 1.1310
    R* = 1.9613
    w* = 0.3964
     -------------------------------------
    ARC = 0.0000
    
    


