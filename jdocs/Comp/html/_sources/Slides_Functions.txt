Functions
===========

Use simple user defined functions
-------------------------------------

In Python we can write the following to define a simple function. We start with
two simple function definitions and save them in a file called ``myFunctions.py``


.. code:: python

    import numpy as np
    import matplotlib.pyplot as plt
    import math as m
    from scipy import stats as st
    import time            # Imports system time module to time your
    script
    
    plt.close('all')  # close all open figures
    



We next define our own functions and save them as ``myFunctions.py``


.. code:: python

    # File 1: myFunctions.py
    def hw1(r1, r2):
        s = m.sin(r1 + r2)
        return s
    
    def hw2(r1, r2):
        s = m.sin(r1 + r2)
        print("Hello, World! sin({0:4.2f}+{1:4.2f}) = {2:4.2f}".format(r1,
    r2, s))
    



In a separate Python script we can now import this previous file containing our
functions with the ``import`` command. We save this new Python script as
``Lecture_Functions\myFunctions.py``


.. code:: python

    # File 2: Lecture_Functions\myFunctions.py
    import myFunctions as mfunc
    
    # Now we call these functions with function arguments
    print(mfunc.hw1(2.6, 4.0))
    mfunc.hw2(2.5,5.6)
    

.. code::

    0.31154136351337786
    Hello, World! sin(2.50+5.60) = 0.97
    
    



Advanced Graphing using loops and functions
-----------------------------------------------

Graphing functions with two input arguments z = f(x,y)
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

We next want to plot a function with two input variables:

.. math::

        f(x,y) = sin(x \times y).

We first define an input grid for values of :math:`x` and store the grid in
vector ``xv``, followed by an input grid for values of :math:`y` which is
stored in vector ``yv``.



.. code:: python

    from mpl_toolkits.mplot3d import Axes3D
    
    xv = np.arange(1, 11, 1)
    yv = np.arange(1, 11, 1)
    
    # Meshgrid spans a grid-field over the 2 dimensions
    X, Y = np.meshgrid(xv, xv)
    
    # X and Y are both matrices now
    xn, yn = X.shape
    
    # We next need to evaluate the function
    # repeatedly over the entire grid-field
    
    # Define matrix size n x n with zero entries
    f = np.zeros((xn, yn),float)
    for i in range(xn):
        for j in range(yn):
            #print(i,j)
            # Here you want to use matrix X
            # and not the gridvector xv
            f[i,j] = np.sin(X[i,j]*Y[i,j])
    





.. code:: python

    fig = plt.figure(figsize=(14,16))
    ax = Axes3D(fig)
    ax.plot_wireframe(X, Y, f, rstride=2, cstride=2)
    ax.set_xlabel('x')
    ax.set_ylabel('y')
    ax.set_zlabel('f(x,y)')
    ax.set_title('sin(x,y)')
    plt.show()
    

.. image:: figures/Slides_Functions_Fig3DPlot_1.png
   :width: 12 cm




Same thing but different function
++++++++++++++++++++++++++++++++++++++++

This time we define the function first using the ``def`` command:

.. math::

  g = f(x, y)=(1 + y * 2) ^ {(-x / y)} * (1 + y * 1) ^ {(x / y)}

We then span a grid over `x` and `y` and evaluate
the function `g` at each combination of `(x,y)` using the ``expand.grid`` command.

The grid space between `(x,y)` is created using the ``meshgrid`` command. The
function ``g`` is then evaluated at every point `(x,y)` over the grid. The
``ax.plot_wireframe`` command produces the picture.


.. code:: python

    # Define function
    def g(x, y):
        res = (1 + y * 2) ** (-x / y) * (1 + y * 1) ** (x / y)
        return res
    
    xv = np.linspace(0.01, 1, 20)
    yv = np.linspace(0.01, 1, 20)
    X, Y = np.meshgrid(xv, yv)
    
    xn, yn = X.shape
    
    f = np.zeros((xn,xn),float)   # Define matrix size nxn with zero
    entries
    for i in range(xn):
        for j in range(yn):
            f[i,j] = g(X[i,j], Y[i,j])
    





.. code:: python

    fig = plt.figure(figsize=(14,16))
    ax = Axes3D(fig)
    ax.plot_wireframe(X, Y, f, rstride=2, cstride=2)
    ax.set_title('sin(x,y)')
    ax.set_xlabel('x')
    ax.set_ylabel('y')
    ax.set_zlabel('f(x,y)')
    plt.show()
    

.. image:: figures/Slides_Functions_Fig3DPlot_1.png
   :width: 12 cm



Scope of variables in functions
-------------------------------------------------------------------------------

When we use functions we need to distinguish between variables that are local
to functions and that can therefore be readily accessed and manipulated
by the functions and
variables that are defined outside of a function. These variables usually
cannot be manipulated directly from within a function.


.. code:: python

    def myFun(x):
        x += 1
        print('x in myFun = ', x)
    
    # Call function
    x = 10
    myFun(5)
    print('x = ', x)
    

.. code::

    x in myFun =  6
    x =  10
    
    



Now let's try to access a variable that is defined outside of the function in
what is called the global name space as opposed to the local name space inside of
the function.


.. code:: python

    def myFun2(x):
        x += 1
        print('x inside myFun2 = ', x)
        print('y inside myFun2 = ', y)
    
    # Call function
    y = 10
    myFun2(5)
    

.. code::

    x inside myFun2 =  6
    y inside myFun2 =  10
    
    



Here we see that it is still possible to access variable ``y`` despite the fact
that it is not handed in explicitly. This is bad programming style and should
be avoided. Always try to be as explicit as possible. If you want to use input
argument ``y`` in your function, then define is explicitly as input argument.
Let us now try to change the value of variable ``y`` inside of the function.


.. code:: python

    def myFun3(x):
        x += 1
        print('x inside myFun3 = ', x)
        y = 5
        print('y inside myFun3 = ', y)
    
    # Call function
    y = 10
    myFun3(5)
    print('y =', y)
    

.. code::

    x inside myFun3 =  6
    y inside myFun3 =  5
    y = 10
    
    



Here we use variable ``y`` again and define it as a local variable inside the
function.  However, this change is only valid inside the **local** name space
of the function. Once we are outside the function the value of ``y`` is 10
again. So ``y`` has now two instances, one in the local name space inside the
function and another one in the **global** name space outside of the function.

Let's next try to manipulate a variable that is not explicitly handed into the
function.


.. code:: python

    def myFun4(x):
        x += 1
        print('x inside myFun4 = ', x)
        print('y inside myFun4 = ', y)
        y = 1
        print('y inside myFun4 = ', y)
    
    # Call function
    y = 10
    myFun4(5)
    print('y =', y)
    

.. code::

    <class 'UnboundLocalError'>
    local variable 'y' referenced before assignment
    



Here we get an error because the interpreter defines ``y`` as local variable
and the first print statement happens before the local variable ``y`` is
defined.

We could finally use variable ``y`` as a **global** variable in which case we can
change it outside **and** inside the function. Again, this is considered bad
programming style as it can very quickly lead to errors that will be difficult
to spot.


.. code:: python

    def myFun5(x):
        global y
        x += 1
        print('x inside myFun5 = ', x)
        print('y inside myFun5 = ', y)
        y += 1
        print('y inside myFun5 = ', y)
    
    # Call function
    y = 10
    print('y =', y)
    myFun5(5)
    print('y =', y)
    

.. code::

    y = 10
    x inside myFun5 =  6
    y inside myFun5 =  10
    y inside myFun5 =  11
    y = 11
    
    



Functions with default arguments
-------------------------------------------------------------------------------

A default argument is an argument that assumes a default value if a value is
not provided in the function call for that argument.
The following example illustrates default arguments in a simple function with
two inputs, a name and a number, that the function then prints in the terminal
window.


.. code:: python

    def f_printInfo(name, age = 35):
        "This prints the passed variable values"
        print('-----------------')
        print("Name: {}".format(name))
        print("Age: {}".format(age))
        print('-----------------')
        return
    



We next call the function by differently assigning the name and age
variables.


.. code:: python

    f_printInfo(age=50, name="mike")
    

.. code::

    -----------------
    Name: mike
    Age: 50
    -----------------
    
    



.. code:: python

    f_printInfo(name="mike")
    

.. code::

    -----------------
    Name: mike
    Age: 35
    -----------------
    
    



This next function call is problematic as it reverses the variable order!


.. code:: python

    f_printInfo(50, "john")
    

.. code::

    -----------------
    Name: 50
    Age: john
    -----------------
    
    



If you want to reverse the order you need to provide the keyword argument

so that the function can assign the values correctly.

.. code:: python

    f_printInfo(name="mike", age=50)
    

.. code::

    -----------------
    Name: mike
    Age: 50
    -----------------
    
    



And this one throws a syntax error since we are inconsistent with out function
call by providing a keyword argument for one of the input variables but not for
the other **and** we reverse the order at the same time. Here the interpreter
will not be able to figure out the correct correspondence between inputs and
variable assignments and therefore it throws an error.


.. code:: python

    f_printInfo(name="mike", 50)
    

.. code::

    <class 'SyntaxError'>
    non-keyword arg after keyword arg (chunk, line 2)
    




In class exercises
-------------------------------------------------------------------------------

A simple function again. We next program a function that calculates the
standard deviation of the elements of an input vector.
