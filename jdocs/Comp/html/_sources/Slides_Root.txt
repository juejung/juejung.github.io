Root finding
==============

First steps
---------------

.. code:: python

    import numpy as np
    import matplotlib.pyplot as plt
    import math as m
    from scipy import stats as st
    #
    import time  # Imports system time module to time your script
    #
    plt.close('all')  # close all open figures
    




Define example function
++++++++++++++++++++++++++++++

Define am example function for which we calculate the root, i.e. find :math:`x`
so that :math:`f(x) = 0`.


.. code:: python

    def func(x):
        s = np.log(x) - np.exp(-x)  # function: f(x)
        return s
    



Define the same function  but this time we return the functional value and the
first derivate of the function (i.e. the gradient).


.. code:: python

    def func1(x):
        s = np.log(x) - np.exp(-x)  # function: f(x)
        sp= 1.0/x + np.exp(-x)      # derivative of function: f'(x)
        return np.array([s, sp])
    



Plot the function
++++++++++++++++++++++++


.. code:: python

    xmin = 1
    xmax = 6
    x  = np.arange(xmin, xmax, (xmax - xmin)/200.0)
    fx = np.zeros(len(x),float) # define column vector
    for i in range(len(x)):
        fx[i] = func(x[i])
    
    #print "fx=" +str(fx)
    




.. code:: python

    fig, ax = plt.subplots()
    ax.plot(x, fx)
    ax.plot(x, np.zeros(len(x)))
    # Create a title with a red, bold/italic font
    plt.show()
    

.. image:: figures/Slides_Root_FigAutos_1.png
   :width: 12 cm



Newton-Raphson
-------------------------------------------------------------------------------

The method
+++++++++++++++++


We start with an initial guess :math:`x_0`. The tangent line through the
initial guess can be defined as:

:math:`f'(x_0)=\frac{f(x_0)-y}{x_0-x}`
This line crosses the x-axis at point :math:`x_1` so that
:math:`f'(x_0)=\frac{f(x_0)-0}{x_0-x_1}`
which we can solve for :math:`x_1` as:
:math:`x_1 = x_0 - \frac{f(x_0)}{f'(x_0)}.`
We can repeat this successively using the iterative procedure:
:math:`\boxed{x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}}`

Define the Newton-Raphson algorithm
++++++++++++++++++++++++++++++++++++++++++


.. code:: python

    def newtonraphson(ftn, x0, tol = 1e-9, maxiter = 100):
        # Newton_Raphson algorithm for solving ftn(x)[1] == 0
        # we assume that ftn is a function of a single variable that
    returns
        # the function value and the first derivative as a vector of
    length 2
        #
        # x0 is the initial guess at the root
        # the algorithm terminates when the function value is within
    distance
        # tol of 0, or the number of iterations exceeds max.iter
        # initialise
    
        x = x0
        fx = ftn(x)
        iter =  0
        # continue iterating until stopping conditions are met
        while ((abs(fx[0]) > tol) and (iter < maxiter)):
            x = x - fx[0]/fx[1]
            fx = ftn(x)
            iter =  iter + 1
            print("At iteration " + str(iter) + " value of x is: " +
    str(x))
    
        # output depends on success of algorithm
        if (abs(fx[0]) > tol):
            print("Algorithm failed to converge")
            return(NULL)
        else:
            print("fx = ", fx[0])
            print("Algorithm converged")
            return(x)
    




Calculate the root of the function calling 'newtonraphson'
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


.. code:: python

    newtonraphson(func1, 2)
    

.. code::

    At iteration 1 value of x is: 1.12201964531
    At iteration 2 value of x is: 1.29499697044
    At iteration 3 value of x is: 1.30970906266
    At iteration 4 value of x is: 1.30979958242
    At iteration 5 value of x is: 1.3097995858
    fx =  -5.55111512313e-17
    Algorithm converged
    
    



Secant method
-------------------------------------------------------------------------------

Define the secant method
+++++++++++++++++++++++++++++++

In this case we start with two starting values :math:`x_0` and :math:`x_1` and
put a line through the functional values :math:`f(x_0)` and :math:`f(x_1)`. The
advantage of this method is that we do not have to calculate the first
derivative of the function.The line through :math:`f(x_0)` and :math:`f(x_1)`
is expressed as: :math:`\frac{y-f(x_1)}{x-x_1} =
\frac{f(x_0)-f(x_1)}{x_0-x_1}.`

The point :math:`x_2` where this line crosses the x-axis can be found using:
:math:`\frac{0-f(x_1)}{x_2-x_1} = \frac{f(x_0)-f(x_1)}{x_0-x_1},` which results
in :math:`x_2 = x_1 - f(x_1)\frac{x_0-x_1}{f(x_0)-f(x_1)}.`

The iterative procedure can be written as: :math:`\boxed{x_{n+1} = x_n -
f(x_n)\frac{x_{n-1}-x_n}{f(x_{n-1})-f(x_n)}}`

Note that if :math:`x_0` and :math:`x_1` are close together then:
:math:`f'(x_n) \approx f(x_1)\frac{f(x_n)-f(x_{n-1})}{x_n-x_{n-1}}.`


The algorithm of the secant method
+++++++++++++++++++++++++++++++++++++++++


.. code:: python

    def secant(ftn, x0, x1, tol = 1e-9, maxiter = 100):
        # Secant algorithm for solving ftn(x) == 0
        # we assume that ftn is a function of a single variable that
    returns
        # the function value
        #
        # x0 and x1 are the initial guesses around the root
        # the algorithm terminates when the function value is within
    distance
        # tol of 0, or the number of iterations exceeds max.iter
        #
        # initialize
        fx0 = ftn(x0)
        fx1 = ftn(x1)
        iter =  0
        #
        # continue iterating until stopping conditions are met
        while ((abs(fx1) > tol) and (iter < maxiter)):
            x  = x1 - fx1 * (x1-x0)/(fx1 - fx0)
            fx0 = ftn(x1)
            fx1 = ftn(x)
            x0  = x1
            x1  = x
            iter =  iter + 1
            print("At iteration "+str(iter)+" value of x is: "+str(x))
    # output depends on success of algorithm
        if (abs(fx1) > tol):
            print("Algorithm failed to converge")
            return(NULL)
        else:
           print("Algorithm converged")
           return(x)
    



Calculate the root of the function calling 'secant'
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


.. code:: python

    secant(func, 1,2)
    

.. code::

    At iteration 1 value of x is: 1.39741048217
    At iteration 2 value of x is: 1.28547612015
    At iteration 3 value of x is: 1.31067675808
    At iteration 4 value of x is: 1.30980839802
    At iteration 5 value of x is: 1.30979958261
    At iteration 6 value of x is: 1.3097995858
    Algorithm converged
    
    



Bisection
-------------------------------------------------------------------------------

Define the bisection method
++++++++++++++++++++++++++++++++++

The bisection method is the most robust method, but it is slow. We start with
two values :math:`x_l < x_r` which bracket the root of the function. It
therefore must hold that :math:`f(x_l) f(x_r) < 0`. The algorithm then
repeatedly brackets around the root in the following systematic way:

 1. if :math:`x_r - x_l \le \epsilon` then stop
 2. calculate midpoint: :math:`x_m = (x_l+x_r)/2`
 3. if :math:`f(x_m)==0` stop
 4. if :math:`f(x_l) f(x_r) < 0` then set :math:`x_r = x_m` otherwise :math:`x_l=x_m`
 5. go back to step 1


The algorithm of the bisection method
++++++++++++++++++++++++++++++++++++++++++++


.. code:: python

    def bisection(ftn, xl, xr, tol = 1e-9):
        # applies the bisection algorithm to find x such that ftn(x) == 0
        # we assume that ftn is a function of a single variable
        #
        # x.l and x.r must bracket the fixed point, that is
        # x.l < x.r and ftn(x.l) * ftn(x.r) < 0
        #
        # the algorithm iteratively refines x.l and x.r and terminates
    when
        # x.r - x.l <= tol
    
        # check inputs
        if (xl >= xr):
            print("error: xl >= xr")
            return(NULL)
    
        fl = ftn(xl)
        fr = ftn(xr)
    
        if (fl == 0):
            return(x.l)
        elif (fr == 0):
            return(x.r)
        elif (fl * fr > 0):
            print("error: ftn(xl) * ftn(xr) > 0")
            return(NULL)
    
        # successively refine x.l and x.r
        n = 0
        while ((xr - xl) > tol):
            xm = (xl + xr)/2.0
            fm = ftn(xm)
            if (fm == 0):
                return(fm)
            elif (fl * fm < 0):
                xr = xm
                fr = fm
            else:
                xl = xm
                fl = fm
            n = n + 1
            print("at iteration "+ str(n) + " the root lies between " +
    str(xl) + " and " + str(xr))
    
        # return (approximate) root
        return ((xl + xr)/2.0)
    



Calculate the root of the function calling 'bisection'
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


.. code:: python

    bisection(func, 1,2)
    

.. code::

    at iteration 1 the root lies between 1 and 1.5
    at iteration 2 the root lies between 1.25 and 1.5
    at iteration 3 the root lies between 1.25 and 1.375
    at iteration 4 the root lies between 1.25 and 1.3125
    at iteration 5 the root lies between 1.28125 and 1.3125
    at iteration 6 the root lies between 1.296875 and 1.3125
    at iteration 7 the root lies between 1.3046875 and 1.3125
    at iteration 8 the root lies between 1.30859375 and 1.3125
    at iteration 9 the root lies between 1.30859375 and 1.310546875
    at iteration 10 the root lies between 1.3095703125 and 1.310546875
    at iteration 11 the root lies between 1.3095703125 and 1.31005859375
    at iteration 12 the root lies between 1.3095703125 and 1.309814453125
    at iteration 13 the root lies between 1.3096923828125 and
    1.309814453125
    at iteration 14 the root lies between 1.30975341796875 and
    1.309814453125
    at iteration 15 the root lies between 1.309783935546875 and
    1.309814453125
    at iteration 16 the root lies between 1.3097991943359375 and
    1.309814453125
    at iteration 17 the root lies between 1.3097991943359375 and
    1.3098068237304688
    at iteration 18 the root lies between 1.3097991943359375 and
    1.3098030090332031
    at iteration 19 the root lies between 1.3097991943359375 and
    1.3098011016845703
    at iteration 20 the root lies between 1.3097991943359375 and
    1.309800148010254
    at iteration 21 the root lies between 1.3097991943359375 and
    1.3097996711730957
    at iteration 22 the root lies between 1.3097994327545166 and
    1.3097996711730957
    at iteration 23 the root lies between 1.3097995519638062 and
    1.3097996711730957
    at iteration 24 the root lies between 1.3097995519638062 and
    1.309799611568451
    at iteration 25 the root lies between 1.3097995817661285 and
    1.309799611568451
    at iteration 26 the root lies between 1.3097995817661285 and
    1.3097995966672897
    at iteration 27 the root lies between 1.3097995817661285 and
    1.3097995892167091
    at iteration 28 the root lies between 1.3097995854914188 and
    1.3097995892167091
    at iteration 29 the root lies between 1.3097995854914188 and
    1.309799587354064
    at iteration 30 the root lies between 1.3097995854914188 and
    1.3097995864227414
    
    



Using built in unit-root function
-------------------------------------------------------------------------------

The built in functions are part of the
`scipy.optimize <http://docs.scipy.org/doc/scipy/reference/optimize.html#module-scipy.optimize>`_ library.
The functions work very similar to the ones that we just wrote ourselves. It
usually requires that we first define our function. We then hand it to the
solver algorithm with a starting guess of the root position.
The first root finding algorithm is called
`root <http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.root.html#scipy.optimize.root>`_


.. code:: python

    from scipy.optimize import root
    guess = 2
    print(" ")
    print(" -------------- Root ------------")
    result = root(func, guess) # starting from x = 2
    myroot = result.x  # Grab number from result dictionary
    print("The root of func is at {}".format(myroot))
    

.. code::

    
     -------------- Root ------------
    The root of func is at [ 1.31]
    
    




The second root finding algorithm is called
`fsolve <http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.root.html#scipy.optimize.fsolve>`_


.. code:: python

    from scipy.optimize import fsolve
    
    guess = 2
    print(" ")
    print(" -------------- Fsolve ------------")
    result = fsolve(func, guess) # starting from x = 2
    myroot = result[0] # Grab number from result dictionary
    print("The root is at {}".format(result))
    

.. code::

    
     -------------- Fsolve ------------
    The root is at [ 1.31]
    
    



or

Homework
-------------------------------------------------------------------------------

:doc:`./Lecture_Root/Homework/Homework_Root`

