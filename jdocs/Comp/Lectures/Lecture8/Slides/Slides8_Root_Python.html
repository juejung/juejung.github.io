<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<title>Root finding</title>

<base target="_blank"/>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: #F9F6F4;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
   background-color: #C9A798;
}

h2 { 
   font-size:1.8em; 
   background-color: #BCC632; 
}

h3 { 
   font-size:1.4em; 
   background-color: #D4DBB2;
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
}

pre code {
   display: block; padding: 0.5em;
}

code.r {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}
</style>



<!-- MathJax scripts -->
<script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


</head>

<body>
<h1>Root finding</h1>

<h1>1 First steps</h1>

<pre><code class="python">import math
from pylab import *
from scipy.optimize import fsolve
close(&#39;all&#39;)  # close all open figure
</code></pre>

<pre><code>
</code></pre>

<h2>1.1 Define example function</h2>

<p>Define am example function for which we calculate the root, i.e. find x so that f(x) = 0</p>

<pre><code class="python">def func(x):
    s = log(x) - exp(-x)  # function: f(x)
    return s
</code></pre>

<pre><code>
</code></pre>

<p>Define the same function  but this time we return the functional value and the first derivate of the function (i.e. the gradient).</p>

<pre><code class="python">def func1(x):
    s = log(x) - exp(-x)  # function: f(x)
    sp= 1.0/x + exp(-x)      # derivative of function: f&#39;(x)
    return array([s,sp])    
</code></pre>

<pre><code>
</code></pre>

<h2>1.2 Plot the function</h2>

<pre><code class="python">xmin = 1
xmax = 6
x  = arange(xmin, xmax, (xmax - xmin)/200.0)
fx = zeros(len(x),float) # define column vector
for i in range(len(x)):
    fx[i] = func(x[i])

#print &quot;fx=&quot; +str(fx)

fig1 = figure()
plot(x, fx)
plot(x, zeros(len(x)))
show()
</code></pre>

<pre><code>Traceback (most recent call last):
  File &quot;&lt;string&gt;&quot;, line 3, in &lt;module&gt;
NameError: name &#39;arange&#39; is not defined
</code></pre>

<hr/>

<h1>2 Newton-Raphson</h1>

<h2>2.1 The method</h2>

<p>We start with an initial guess \( x_0\). The tangent line through the initial guess can be defined as:</p>

<p>\[ f'(x_0)=\frac{f(x_0)-y}{x_0-x}\]<br/>
This line crosses the x-axis at point \( x_1\) so that<br/>
\[ f'(x_0)=\frac{f(x_0)-0}{x_0-x_1}\] <br/>
which we can solve for \( x_1\) as:<br/>
\[ x_1 = x_0 - \frac{f(x_0)}{f'(x_0)}.\]<br/>
We can repeat this successively using the iterative procedure:<br/>
\[  \boxed{x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}}\]</p>

<h2>2.2 Define the Newton-Raphson algorithm</h2>

<pre><code class="python">def newtonraphson(ftn, x0, tol = 1e-9, maxiter = 100):
    # Newton_Raphson algorithm for solving ftn(x)[1] == 0
    # we assume that ftn is a function of a single variable that returns
    # the function value and the first derivative as a vector of length 2
    #
    # x0 is the initial guess at the root
    # the algorithm terminates when the function value is within distance
    # tol of 0, or the number of iterations exceeds max.iter
    # initialise

    x = x0
    fx = ftn(x)
    iter =  0
    # continue iterating until stopping conditions are met
    while ((abs(fx[0]) &gt; tol) and (iter &lt; maxiter)):
        x = x - fx[0]/fx[1]
        fx = ftn(x)
        iter =  iter + 1
        print &quot;At iteration &quot; + str(iter) + &quot; value of x is: &quot; +str(x)

    # output depends on success of algorithm
    if (abs(fx[0]) &gt; tol):
        print &quot;Algorithm failed to converge&quot;
        return(NULL)
    else:
        print &quot;fx = &quot; + str(fx[0])
        print &quot;Algorithm converged&quot;
        return(x)
</code></pre>

<pre><code>
</code></pre>

<h2>2.3 Calculate the root of the function calling &#39;newtonraphson&#39;</h2>

<pre><code class="python">newtonraphson(func1, 2)
</code></pre>

<pre><code>Traceback (most recent call last):
  File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;
NameError: name &#39;newtonraphson&#39; is not defined
</code></pre>

<hr/>

<h1>3 Secant method</h1>

<h2>3.1 Define the secant method</h2>

<p>In this case we start with two starting values \( x_0\) and \( x_1\) and put a line through the functional values \( f(x_0)\) and \( f(x_1)\). The advantage of this method is that we do not have to calculate the first derivative of the function.The line through \( f(x_0)\) and \( f(x_1)\) is expressed as:<br/>
\[ \frac{y-f(x_1)}{x-x_1} = \frac{f(x_0)-f(x_1)}{x_0-x_1}.\]</p>

<p>The point \( x_2\) where this line crosses the x-axis can be found using:<br/>
\[ \frac{0-f(x_1)}{x_2-x_1} = \frac{f(x_0)-f(x_1)}{x_0-x_1},\]<br/>
which results in<br/>
\[ x_2 = x_1 - f(x_1)\frac{x_0-x_1}{f(x_0)-f(x_1)}.\]</p>

<p>The iterative procedure can be written as:<br/>
\[ \boxed{x_{n+1} = x_n - f(x_n)\frac{x_{n-1}-x_n}{f(x_{n-1})-f(x_n)}}\]</p>

<p>Note that if markdown<em>math_80000025000000008000002600000000 and \( x_1\) are close together then:<br/>
$$f&#39;(x_n) \approx f(x_1)\frac{f(x_n)-f(x</em>{n-1})}{x<em>n-x</em>{n-1}}.$$</p>

<h2>3.2 The algorithm of the secant method</h2>

<pre><code class="python">def secant(ftn, x0, x1, tol = 1e-9, maxiter = 100):
    # Secant algorithm for solving ftn(x) == 0
    # we assume that ftn is a function of a single variable that returns
    # the function value
    #
    # x0 and x1 are the initial guesses around the root
    # the algorithm terminates when the function value is within distance
    # tol of 0, or the number of iterations exceeds max.iter
    #
    # initialize
    fx0 = ftn(x0)
    fx1 = ftn(x1)
    iter =  0
    #
    # continue iterating until stopping conditions are met
    while ((abs(fx1) &gt; tol) and (iter &lt; maxiter)):
        x  = x1 - fx1 * (x1-x0)/(fx1 - fx0) 
        fx0 = ftn(x1)
        fx1 = ftn(x)
        x0  = x1
        x1  = x
        iter =  iter + 1
        print &quot;At iteration &quot;+str(iter)+&quot; value of x is: &quot;+str(x)
# output depends on success of algorithm
    if (abs(fx1) &gt; tol):
        print &quot;Algorithm failed to converge&quot;
        return(NULL)
    else:
       print &quot;Algorithm converged&quot;
       return(x)
</code></pre>

<pre><code>
</code></pre>

<h2>3.3 Calculate the root of the function calling &#39;secant&#39;</h2>

<pre><code class="python">secant(func, 1,2)
</code></pre>

<pre><code>Traceback (most recent call last):
  File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;
NameError: name &#39;secant&#39; is not defined
</code></pre>

<hr/>

<h1>4 Bisection</h1>

<h2>4.1 Define the bisection method</h2>

<p>The bisection method is the most robust method, but it is slow. We start with two values \( x_l < x_r\) which bracket the root of the function. It therefore must hold that \( f(x_l) f(x_r) < 0\). The algorithm then repeatedly brackets around the root in the following systematic way:</p>

<ol>
<li>if \( x_r - x_l \le \epsilon\) then stop</li>
<li>calculate midpoint: \( x_m = (x_l+x_r)/2\)</li>
<li>if \( f(x_m)==0\) stop</li>
<li>if \( f(x_l) f(x_r) < 0\) then set \( x_r = x_m\) otherwise \( x_l=x_m\)</li>
<li>go back to step 1</li>
</ol>

<h2>4.2 The algorithm of the bisection method</h2>

<pre><code class="python">def bisection(ftn, xl, xr, tol = 1e-9):
    # applies the bisection algorithm to find x such that ftn(x) == 0
    # we assume that ftn is a function of a single variable
    #
    # x.l and x.r must bracket the fixed point, that is
    # x.l &lt; x.r and ftn(x.l) * ftn(x.r) &lt; 0
    #
    # the algorithm iteratively refines x.l and x.r and terminates when
    # x.r - x.l &lt;= tol

    # check inputs
    if (xl &gt;= xr):
        print &quot;error: xl &gt;= xr&quot;
        return(NULL)

    fl = ftn(xl)
    fr = ftn(xr)

    if (fl == 0):
        return(x.l)
    elif (fr == 0):
        return(x.r)
    elif (fl * fr &gt; 0):
        print &quot;error: ftn(xl) * ftn(xr) &gt; 0&quot;
        return(NULL)

    # successively refine x.l and x.r
    n = 0
    while ((xr - xl) &gt; tol):
        xm = (xl + xr)/2.0
        fm = ftn(xm)
        if (fm == 0):
            return(fm)
        elif (fl * fm &lt; 0):
            xr = xm
            fr = fm
        else:
            xl = xm
            fl = fm
        n = n + 1
        print &quot;at iteration &quot;+str(n)+ &quot; the root lies between &quot;+str(xl)+ &quot; and &quot;+str(xr)

    # return (approximate) root
    return ((xl + xr)/2.0)

</code></pre>

<pre><code>
</code></pre>

<h2>4.3 Calculate the root of the function calling &#39;bisection&#39;</h2>

<pre><code class="python">bisection(func, 1,2)
</code></pre>

<pre><code>Traceback (most recent call last):
  File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;
NameError: name &#39;bisection&#39; is not defined
</code></pre>

<h1>5 Using built in unit-root function</h1>

<pre><code class="python">print &quot; &quot;
print &quot; -------------- Fsolve ------------&quot;
result = fsolve(func, 2) # starting from x = 2
print result
</code></pre>

<pre><code>
 -------------- Fsolve ------------
Traceback (most recent call last):
  File &quot;&lt;string&gt;&quot;, line 3, in &lt;module&gt;
NameError: name &#39;fsolve&#39; is not defined
</code></pre>

</body>

</html>
