<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<title>Optimization</title>

<base target="_blank"/>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: #F9F6F4;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
   background-color: #C9A798;
}

h2 { 
   font-size:1.8em; 
   background-color: #BCC632; 
}

h3 { 
   font-size:1.4em; 
   background-color: #D4DBB2;
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
}

pre code {
   display: block; padding: 0.5em;
}

code.r {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}
</style>



<!-- MathJax scripts -->
<script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


</head>

<body>
<h1>Optimization</h1>

<h1>1 Univariate function optimization</h1>

<h2>1.1 Example function to be maximized</h2>

<pre><code class="python">import math
from pylab import *
import scipy.optimize as optimize
close(&#39;all&#39;)  # close all open figure
</code></pre>

<pre><code>
</code></pre>

<p>Here we want to optimize a univariate function: f1</p>

<pre><code class="python">def f1simple(x):
    # gamma(2,3) density
    if (x &lt; 0): 
        return (0)
    if (x == 0): 
        return (NaN)
    y = exp(-2*x)
    return (4 * x**2 * y)
</code></pre>

<pre><code>
</code></pre>

<p>Next we define the same function but return f(x), f&#39;(x), and f&#39;&#39;(x) </p>

<pre><code class="python">def f1(x):
    # gamma(2,3) density
    if (x &lt; 0): 
        return array([0, 0, 0])
    if (x == 0): 
        return array([0, 0, NaN])
    y = exp(-2.0*x)
    return array([4.0 * x**2.0 * y, 8.0 * x*(1.0-x)*y, 8.0*(1.0 - 2.0 * x**2.0)*y])
</code></pre>

<pre><code>
</code></pre>

<p>Some algorithms that we&#39;ll encounter later will minimize a function. So if we want to maximize our function we have to define it as a negate function, that is: \( g(x) = -f(x)\) then \( min(g(x))\) is the same as \( max(f(x))\).</p>

<pre><code class="python">def f1simpleNeg(x):
    # gamma(2,3) density
    if (x &lt; 0): 
        return (0)
    if (x == 0): 
        return (NaN)
    y = exp(-2*x)
    return (-(4 * x**2 * y))
</code></pre>

<pre><code>
</code></pre>

<p>Plotting the function is always a good idea!</p>

<pre><code class="python">xmin = 0
xmax = 6
x  = arange(xmin, xmax, (xmax - xmin)/200.0)
fx = zeros(len(x),float) # define column vector
for i in range(len(x)):
    fx[i] = f1(x[i])[0]

#print &quot;fx=&quot; +str(fx)

fig1 = figure()
plot(x, fx)
plot(x, zeros(len(x)))
show()
</code></pre>

<pre><code>Traceback (most recent call last):
  File &quot;&lt;string&gt;&quot;, line 3, in &lt;module&gt;
NameError: name &#39;arange&#39; is not defined
</code></pre>

<h2>1.2 Optimization methods</h2>

<h3>1.2.1 Newton&#39;s method</h3>

<pre><code class="python">def newton(f3, x0, tol = 1e-9, nmax = 100):
    # Newton&#39;s method for optimization, starting at x0
    # f3 is a function that given x returns the vector
    # (f(x), f&#39;(x), f&#39;&#39;(x)), for some f
    x = x0
    f3x = f3(x)
    n = 0
    while ((abs(f3x[1]) &gt; tol) and (n &lt; nmax)):
        x = x - f3x[1]/f3x[2]
        f3x = f3(x)
        n = n + 1
    if (n == nmax):
        print &quot;newton failed to converge&quot;
    else:
        return(x)
</code></pre>

<pre><code>
</code></pre>

<h3>1.2.2 Golden section method</h3>

<pre><code class="python">def gsection(ftn, xl, xr, xm, tol = 1e-9):
    # applies the golden-section algorithm to maximise ftn
    # we assume that ftn is a function of a single variable
    # and that x.l &lt; x.m &lt; x.r and ftn(x.l), ftn(x.r) &lt;= ftn(x.m)
    #
    # the algorithm iteratively refines x.l, x.r, and x.m and terminates
    # when x.r - x.l &lt;= tol, then returns x.m
    # golden ratio plus one
    gr1 = 1 + (1 + math.sqrt(5))/2
#   
    # successively refine x.l, x.r, and x.m
    fl = ftn(xl)
    fr = ftn(xr)
    fm = ftn(xm)
    while ((xr - xl) &gt; tol):
        if ((xr - xm) &gt; (xm - xl)):
            y = xm + (xr - xm)/gr1
            fy = ftn(y)
            if (fy &gt;= fm):
                xl = xm
                fl = fm
                xm = y
                fm = fy
            else:
                xr = y
                fr = fy
        else:
            y = xm - (xm - xl)/gr1
            fy = ftn(y)
            if (fy &gt;= fm):
                xr = xm
                fr = fm
                xm = y
                fm = fy
            else:
                xl = y
                fl = fy
    return(xm)
</code></pre>

<pre><code>
</code></pre>

<h3>1.2.3 Built in &#39;optimize.fmin&#39; function</h3>

<p>The function &#39;optimize.fmin&#39; is in scipy.optimize as optimize</p>

<h2>1.3 Maximize function: f1</h2>

<h3>1.3.1 Maximizing using the Newton method</h3>

<pre><code class="python">print &quot; -----------------------------------&quot;
print &quot; Newton results &quot;
print &quot; -----------------------------------&quot;
print str(newton(f1, 0.25))
print str(newton(f1, 0.5))
print str(newton(f1, 0.75))
print str(newton(f1, 1.75))
</code></pre>

<pre><code> -----------------------------------
 Newton results 
 -----------------------------------
Traceback (most recent call last):
  File &quot;&lt;string&gt;&quot;, line 4, in &lt;module&gt;
NameError: name &#39;newton&#39; is not defined
</code></pre>

<h3>1.3.2 Maximizing using the Secant method</h3>

<pre><code class="python">print &quot; -----------------------------------&quot;
print &quot; Golden section results &quot;
print &quot; -----------------------------------&quot;
print str(gsection(f1simple, 0.1, 0.25, 1.3))
print str(gsection(f1simple, 0.25, 0.5, 1.7))
print str(gsection(f1simple, 0.6, 0.75, 1.8))
print str(gsection(f1simple, 0.0, 2.75, 5.0))
</code></pre>

<pre><code> -----------------------------------
 Golden section results 
 -----------------------------------
Traceback (most recent call last):
  File &quot;&lt;string&gt;&quot;, line 4, in &lt;module&gt;
NameError: name &#39;gsection&#39; is not defined
</code></pre>

<h3>1.3.3 Maximizing using the built in optimize function</h3>

<pre><code class="python">print &quot; -----------------------------------&quot;
print &quot; optimize.fmin &quot;
print &quot; -----------------------------------&quot;
print str(optimize.fmin(f1simpleNeg, 0.25))
print str(optimize.fmin(f1simpleNeg, 0.5))
print str(optimize.fmin(f1simpleNeg, 0.75))
print str(optimize.fmin(f1simpleNeg, 1.75))
</code></pre>

<pre><code> -----------------------------------
 optimize.fmin 
 -----------------------------------
Traceback (most recent call last):
  File &quot;&lt;string&gt;&quot;, line 4, in &lt;module&gt;
NameError: name &#39;optimize&#39; is not defined
</code></pre>

<hr/>

<h1>2 Multivariate optimization</h1>

<h2>2.1 Define multivariate (i.e. bivariate) example functions</h2>

<p>Here we want to optimize the following functions: f3, f4</p>

<h3>2.1.1 Function f3</h3>

<pre><code class="python">def f3simple(x):
    a = x[0]**2/2.0 - x[1]**2/4.0
    b = 2*x[0] - exp(x[1])
    f = sin(a)*cos(b)
    return(f)
</code></pre>

<pre><code>
</code></pre>

<p>Its negative version: </p>

<pre><code class="python">def f3simpleNeg(x):
    a = x[0]**2/2.0 - x[1]**2/4.0
    b = 2*x[0] - exp(x[1])
    f = -sin(a)*cos(b)
    return(f)
</code></pre>

<pre><code>
</code></pre>

<p>And the version that returns f(x), f&#39;(x) (i.e. the gradient), and f&#39;&#39;(x) (i.e. the Hessian):</p>

<pre><code class="python">def f3(x):
    a = x[0]**2/2.0 - x[1]**2/4.0
    b = 2*x[0] - exp(x[1])
    f = sin(a)*cos(b)
    f1 = cos(a)*cos(b)*x[0] - sin(a)*sin(b)*2
    f2 = -cos(a)*cos(b)*x[1]/2 + sin(a)*sin(b)*exp(x[1])
    f11 = -sin(a)*cos(b)*(4 + x[0]**2) + cos(a)*cos(b) - cos(a)*sin(b)*4*x[0]
    f12 = sin(a)*cos(b)*(x[0]*x[1]/2.0 + 2*exp(x[1])) + cos(a)*sin(b)*(x[0]*exp(x[1]) + x[1])
    f22 = -sin(a)*cos(b)*(x[1]**2/4.0 + exp(2*x[1])) - cos(a)*cos(b)/2.0 - cos(a)*sin(b)*x[1]*exp(x[1]) + sin(a)*sin(b)*exp(x[1])
    return (f, array([f1, f2]), array([[f11, f12], [f12, f22]])) # Function f3 returns: f(x), f&#39;(x), and f&#39;&#39;(x)
</code></pre>

<pre><code>
</code></pre>

<p>Plot function f3:</p>

<pre><code class="python">fig2 = figure()
ax = gca(projection=&#39;3d&#39;)
X = arange(-3, 3, .1)
Y = arange(-3, 3, .1)
X, Y = meshgrid(X, Y)

Z = zeros((len(X),len(Y)),float)
for i in range(len(X)):
    for j in range(len(Y)):
        Z[i][j] = f3simple([X[i][j],Y[i][j]])
surf = ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=cm.jet,
        linewidth=0, antialiased=False)
show()
</code></pre>

<pre><code>Traceback (most recent call last):
  File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;
NameError: name &#39;figure&#39; is not defined
</code></pre>

<h3>2.1.2 Function f4</h3>

<p>This is the same function, so we won&#39;t repeat it here.</p>

<h2>2.2 Multivariate optimization methods</h2>

<h3>2.2.1 Newton</h3>

<pre><code class="python">def newtonMult(f3, x0, tol = 1e-9, nmax = 100):
    # Newton&#39;s method for optimisation, starting at x0
    # f3 is a function that given x returns the list
    # {f(x), grad f(x), Hessian f(x)}, for some f
    x = x0
    f3x = f3(x)
    n = 0
    while ((max(abs(f3x[1])) &gt; tol) and (n &lt; nmax)):
        x = x - linalg.solve(f3x[2], f3x[1])
        f3x = f3(x)
        n = n + 1
    if (n == nmax):
        print &quot;newton failed to converge&quot;
    else:
        return(x)
</code></pre>

<pre><code>
</code></pre>

<h3>2.2.2 Built in &#39;fmin_tnc&#39; in scipy.optimize.tnc</h3>

<h2>2.3 Maximize multivariate function</h2>

<p>We use various starting values to see whether we can find more than one optimum.</p>

<pre><code class="python">for x0 in arange(1.4, 1.6, 0.1):
    for y0 in arange(0.4, 0.7, 0.1):
        print &quot;Newton: f3        &quot; +str([x0,y0]) + &#39; --&gt; &#39; + str(newtonMult(f3, array([x0,y0])))  # This algorithm requires f(x), f&#39;(x), and f&#39;&#39;(x)
        print &quot;optimize.fmin: f3 &quot; +str([x0,y0]) + &#39; --&gt; &#39; + str(optimize.fmin(f3simpleNeg, array([x0,y0])))        
        print &quot; ----------------------------------------- &quot;
</code></pre>

<pre><code>Traceback (most recent call last):
  File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;
NameError: name &#39;arange&#39; is not defined
</code></pre>

</body>

</html>
