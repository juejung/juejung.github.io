[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Computational Economics",
    "section": "",
    "text": "1 Preface\nA cross listed undergraduate/graduate (Econ 431/631) level economics course offered by the Department of Economics at Towson University in Maryland, USA.\nCourse Instructor: Prof. Juergen Jung\nemail: jjung@towson.edu\nweb: https://juejung.github.io/\nThis book was typeset with Quarto. Visit https://quarto.org/docs/books.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "CourseAdministration.html",
    "href": "CourseAdministration.html",
    "title": "2  Course Administration",
    "section": "",
    "text": "2.1 Installing Python\nNext you have to download Python. If you are running Linux or Apple, some version of Python is already installed. However, these basic Python versions miss some of the important scientific packages that you will still have to install. The most important ones are numpy, scipy, and matplotlib. If you “google” these packages you should be able to find them on the internet. They need to be installed.\nI also recommend that you install an IDE for Python. One that is very amenable for scientific computation is called Spyder. Spyder is part of most Linux repositories and can easily be installed from there.\nThe easiest way to install Python and Spyder and all sorts of other useful packages for scientific computing is to install Python via the Anaconda distribution from: https://www.anaconda.com/download This is a simple one click installation process which works for Linux/Windows/Mac and it installs everything! When prompted which version you want to install go with the latest one for your system which at the time of writing this is Python 3.10. You should install the 64 bit version, not the 32 bit version.",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Course Administration</span>"
    ]
  },
  {
    "objectID": "CourseAdministration.html#installing-r-and-r-studio",
    "href": "CourseAdministration.html#installing-r-and-r-studio",
    "title": "2  Course Administration",
    "section": "2.2 Installing R and R Studio",
    "text": "2.2 Installing R and R Studio\nTo install R and R-Studio, follow these steps:\n\nInstall R:\n\nGo to the CRAN (Comprehensive R Archive Network) website.\nChoose a CRAN mirror location near you.\nDownload and run the R installer for your operating system (Windows, macOS, or Linux).\nFollow the installation instructions, which are usually straightforward.\n\nInstall R-Studio:\n\nGo to the R-Studio download page.\nChoose the R-Studio Desktop edition (free version).\nDownload the R-Studio installer for your operating system (Windows, macOS, or Linux).\nRun the installer and follow the installation instructions.\n\n\nAfter completing these steps, you’ll have both R and R-Studio installed on your system. You can now open R-Studio, and it will work seamlessly with your R installation. R-Studio provides a user-friendly interface and various tools to help you work with R more effectively.",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Course Administration</span>"
    ]
  },
  {
    "objectID": "CourseAdministration.html#submitting-homework-the-midterm-and-the-final-via-dropbox",
    "href": "CourseAdministration.html#submitting-homework-the-midterm-and-the-final-via-dropbox",
    "title": "2  Course Administration",
    "section": "2.3 Submitting homework, the midterm and the final via Dropbox",
    "text": "2.3 Submitting homework, the midterm and the final via Dropbox\nA homework will be due every week. You need to submit the homework and all other assignments via Dropbox. There is a little bit of setup involved but it is not very complicated.\n\n\nGo to Dropbox and sign up for a free account. This is a free account which gives you 2GB cloud disk space. It’s not immediately obvious from the Dropbox starting page how to sign up for the free account. On the left, below the two boxes you see a link that says get Dropbox Basic. Follow that link.\nDownload the Dropbox client on your computer and install it. This may take a couple minutes. You should now see a new Dropbox folder with a green marking on it in your folder structure. Usually under user but it depends on whether you are under windows, mac or linux.\n\n\nIf you are under Windows you may have to start the Dropbox client by\n\nhand each time you reboot the computer. You simply go to the Start menue button, start typing Dropbox in the search field and once the Dropbox link appears in the Start-Menue, right-click on it and click on Run as Administrator. This will start the client. You should see a small Dropbox symbol in your status line at the bottom that should say something like Dropbox Up to Date when you hover over it with the mouse pointer.\n\n\n\nAccept the share-a-folder invitation that I sent out via Dropbox. I will email this invitation after our first class session.\nYou will find a folder structure in this shared folder that should be self explanatory, i.e., a homework folder for homework, a midterm folder for the midterm, etc. All the homework script file with extensions .py are already inside of this folder.\nWhen you work on a homework, simply open Spyder first. Then, from within Spyder navigate to this shared folder and open the homework script file that you want to work on. For the first homework this would be the file: homework1.py. So open homework1.py from within Spyder and start editing it. Once you hit save the file will automatically be mirrored via Dropbox and I will see the updated homework1.py file on my computer.\nNo further action is required - the homework is already submitted.\nPS: Please do not change the names of the scriptfiles.\nA day or two later you will find a file called: homework1_graded.py with my comments and the point score for this assignment.",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Course Administration</span>"
    ]
  },
  {
    "objectID": "FirstSteps.html",
    "href": "FirstSteps.html",
    "title": "\n3  First Steps\n",
    "section": "",
    "text": "3.1 Simple Calculations\nAfter installation, open Spyder and try some of the following in the command line:\nOr try it in a script file, save it and run it.\nThen try the following mathematical operators.\nNote that the power function is not ^ but **. Also in Python we need to import the math-module in order to use certain math functions like sqrt() etc. When importing a module, we actually import a library of functions that all start with the module name. By typing import math at the beginning of your script you can then call all the functions of the math-module (or library) by typing math.functionName(). So if you want to take the square root of number 9, you would then simply call math.sqrt(9). You can also abbreviate the name of the module by typing import math as m in which case you can now take the square root with m.sqrt(9) as in the following script.\nIf you want to see a list of all the functions in the math module you can type: dir(math) or dir(m) and you will get a list of all methods/functions embedded in the module.",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>First Steps</span>"
    ]
  },
  {
    "objectID": "FirstSteps.html#simple-calculations",
    "href": "FirstSteps.html#simple-calculations",
    "title": "\n3  First Steps\n",
    "section": "",
    "text": "Python Code\nR Code\nJulia Code\n\n\n\n\nx = 2.5\ny = 3.0\nx + y\n\n5.5\n\n\n\n\n\nx = 2.5\ny = 3.0\nx + y\n\n[1] 5.5\n\n\n\n\nx = 2.5\ny = 3.0\nx + y\n\n\n\n\n\n\nPython Code\nR Code\nJulia Code\n\n\n\n\nprint(\"x= \", x)\nprint(\"y= \", y)\nprint(\"x + y = \", x + y)\n\nx=  2.5\ny=  3.0\nx + y =  5.5\n\n\n\n\n\nprint(paste(\"x= \", x))\nprint(paste(\"y= \", y))\nprint(paste(\"x + y = \", x + y))\n\n[1] \"x=  2.5\"\n[1] \"y=  3\"\n[1] \"x + y =  5.5\"\n\n\n\n\n#| results: hold\n\nprintln(\"x = $x\")\nprintln(\"y = $y\")\nprintln(\"x + y = $(x + y)\")\n\n\n\n\n\n\nOperation\nExpression\n\n\n\nSubtraction\nx - y\n\n\nDivision\nx / y\n\n\nMultiplication\nx * y\n\n\nPower\nx ** y\n\n\nSquare root\nm.sqrt(x)\n\n\nModulus\nx % y\n\n\nFloor division\nx // y\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nx = 7\ny = 2\n\nprint(\" --- OUTPUT: --- \")\n\n# addition\nprint(\"x + y = {}\".format(x + y))\n\n# subtraction\nprint(\"x - y = {}\".format(x - y))\n\n# multiplication\nprint(\"x * y = {}\".format(x * y))\n\n# division\nprint(\"x / y = {}\".format(x / y))\n\n# exponentiation\nprint(\"x ** y = {}\".format(x ** y))\n\n# square root\nimport math as m\nprint(\"m.sqrt(x) = {}\".format(m.sqrt(x)))\n\n# modulus\nprint(\"x % y = {}\".format(x % y))\n\n# floor division\nprint(\"x // y = {}\".format(x // y))\n\n --- OUTPUT: --- \nx + y = 9\nx - y = 5\nx * y = 14\nx / y = 3.5\nx ** y = 49\nm.sqrt(x) = 2.6457513110645907\nx % y = 1\nx // y = 3\n\n\n\n\n\n\nOperation\nExpression\n\n\n\nSubtraction\nx - y\n\n\nDivision\nx / y\n\n\nMultiplication\nx * y\n\n\nPower\nx ^ y\n\n\nSquare root\nsqrt(x)\n\n\nModulus\nx %% y\n\n\nFloor division\nx %//% y\n\n\n\n\nx = 7\ny = 2\n\n\nprint(paste(\"x + y = \", x + y))\nprint(paste(\"x * y = \", x * y))\nprint(paste(\"x / y = \", x / y))\nprint(paste(\"x^y = \", x ^ y))\nprint(paste(\"sqrt(x) = \", sqrt(x)))\nprint(paste(\"x%%y = \", x %% y))\nprint(paste(\"x%/%y = \", x %/% y))\n\n[1] \"x + y =  9\"\n[1] \"x * y =  14\"\n[1] \"x / y =  3.5\"\n[1] \"x^y =  49\"\n[1] \"sqrt(x) =  2.64575131106459\"\n[1] \"x%%y =  1\"\n[1] \"x%/%y =  3\"",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>First Steps</span>"
    ]
  },
  {
    "objectID": "FirstSteps.html#the-print-function",
    "href": "FirstSteps.html#the-print-function",
    "title": "\n3  First Steps\n",
    "section": "\n3.2 The Print Function",
    "text": "3.2 The Print Function\nIf you want to format your print output and combine text with numbers you need to use the .format method of the print function. You will learn more about objects and methods in a later chapter. Just hang in there fore now.\nIf you want to format the numbers (e.g., round etc.) that print will output you need to type the double brackets {} in your text string as a placeholder for where the number will be inserted.\n\n\nPython Code\nR Code\n\n\n\n\nimport math as m\nx = 2.455555\ny = 3.12344\n\nprint(\" --- OUTPUT: --- \")\n\n# Unformatted\nprint(\"x+y\", x+y)\n\n# Still unformatted but using the .format() method\nprint(\"Unformatted: x + y  = {}\".format(x+y))\n\n# Formatted, finally ...\nprint(\"Formatted: x + y  = {:5.2f}\".format(x+y))\n\n --- OUTPUT: --- \nx+y 5.578995\nUnformatted: x + y  = 5.578995\nFormatted: x + y  =  5.58\n\n\n\n\n\nx &lt;- 2.455555\ny &lt;- 3.12344\n\ncat(\" --- OUTPUT: --- \\n\")\n\n# Unformatted\ncat(\"x+y\", x+y, \"\\n\")\n\n# Still unformatted but using the sprintf() method\ncat(sprintf(\"Unformatted: x + y  = %f \\n\", x+y))\n\n# Formatted, finally ...\ncat(sprintf(\"Formatted: x + y  = %5.2f \\n\", x+y))\n\n --- OUTPUT: --- \nx+y 5.578995 \nUnformatted: x + y  = 5.578995 \nFormatted: x + y  =  5.58 \n\n\n\n\n\nThe format instruction :5.2f means that the output of the number is formatted as a five digit number with two fixed decimal places. If you want to see more details about how you can format numbered output have a look at this link: https://www.python-course.eu/python3_formatted_output.php\nHere are some more examples:\n\n\nPython Code\nR Code\n\n\n\n\nprint(\"x * y  = {:5.2f}\".format(x*y))\nprint(\"x / y  = {:5.2f}\".format(x/y))\nprint(\"x ** y = {:5.2f}\".format(x**y))\nprint(\"sqrt(x)= {:5.2f}\".format(m.sqrt(x)))\n\nx * y  =  7.67\nx / y  =  0.79\nx ** y = 16.54\nsqrt(x)=  1.57\n\n\n\n\n\ncat(paste0(\"x * y  = \", format(x*y, digits = 5, nsmall = 2), \"\\n\"))\ncat(paste0(\"x / y  = \", format(x/y, digits = 5, nsmall = 2), \"\\n\"))\ncat(paste0(\"x ** y = \", format(x^y, digits = 5, nsmall = 2), \"\\n\"))\ncat(paste0(\"sqrt(x)= \", format(sqrt(x), digits = 5, nsmall = 2), \"\\n\"))\n\nx * y  = 7.6698\nx / y  = 0.78617\nx ** y = 16.543\nsqrt(x)= 1.567\n\n\n\n\n\nYou can write more complex output with more than one number embedded in a line of text as follows:\n\n\nPython Code\nR Code\n\n\n\n\nprint(\" --- OUTPUT: --- \")\nprint(\"\"\"We want to use variable x = {0:4.2f} \\n and divide by\nvariable y = {1:4.2f},\\n so that we end up with expression\nx/y = {2:4.2f}\"\"\".format(x, y, x/y))\n\n --- OUTPUT: --- \nWe want to use variable x = 2.46 \n and divide by\nvariable y = 3.12,\n so that we end up with expression\nx/y = 0.79\n\n\n\n\n\ncat(\" --- OUTPUT: --- \\n\")\ncat(sprintf(\"We want to use variable x = %4.2f \\n and divide by\nvariable y = %4.2f,\\n so that we end up with expression\nx/y = %4.2f\", x, y, x/y))\n\n --- OUTPUT: --- \nWe want to use variable x = 2.46 \n and divide by\nvariable y = 3.12,\n so that we end up with expression\nx/y = 0.79\n\n\n\n\n\nThe symbol \\n that you see above is not printed but indicates a line break.",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>First Steps</span>"
    ]
  },
  {
    "objectID": "FirstSteps.html#script-files",
    "href": "FirstSteps.html#script-files",
    "title": "\n3  First Steps\n",
    "section": "\n3.3 Script Files",
    "text": "3.3 Script Files\nBefore we go on, let’s save all our commands in a so called Script file. These are basically text files that contain all commands in one big “laundry list” that we can then execute all at once. In order to open such a script file in Spyder simply click on File \\(\\rightarrow\\) New. Copy/paste the above commands into this script file and save it under a name of your choosing. Note that the file has the extension .py which indicates that it is a Python script file. You can then edit this file at will and add commands etc.\nIf you want to run or execute the script file simply click the Source button on top of your editor window. You can also execute the script file line by line. Simply mark the line, right click, and choose to execute selection or click on the Run icon on top of your editor window. This is the green button with the “running man symbol” on top of your editor window. If you’d like to execute just one line, mark the line and click on the “running man symbol” to the right of the first green button.\nFor the remainder of the class I highly recommend that you always use script files. This will help you to quickly run your code and evaluate your results.",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>First Steps</span>"
    ]
  },
  {
    "objectID": "FirstSteps.html#jupyter-notebook",
    "href": "FirstSteps.html#jupyter-notebook",
    "title": "\n3  First Steps\n",
    "section": "\n3.4 Jupyter Notebook",
    "text": "3.4 Jupyter Notebook\nA different way to write your codes is via the Jupyter Notebook, formerly known as the IPython Notebook. Read the instructions carefully, it should be pretty self explanatory. All you need to do is you open a terminal window.\n\n\nWindows: Go to the start button and type cmd in the search box. This will open a black terminal window.\nMac: Open a terminal by clicking on the terminal symbol in the dashboard at the bottom.\n\n\nIn this window, after the dollar prompt, you simply type jupyter notebook. This will start your browser and get you to the Jupyter-Notebook dashboard. You can start a new notebook from there and start typing code into the input boxes. You can immediately evaluate python code pressing: shift-enter. There are many tutorials about the Jupyter Notebook on the internet.\n\n\n\n\n\n\nKey Concepts and Summary\n\n\n\n\nThe print() function allows you to show output in the command line.\nThe .format() option allows you to format how numbers are printed.\nA script file is a text file with python commands.\n\n\n\n\n\n\n\n\n\nSelf-check questions\n\n\n\n\n\n\nGenerate a list with numbers from 1 to 10\nPrint the first 5 elements of this list\nReplace the last entry of the list with 100 and print the list again\nSort the list from largest to smallest element\nGo to www.learnpython.org",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>First Steps</span>"
    ]
  },
  {
    "objectID": "DataStructures.html",
    "href": "DataStructures.html",
    "title": "\n4  Data Structures\n",
    "section": "",
    "text": "4.1 Lists\nA list is a simple container object that can hold an arbitrary number of Python objects. A list can be a list of numbers, words, or a combination. Here is an example:\nAlternatively we could translate the list into a string and then print it. You can tag together strings with the plus sign, which combines a string \"The list is alist = \" together with another string str(alist). The Python function str() translates a number into a string, i.e., a word and then prints the combined \"word\".\nWe can access the elements of a list bit-by-bit using list indexation. Note that the first element in the list is at position 0.\nOr prettier\nIf you want to extract more than one element of a list you can use a slice operator. This basically involves the colon symbol : at the appropriate position. If you want to extract the first three elements you can simply index the list as alist[:3]. If you want to get everything from element 2 onwards you can alist[2:]\nIf you want to grab the last element of the list you can start indexing with negative numbers.\nYou can change elements of a list by reassigning them using their index. So if you want to replace the third element of the list with the word \"Mom\" you simply assign it as\nWhat about more complicated lists, where the elements inside the list are lists themselves. In this case we are dealing with nested lists. Here is an example:\nNow let's see what happens if we index this list. Try the following:\nThen try\nNow let's go one step deeper into the list:\nThis example shows how you can extract content from a list inside of a list by simply adding brackets with indexing positions to the list name. If you go outside the range of the inside list, the interpreter will throw an error:",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "DataStructures.html#lists",
    "href": "DataStructures.html#lists",
    "title": "\n4  Data Structures\n",
    "section": "",
    "text": "Python Code\nR Code\n\n\n\n\nalist = [1, \"me\", 3.456, \"you\", 50]\nprint(\"The list is alist = {}\".format(alist))\n\nThe list is alist = [1, 'me', 3.456, 'you', 50]\n\n\n\n\n\nalist &lt;- c(1, \"me\", 3.456, \"you\", 50)\ncat(\"The list is alist =\", alist)\n\nThe list is alist = 1 me 3.456 you 50\n\n\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nprint(\"The list is alist = \" + str(alist))\n\nThe list is alist = [1, 'me', 3.456, 'you', 50]\n\n\n\n\n\nprint(paste(\"The list is alist =\", alist))\n\n[1] \"The list is alist = 1\"     \"The list is alist = me\"   \n[3] \"The list is alist = 3.456\" \"The list is alist = you\"  \n[5] \"The list is alist = 50\"   \n\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nPython is zero-indexed. This means that the first element in a list (or other collection object such as tuple or array, more on these later) is at position “zero”.\nR, on the other hand, is one-indexed. This means that the first element in a list is at position “one”.\nMost general programming languages such as C, Java, Ruby, PHP, Python etc. are zero indexed, whereas most applied programming “languages” such as R, Matlab, Julia or Stata are one-indexed.\nThere is a philosophical debate about zero vs. one indexing going on, but the gist is that most computer scientists strongly prefer zero indexing whereas most math adjacent fields such as statistics and economics prefer one-based indexing as it seems more “natural.” See Wikipedia on Zero Based Indexing\n\n\n\n\nPython Code\nR Code\n\n\n\n\nprint(alist[0])\nprint(alist[1])\nprint(alist[2])\nprint(alist[3])\nprint(alist[4])\n\n1\nme\n3.456\nyou\n50\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nIn R indexing does not start with zero, but with one. So that the first element in the list has to be indexed as alist[1].\n\n\n\ncat(alist[1])\ncat(alist[2])\ncat(alist[3])\ncat(alist[4])\ncat(alist[5])\n\n1me3.456you50\n\n\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nprint(\"alist[0] = {}\".format(alist[0]))\nprint(\"alist[1] = {}\".format(alist[1]))\nprint(\"alist[2] = {}\".format(alist[2]))\nprint(\"alist[3] = {}\".format(alist[3]))\nprint(\"alist[4] = {}\".format(alist[4]))\n\nalist[0] = 1\nalist[1] = me\nalist[2] = 3.456\nalist[3] = you\nalist[4] = 50\n\n\n\n\n\nprint(paste(\"alist[1] =\", alist[1]))\nprint(paste(\"alist[2] =\", alist[2]))\nprint(paste(\"alist[3] =\", alist[3]))\nprint(paste(\"alist[4] =\", alist[4]))\nprint(paste(\"alist[5] =\", alist[5]))\n\n[1] \"alist[1] = 1\"\n[1] \"alist[2] = me\"\n[1] \"alist[3] = 3.456\"\n[1] \"alist[4] = you\"\n[1] \"alist[5] = 50\"\n\n\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nprint(alist)\nprint(\"alist[0:4] = {}\".format(alist[0:4]))\nprint(\"alist[:3] = {}\".format(alist[:3]))\nprint(\"alist[2:] = {}\".format(alist[2:]))\n\n[1, 'me', 3.456, 'you', 50]\nalist[0:4] = [1, 'me', 3.456, 'you']\nalist[:3] = [1, 'me', 3.456]\nalist[2:] = [3.456, 'you', 50]\n\n\n\n\nThis alist is already a vector, or atomic vector, and hence you can use cat() to print it to the screen.\n\nalist &lt;- c(1, 2, 3, 4, 5)\n\ncat(alist, \"\\n\")\ncat(\"alist[1:5] =\", alist[1:5], \"\\n\")\ncat(\"alist[1:3] =\", alist[1:3], \"\\n\")\ncat(\"alist[3:5] =\", alist[3:5], \"\\n\")\n\n1 2 3 4 5 \nalist[1:5] = 1 2 3 4 5 \nalist[1:3] = 1 2 3 \nalist[3:5] = 3 4 5 \n\n\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nalist = [1, \"me\", 3.456, \"you\", 50]\nprint(alist)\nprint(\"alist[-1] = {}\".format(alist[-1]))\nprint(\"alist[-2] = {}\".format(alist[-2]))\nprint(\"alist[-3] = {}\".format(alist[-3]))\n\n[1, 'me', 3.456, 'you', 50]\nalist[-1] = 50\nalist[-2] = you\nalist[-3] = 3.456\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nIn R you cannot use cat to print the elements of a list, you need to use either print() or str(). Alternatively, you can first unlist() the list object and then use cat() to “print” the resulting atomic vector.\n\n\n\nalist &lt;- list(1, \"me\", 3.456, \"you\", 50)\n\n\nprint(alist)\nstr(alist)\n\n# or unlist first\nmy_atomic_vec = unlist(alist)\ncat(my_atomic_vec)\n\nprint(paste(\"alist[length(alist)] =\", alist[length(alist)]))\ncat('\\n')\nprint(paste(\"alist[length(alist) - 1] =\", alist[length(alist) - 1]))\ncat('\\n')\nprint(paste(\"alist[length(alist) - 2] =\", alist[length(alist) - 2]))\ncat('\\n')\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"me\"\n\n[[3]]\n[1] 3.456\n\n[[4]]\n[1] \"you\"\n\n[[5]]\n[1] 50\n\nList of 5\n $ : num 1\n $ : chr \"me\"\n $ : num 3.46\n $ : chr \"you\"\n $ : num 50\n1 me 3.456 you 50[1] \"alist[length(alist)] = 50\"\n\n[1] \"alist[length(alist) - 1] = you\"\n\n[1] \"alist[length(alist) - 2] = 3.456\"\n\n\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nalist[2] = \"Mom\"\nprint(alist)\n\n[1, 'me', 'Mom', 'you', 50]\n\n\n\n\n\nalist[2] = \"Mom\"\n\n# Again: Don't use cat() here\nprint(alist)\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"Mom\"\n\n[[3]]\n[1] 3.456\n\n[[4]]\n[1] \"you\"\n\n[[5]]\n[1] 50\n\n\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nmyNestedList = [['Mom', 42], ['Dad', 41], ['Kids', 10, 12]]\nprint(myNestedList)\n\n[['Mom', 42], ['Dad', 41], ['Kids', 10, 12]]\n\n\n\n\n\nmyNestedList &lt;- list(\n  list(name = \"Mom\", age = 42),\n  list(name = \"Dad\", age = 41),\n  list(name = \"Kids\", ages = c(10, 12))\n)\n\nprint(myNestedList)\n\n[[1]]\n[[1]]$name\n[1] \"Mom\"\n\n[[1]]$age\n[1] 42\n\n\n[[2]]\n[[2]]$name\n[1] \"Dad\"\n\n[[2]]$age\n[1] 41\n\n\n[[3]]\n[[3]]$name\n[1] \"Kids\"\n\n[[3]]$ages\n[1] 10 12\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nA quick not on the R implementation: Nested lists are not directly supported in R as a built-in data structure. However, you can achieve a similar structure using lists and named lists in R.\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nprint(myNestedList[0])\nprint('---------------')\nprint(myNestedList[1])\nprint('---------------')\n\n['Mom', 42]\n---------------\n['Dad', 41]\n---------------\n\n\n\n\n\nprint(myNestedList[1])\nprint('---------------')\nprint(myNestedList[2])\nprint('---------------')\n\n[[1]]\n[[1]]$name\n[1] \"Mom\"\n\n[[1]]$age\n[1] 42\n\n\n[1] \"---------------\"\n[[1]]\n[[1]]$name\n[1] \"Dad\"\n\n[[1]]$age\n[1] 41\n\n\n[1] \"---------------\"\n\n\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nprint(myNestedList[0][0])\nprint('---------------')\nprint(myNestedList[1][0])\nprint('---------------')\nprint(myNestedList[1][1])\nprint('---------------')\n\nMom\n---------------\nDad\n---------------\n41\n---------------\n\n\n\n\n\nprint(myNestedList[1][1])\nprint('---------------')\nprint(myNestedList[2][1])\nprint('---------------')\nprint(myNestedList[2][2])\nprint('---------------')\n\n[[1]]\n[[1]]$name\n[1] \"Mom\"\n\n[[1]]$age\n[1] 42\n\n\n[1] \"---------------\"\n[[1]]\n[[1]]$name\n[1] \"Dad\"\n\n[[1]]$age\n[1] 41\n\n\n[1] \"---------------\"\n[[1]]\nNULL\n\n[1] \"---------------\"\n\n\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nprint(myNestedList[1][0][0])\nprint('---------------')\nprint(myNestedList[1][0][1])\nprint('---------------')\nprint(myNestedList[1][0][2])\nprint('---------------')\n\nD\n---------------\na\n---------------\nd\n---------------\n\n\n\n\n\nprint(myNestedList[2][1][1])\nprint('---------------')\nprint(myNestedList[2][1][2])\nprint('---------------')\nprint(myNestedList[2][1][3])\nprint('---------------')\n\n[[1]]\n[[1]]$name\n[1] \"Dad\"\n\n[[1]]$age\n[1] 41\n\n\n[1] \"---------------\"\n[[1]]\nNULL\n\n[1] \"---------------\"\n[[1]]\nNULL\n\n[1] \"---------------\"\n\n\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nprint(myNestedList[1][0][3])\n\nError: IndexError: string index out of range\n\n\n\n\n\nprint(myNestedList[2][1][4])\n\n[[1]]\nNULL",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "DataStructures.html#tuples",
    "href": "DataStructures.html#tuples",
    "title": "\n4  Data Structures\n",
    "section": "\n4.2 Tuples",
    "text": "4.2 Tuples\nAre immutable lists, that once defined, cannot be changed anymore. It is a read-only list.\n\n\nPython Code\nR Code\n\n\n\n\na_tuple = (1, \"me\", 3.456, \"you\", 50)\nprint(a_tuple)\n\n(1, 'me', 3.456, 'you', 50)\n\n\n\n\nIn order to use tuples in R you first need to install the library sets with install.packages(\"sets\"). Then you need to import the library using library(sets). Now you are ready to use tuples.\nAlso, in R you first have to “push” the elements of your tuple into a list and then assign the list as a tuple!\n\nlibrary(sets)\n\na_tuple = tuple((1, \"me\", 3.456, \"you\", 50))\nprint(a_tuple)\n\nError: &lt;text&gt;:3:19: unexpected ','\n2: \n3: a_tuple = tuple((1,\n                     ^\n\n\n\n\n\nNow try to change an element of the tuple and see what happens.\n\n\nPython Code\nR Code\n\n\n\n\na_tuple[2] = \"Mom\"\nprint(a_tuple)\n\nError: TypeError: 'tuple' object does not support item assignment\n\n\n(1, 'me', 3.456, 'you', 50)\n\n\n\n\n\na_tuple[3] = \"Mom\"\n\nError: object 'a_tuple' not found\n\nprint(a_tuple)\n\nError in eval(expr, envir, enclos): object 'a_tuple' not found\n\n\n\n\n\nSlice operators work exactly the same way as they work on lists.",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "DataStructures.html#dictionaries",
    "href": "DataStructures.html#dictionaries",
    "title": "\n4  Data Structures\n",
    "section": "\n4.3 Dictionaries",
    "text": "4.3 Dictionaries\nDictionaries or short \"dicts\" are more general mappings and word list associative arrays or so called hashes. They are basically key-value pairs where a key can be almost any Python type. So instead of indexing a list with indexes (which are numbers starting from 0, 1, etc.) the indices of a dictionary can be words or other data types.\nHere is a brief example where we use names of people as keys and store various information together with those keys. We can then retrieve the information of each person with the persons name.\n\n\nPython Code\nR Code\n\n\n\n\n# Defining a dictionary as adict = {'name': income}\nadict = {'James': 20000}\nadict['Jim'] = 50000\nadict['Tom'] = 80000\n\n\n\n\n# Defining a dictionary as adict = {'name': income}\nadict = {'James': 20000}\n\nWarning: NAs introduced by coercion\n\n\nError in \"James\":20000: NA/NaN argument\n\nadict['Jim'] = 50000\n\nError: object 'adict' not found\n\nadict['Tom'] = 80000\n\nError: object 'adict' not found\n\n\n\n\n\nWe can now retrive this info using the key.\n\n\nPython Code\nR Code\n\n\n\n\nprint(adict)\nprint(adict['James'])\nprint(adict['Jim'])\nprint(adict['Tom'])\n\n{'James': 20000, 'Jim': 50000, 'Tom': 80000}\n20000\n50000\n80000\n\n\n\n\n\nprint(adict)\n\nError in eval(expr, envir, enclos): object 'adict' not found\n\nprint(adict['James'])\n\nError in eval(expr, envir, enclos): object 'adict' not found\n\nprint(adict['Jim'])\n\nError in eval(expr, envir, enclos): object 'adict' not found\n\nprint(adict['Tom'])\n\nError in eval(expr, envir, enclos): object 'adict' not found\n\n\n\n\n\nYou can delete an element with\n\n\nPython Code\nR Code\n\n\n\n\ndel adict['James']\nprint(adict)\n\n{'Jim': 50000, 'Tom': 80000}\n\n\n\n\n\ndel adict['James']\nprint(adict)\n\nError: &lt;text&gt;:1:5: unexpected symbol\n1: del adict\n        ^",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "DataStructures.html#pitfalls",
    "href": "DataStructures.html#pitfalls",
    "title": "\n4  Data Structures\n",
    "section": "\n4.4 Pitfalls",
    "text": "4.4 Pitfalls\nWe next give a couple examples of potential pitfalls that can cause programming mistakes.\n\nBe careful how you copy a list:\n\n\n\nPython Code\nR Code\n\n\n\n\nlist1 = [ 1,2,3,4 ]\nlist2 = list1\nlist1.append(5)\nprint(list1)\nprint(list2)\n\n[1, 2, 3, 4, 5]\n[1, 2, 3, 4, 5]\n\n\n\n\n\nlist1 = [ 1,2,3,4 ]\nlist2 = list1\nlist1.append(5)\nprint(list1)\nprint(list2)\n\nError: &lt;text&gt;:1:9: unexpected '['\n1: list1 = [\n            ^\n\n\n\n\n\nWhat happens here is that the list [1,2,3,4] is assigned to two separate names list1 and list2. These two names now point to the same, identical list. As soon as you change the list using list1.append(5) this change will be reflected in both names of the list. If you really just want to copy the list and give that separate copy the name list2, do the following:\n\n\nPython Code\nR Code\n\n\n\n\nfrom copy import deepcopy\n\nlist1 = [ 1,2,3,4 ]\nlist2 = deepcopy(list1)\nlist1.append(5)\nprint(list1)\nprint(list2)\n\n[1, 2, 3, 4, 5]\n[1, 2, 3, 4]\n\n\n\n\n\n# In R, you can use 'list()' to create lists, and 'c()' to create vectors.\nlist1 &lt;- list(1, 2, 3, 4)\nlist2 &lt;- list1  # This makes a copy of the reference, similar to deepcopy in Python\nlist1 &lt;- c(list1, 5)  # Append 5 to the list1 vector\nprint(list1)\nprint(list2)\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3\n\n[[4]]\n[1] 4\n\n[[5]]\n[1] 5\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3\n\n[[4]]\n[1] 4\n\n\n\n\n\n\nThe list methods sort() and reverse() do not return a list object\n\n\n\nPython Code\nR Code\n\n\n\n\nlist1 = [4, 3, 2, 1]\nlist1.sort()\nprint(list1)  # You cannot do: print(list1.sort())\n\n[1, 2, 3, 4]\n\n\n\n\n\nlist1 &lt;- c(4, 3, 2, 1)\nlist1 &lt;- sort(list1)\nprint(list1)\n\n[1] 1 2 3 4\n\n\n\n\n\nBut if you now try:\n\n\nPython Code\nR Code\n\n\n\n\nlist1 = [4, 3, 2, 1]\nlist2 = [-1, 0] + list1.sort()\nprint(list2)\n\nError: TypeError: can only concatenate list (not \"NoneType\") to list\n\n\n[1, 2, 3, 4]\n\n\n\n\n\nlist1 &lt;- c(4, 3, 2, 1)\nlist1 &lt;- sort(list1)\nlist2 &lt;- c(-1, 0, list1)\n\nprint(list2)\n\n[1] -1  0  1  2  3  4\n\n\n\n\n\nyou get an error. So here the sort() method is not returning a list object. Since we then try to add a list [-1, 0] to something that is NOT a list, the interpreter throws an error. Here is one way to fix this, use the sorted command:\n\n\nPython Code\nR Code\n\n\n\n\nlist1 = [4, 3, 2, 1]\nlist2 = [-1, 0] + sorted(list1)\nprint(list1)\nprint(list2)\n\n[4, 3, 2, 1]\n[-1, 0, 1, 2, 3, 4]\n\n\n\n\n\nlist1 &lt;- c(4, 3, 2, 1)\nlist2 &lt;- c(-1, 0, sort(list1))\n\ncat(\"list1 =\", list1, \"\\n\")\ncat(\"list2 =\", list2, \"\\n\")\n\nlist1 = 4 3 2 1 \nlist2 = -1 0 1 2 3 4",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "DataStructures.html#json-data-format",
    "href": "DataStructures.html#json-data-format",
    "title": "\n4  Data Structures\n",
    "section": "\n4.5 JSON Data Format",
    "text": "4.5 JSON Data Format\nJSON (JavaScript Object Notation) is a lightweight data-interchange format. It is easy for humans to read and write and can be used to store and communicate information to other products.\nIt is based on key:value pairs. Many programming languages support the JSON data format. It is based on a subset of the JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999. JSON is a text format that is completely language independent but uses conventions that are familiar to programmers of the C-family of languages, including C, C++, C#, Java, JavaScript, Perl, Python, and many others. These properties make JSON an ideal data-interchange language.\nIn brief, JSON is a way by which we store and exchange data, which is accomplished through its syntax, and is used in many web applications. The nice thing about JSON is that it has a human readable format, and this may be one of the reasons for using it in data transmission, in addition to its effectiveness when working with APIs (Application Programming Interface).\nAn example of JSON-formatted data is as follows:\n{\"name\": \"Frank\", \"age\": 39, \"isEmployed\": true}\nPython has a built in JSON library called json that needs to be imported if you want to convert a JSON string into a Python value object like a dictionary or a list.\n\n\nPython Code\nR Code\n\n\n\n\nimport json\n\njsonData = '{\"name\": \"Frank\", \"age\": 39}'\njsonToPython = json.loads(jsonData)\nprint(jsonToPython)\n\n{'name': 'Frank', 'age': 39}\n\n\n\n\n\nlibrary(jsonlite)\n\njsonData &lt;- '{\"name\": \"Frank\", \"age\": 39}'\njsonToR &lt;- fromJSON(jsonData)\n\nprint(paste(jsonToR, \"\\n\"))\n\n[1] \"Frank \\n\" \"39 \\n\"   \n\n\n\n\n\nThe JSON string has been converted to a dictionary. You can now use it as such.\n\n\nPython Code\nR Code\n\n\n\n\nprint(jsonToPython['name'])\n\nFrank\n\n\n\n\n\nprint(jsonToR['name'])\n\n$name\n[1] \"Frank\"\n\n\n\n\n\nIf you want to convert a Python dictionary into a JSON string that can then be written to a file and read by other programs you can use the json.dumps() function.\n\n\nPython Code\nR Code\n\n\n\n\nimport json\n\npythonDictionary = {'name':'Bob', 'age':44, 'isEmployed':True}\ndictionaryToJson = json.dumps(pythonDictionary)\n\nprint(dictionaryToJson)\n\n{\"name\": \"Bob\", \"age\": 44, \"isEmployed\": true}\n\n\n\n\n\nlibrary(jsonlite)\n\npythonDictionary &lt;- list(name = \"Bob\", age = 44, isEmployed = TRUE)\ndictionaryToJson &lt;- toJSON(pythonDictionary)\n\nprint(past(dictionaryToJson, \"\\n\"))\n\nError in past(dictionaryToJson, \"\\n\"): could not find function \"past\"\n\n\n\n\n\n\n\n\n\n\n\nSelf-check questions\n\n\n\n\n\n\nGenerate a list with numbers from 1 to 10\nPrint the first 5 elements of this list\nReplace the last entry of the list with 100 and print the list again\nSort the list from largest to smallest element",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "Loop.html",
    "href": "Loop.html",
    "title": "\n5  Basic Programming Techniques\n",
    "section": "",
    "text": "5.1 Branching into Alternative Code Blocks",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Basic Programming Techniques</span>"
    ]
  },
  {
    "objectID": "Loop.html#branching-into-alternative-code-blocks",
    "href": "Loop.html#branching-into-alternative-code-blocks",
    "title": "\n5  Basic Programming Techniques\n",
    "section": "",
    "text": "5.1.1 The if statement\nThe if command can be used to check whether a certain condition is true. If it is true, then we can assign a certain chain of commands (i.e., a block of code) for this eventuality. If, on the other hand, the condition in the if statement is wrong, we can branch off our program into another direction and assign different commands (i.e., an alternative code block). This allows us to branch our program into two (or more) separate possible directions. The if construct is illustrated in Figure 5.1.\n\n\n\n\n\nFigure 5.1: If Branching Illustration\n\n\nIn Python it is very important to get the \"indentation\" right. So all the commands that we want to be executed after the if statement need to be \"indented\" by 4 spaces (just hit the tab-key on your keyboard once). Python does not use the curly brackets {} that R, Stata, Java, C or other programming languages use in their versions of the if-statements and for-loops.\nHere is a simple example of an if statement that is used to branch the code into two alternate routes depending on the value stored in variable x. You can read the if statement below as \"if the value of x is larger than one half, then do one thing. If it is not, then do the other thing.\"\n\n\nPython Code\nR Code\n\n\n\n\nx = 2\nif (x &gt; 0.5):\n    print(\"Number x= {} is greater than 0.5\".format(x))\nelse:\n    print(\"Number x= {} is smaller than or equal to 0.5\".format(x))\n\nNumber x= 2 is greater than 0.5\n\n\n\n\n\nx &lt;- 2\n\nif (x &gt; 0.5) {\n  cat(\"Number x =\", x, \"is greater than 0.5\\n\")\n} else {\n  cat(\"Number x =\", x, \"is smaller than or equal to 0.5\\n\")\n}\n\nNumber x = 2 is greater than 0.5\n\n\n\n\n\nThe operators that you can use in the if statements include the following:\n\n\nOperator\nDescription\nExample\n\n\n\n==\nEquals\nx == y\n\n\n!=\nNot equals\nx != y\n\n\n&gt;\nGreater than\nx &gt; y\n\n\n&gt;=\nGreater than or equal to\nx &gt;= y\n\n\n&lt;\nLess than\nx &lt; y\n\n\n&lt;=\nLess than or equal to\nx &lt;= y\n\n\n\nWe next branch the program into 3 separate directions depending on 3 mutually exclusive conditions.\n\n\nPython Code\nR Code\n\n\n\n\nx = 2\ny = 4\n\nif (x &gt; y):\n    print(\"X is greater than Y\")\nelif (x==y):\n    print(\"X is equal to Y\")\nelif (x &lt; y):\n    print(\"X is smaller than Y\")\n\nX is smaller than Y\n\n\n\n\n\nx &lt;- 2\ny &lt;- 4\n\nif (x &gt; y) {\n  cat(\"X is greater than Y\\n\")\n} else if (x == y) {\n  cat(\"X is equal to Y\\n\")\n} else if (x &lt; y) {\n  cat(\"X is smaller than Y\\n\")\n}\n\nX is smaller than Y\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nNote the double equal symbol ==. This is a logical operator or a Boolean operator such as EQUAL, AND, OR, and NOT. While the single equal symbol = is an assignment operator (i.e., x = 3 assigns the value 3 to variable with name x), the double equal symbol is a logical operator. You can find more information about Boolean operators here: Wiki-Boolean Operators\n\n\nThe expression x == 3 for instance asks whether the content of variable x equals the value of 3. If it does, the statement returns True and if it does not, the statement returns False. In the field of Logic the state of True is often coded with the value 1 and the state of False is coded as the value 0. When you used dummy variables in econometrics you basically used a Boolean variable. A dummy variable is simply an indicator variable taking the value 0 or 1 to indicate whether a certain observation belongs to a specific category.\nHere is an example to illustrate the difference between = and ==.\n\n\nPython Code\nR Code\n\n\n\n\n# Assign value 3 to variable with name x using singe equal symbol\nx = 3\nprint(x)\n\n3\n\n# Check whether the value of variable x is 3?\nprint(x == 3)\n\nTrue\n\n# Check whether the value of variable x is 4?\nprint(x == 4)\n\nFalse\n\n\n\n\n\n# Assign value 3 to variable with name x using single equal symbol\nx &lt;- 3\ncat(\"x =\", x, \"\\n\")\n\nx = 3 \n\n# Check whether the value of variable x is 3?\ncat(\"x == 3 =\", x == 3, \"\\n\")\n\nx == 3 = TRUE \n\n# Check whether the value of variable x is 4?\ncat(\"x == 4 =\", x == 4, \"\\n\")\n\nx == 4 = FALSE \n\n\n\n\n\nThe elif (x==y) statement above checks whether the value of variable x is equal to the value of variable y at that particular point in your code (i.e., at runtime). If this is the case, the elif function returns the value 1 (which means True) and then executes the associated code block.\nHere is another simple example using a branching if statement. We first draw some random number between 0 and 1 using the random() function. In order to use this function we first have to import the library in which this function is stored as it is not part of the core functions. We again use the import statement to import the random library. One of the functions in the random library is the function random() (yes it has the same name but there are other functions in the random library as well). In order to call the function random() we need to indicate the library name followed by a . (dot) and then the function name. So all in all this is: random.random() which will draw a random number between 0 and 1. We then check whether the number is smaller or larger than 0.5. For each eventuality we can then assign a string of commands to be executed.\n\n\nPython Code\nR Code\n\n\n\n\nimport random\n\nx = random.random()\nif (x &gt; 0.5):\n    print(\"Random Number x= {:5.2f} is greater than 0.5\".format(x))\nelse:\n    print(\"Random Number x= {:5.2f} is smaller than or equal to 0.5\".format(x))\n\nRandom Number x=  0.32 is smaller than or equal to 0.5\n\n\n\n\n\nx &lt;- runif(1)  # Generate a random number between 0 and 1\nif (x &gt; 0.5) {\n  cat(\"Random Number x =\", format(x, digits = 2), \"is greater than 0.5\\n\")\n} else {\n  cat(\"Random Number x =\", format(x, digits = 2), \"is smaller than or equal to 0.5\\n\")\n}\n\nRandom Number x = 0.033 is smaller than or equal to 0.5\n\n\n\n\n\nWe can also ask for more than one branching criteria again such as\n\n\nPython Code\nR Code\n\n\n\n\nimport random\n\nx = random.random()\nif (x &gt; 0.9):\n    print(\"Random Number x= {:5.2f} is greater than 0.9\".format(x))\nelif (x &gt; 0.8):\n    print(\"Random Number x= {:5.2f} is greater than 0.8\".format(x))\nelif (x &gt; 0.7):\n    print(\"Random Number x= {:5.2f} is greater than 0.7\".format(x))\nelse:\n    print(\"Random Number x= {:5.2f} is smaller than or equal to 0.7\".format(x))\n\nRandom Number x=  0.58 is smaller than or equal to 0.7\n\n\n\n\n\nx &lt;- runif(1)  # Generate a random number between 0 and 1\n\nif (x &gt; 0.9) {\n  cat(\"Random Number x =\", format(x, digits = 2), \"is greater than 0.9\\n\")\n} else if (x &gt; 0.8) {\n  cat(\"Random Number x =\", format(x, digits = 2), \"is greater than 0.8\\n\")\n} else if (x &gt; 0.7) {\n  cat(\"Random Number x =\", format(x, digits = 2), \"is greater than 0.7\\n\")\n} else {\n  cat(\"Random Number x =\", format(x, digits = 2), \"is smaller than or equal to 0.7\\n\")\n}\n\nRandom Number x = 0.2 is smaller than or equal to 0.7\n\n\n\n\n\nRunning the same script again, will result in a different random number being drawn, so that the result may differ of course.\n\n\nPython Code\nR Code\n\n\n\n\nimport random\n\nx = random.random()\nif (x &gt; 0.9):\n    print(\"Random Number x= {:5.2f} is greater than 0.9\".format(x))\nelif (x &gt; 0.8):\n    print(\"Random Number x= {:5.2f} is greater than 0.8\".format(x))\nelif (x &gt; 0.7):\n    print(\"Random Number x= {:5.2f} is greater than 0.7\".format(x))\nelse:\n    print(\"Random Number x= {:5.2f} is smaller than or equal to 0.7\".format(x))\n\nRandom Number x=  0.38 is smaller than or equal to 0.7\n\n\n\n\n\nx &lt;- runif(1)  # Generate a random number between 0 and 1\n\nif (x &gt; 0.9) {\n  cat(\"Random Number x =\", format(x, digits = 2), \"is greater than 0.9\\n\")\n} else if (x &gt; 0.8) {\n  cat(\"Random Number x =\", format(x, digits = 2), \"is greater than 0.8\\n\")\n} else if (x &gt; 0.7) {\n  cat(\"Random Number x =\", format(x, digits = 2), \"is greater than 0.7\\n\")\n} else {\n  cat(\"Random Number x =\", format(x, digits = 2), \"is smaller than or equal to 0.7\\n\")\n}\n\nRandom Number x = 0.77 is greater than 0.7\n\n\n\n\n\n\n\n5.1.2 Branching with Logical Operators\nFinally, we can use logical operators such as and as well as or to construct more sophisticated conditions for code branching. Assume, for instance, that you program a game that assigns a price of $1 if a random number is greater than 0.3 but less than 0.5. You could use the logical statement and to accomplish this as follows:\n\n\nPython Code\nR Code\n\n\n\n\nimport random\n\nx = random.random()\nprint(\"Random Number is x= {:5.2f}\".format(x))\n\nRandom Number is x=  0.32\n\nif (x &gt; 0.3 and x &lt; 0.5):\n    print(\"You win a price of $1, congratulations!\")\nelse:\n    print(\"Sorry, you win nothing!\")\n\nYou win a price of $1, congratulations!\n\n\n\n\n\nx &lt;- runif(1)  # Generate a random number between 0 and 1\n\ncat(\"Random Number is x =\", format(x, digits = 2), \"\\n\")\n\nRandom Number is x = 0.25 \n\nif (x &gt; 0.3 && x &lt; 0.5) {\n  cat(\"You win a prize of $1, congratulations!\\n\")\n} else {\n  cat(\"Sorry, you win nothing!\\n\")\n}\n\nSorry, you win nothing!\n\n\n\n\n\nA different game could assign a price of $1 to a player if a randomly drawn number is less than 0.3 or greater than 0.5. If you want to program this game, you would use the logical operator or as:\n\n\nPython Code\nR Code\n\n\n\n\nimport random\n\nx = random.random()\nprint(\"Random Number is x= {:5.2f}\".format(x))\n\nRandom Number is x=  0.94\n\nif (x &lt; 0.3 or x &gt; 0.5):\n    print(\"You win a price of $1, congratulations!\")\nelse:\n    print(\"Sorry, you win nothing!\")\n\nYou win a price of $1, congratulations!\n\n\n\n\n\nx &lt;- runif(1)  # Generate a random number between 0 and 1\n\ncat(\"Random Number is x =\", format(x, digits = 2), \"\\n\")\n\nRandom Number is x = 0.86 \n\nif (x &lt; 0.3 || x &gt; 0.5) {\n  cat(\"You win a prize of $1, congratulations!\\n\")\n} else {\n  cat(\"Sorry, you win nothing!\\n\")\n}\n\nYou win a prize of $1, congratulations!\n\n\n\n\n\nAnd you can of course combine these as well. A more complex game could pay the player $1 if the random number is at least 0.1 but less than two 0.2 or larger than 0.6. Notice that \"at least 0.1\" means that 0.1 is included in the condition so you need the &gt;= symbol as opposed the strictly greater &gt;. You could program this as:\n\n\nPython Code\nR Code\n\n\n\n\nimport random\n\nx = random.random()\nprint(\"Random Number is x= {:5.2f}\".format(x))\n\nRandom Number is x=  0.18\n\nif (x &gt;= 0.1 and x &lt; 0.2) or (x &gt; 0.6):\n    print(\"You win a price of $1, congratulations!\")\nelse:\n    print(\"Sorry, you win nothing!\")\n\nYou win a price of $1, congratulations!\n\n\n\n\n\nx &lt;- runif(1)  # Generate a random number between 0 and 1\n\ncat(\"Random Number is x =\", format(x, digits = 2), \"\\n\")\n\nRandom Number is x = 0.074 \n\nif ((x &gt;= 0.1 && x &lt; 0.2) || (x &gt; 0.6)) {\n  cat(\"You win a prize of $1, congratulations!\\n\")\n} else {\n  cat(\"Sorry, you win nothing!\\n\")\n}\n\nSorry, you win nothing!",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Basic Programming Techniques</span>"
    ]
  },
  {
    "objectID": "Loop.html#for-loops",
    "href": "Loop.html#for-loops",
    "title": "\n5  Basic Programming Techniques\n",
    "section": "\n5.2 For-Loops",
    "text": "5.2 For-Loops\n\n5.2.1 Loop to Repeat a Simple Print Function\nAssume you have the following assignment. Please print the following on a screen:\ni = 0\ni = 1\ni = 2\ni = 3\n\netc.\n\ni = 9\nWe could first of course just write simple print statements as follows:\n\n\nPython Code\nR Code\n\n\n\n\nprint('i = {}'.format(0))\nprint('i = {}'.format(1))\nprint('i = {}'.format(2))\nprint('i = {}'.format(3))\nprint('i = {}'.format(4))\nprint('i = {}'.format(5))\nprint('i = {}'.format(6))\nprint('i = {}'.format(7))\nprint('i = {}'.format(8))\nprint('i = {}'.format(9))\n\ni = 0\ni = 1\ni = 2\ni = 3\ni = 4\ni = 5\ni = 6\ni = 7\ni = 8\ni = 9\n\n\n\n\n\ncat(\"i =\", 0, \"\\n\")\ncat(\"i =\", 1, \"\\n\")\ncat(\"i =\", 2, \"\\n\")\ncat(\"i =\", 3, \"\\n\")\ncat(\"i =\", 4, \"\\n\")\ncat(\"i =\", 5, \"\\n\")\ncat(\"i =\", 6, \"\\n\")\ncat(\"i =\", 7, \"\\n\")\ncat(\"i =\", 8, \"\\n\")\ncat(\"i =\", 9, \"\\n\")\n\ni = 0 \ni = 1 \ni = 2 \ni = 3 \ni = 4 \ni = 5 \ni = 6 \ni = 7 \ni = 8 \ni = 9 \n\n\n\n\n\nNot wrong, but pretty slow to produce and boring. Whenever a task is repetitive and boring there is probably a quicker and more exciting way of accomplishing it.\nLet's think about a loop implementation. When you construct a loop, you essentially define a code block that gets repeated a number of times. Figure 5.2 illustrates the loop concept. An iterator variable var is generated and is assigned a “value” out of a collection of values such as a list or tuple. The latter is referred to as the iterable.\n\n\n\n\n\nFigure 5.2: Loop Structure Illustration\n\n\nNow try this in a code example that implements the exercise above again:\n\n\nPython Code\nR Code\n\n\n\n\nfor i in range(10):\n    print('i = {}'.format(i))\n\ni = 0\ni = 1\ni = 2\ni = 3\ni = 4\ni = 5\ni = 6\ni = 7\ni = 8\ni = 9\n\n\n\n\n\nfor (i in 0:9) {\n  cat(\"i =\", i, \"\\n\")\n}\n\ni = 0 \ni = 1 \ni = 2 \ni = 3 \ni = 4 \ni = 5 \ni = 6 \ni = 7 \ni = 8 \ni = 9 \n\n\n\n\n\nNote that we again need to increment the print statement inside of the loop with 4! white-spaces. The range() command will generate a list with 10 objects in it. The objects are the numbers from [0,1,...9]. It will then instruct the computer to assign the list elements to variable i in each round.\nYou can then decide what to do with the specific value of variable i in each round. Variable i is called the iterator or counter as it changes its value in every iteration of the loop and in a way counts in which round you currently are. Here's a more elaborate example.\n\n\nPython Code\nR Code\n\n\n\n\nfor i in range(10):\n    x = i/2\n    print('Round: {}'.format(i))\n    print('------------------------')\n    print('i = {}'.format(i))\n    print('x = i/2 = {}/2 = {}'.format(i, x))\n    print('------------------------')\n\nRound: 0\n------------------------\ni = 0\nx = i/2 = 0/2 = 0.0\n------------------------\nRound: 1\n------------------------\ni = 1\nx = i/2 = 1/2 = 0.5\n------------------------\nRound: 2\n------------------------\ni = 2\nx = i/2 = 2/2 = 1.0\n------------------------\nRound: 3\n------------------------\ni = 3\nx = i/2 = 3/2 = 1.5\n------------------------\nRound: 4\n------------------------\ni = 4\nx = i/2 = 4/2 = 2.0\n------------------------\nRound: 5\n------------------------\ni = 5\nx = i/2 = 5/2 = 2.5\n------------------------\nRound: 6\n------------------------\ni = 6\nx = i/2 = 6/2 = 3.0\n------------------------\nRound: 7\n------------------------\ni = 7\nx = i/2 = 7/2 = 3.5\n------------------------\nRound: 8\n------------------------\ni = 8\nx = i/2 = 8/2 = 4.0\n------------------------\nRound: 9\n------------------------\ni = 9\nx = i/2 = 9/2 = 4.5\n------------------------\n\n\n\n\n\nfor (i in 0:9) {\n  x &lt;- i/2\n  cat(\"Round:\", i, \"\\n\")\n  cat(\"------------------------\\n\")\n  cat(\"i =\", i, \"\\n\")\n  cat(\"x = i/2 =\", i, \"/2 =\", x, \"\\n\")\n  cat(\"------------------------\\n\\n\")\n}\n\nRound: 0 \n------------------------\ni = 0 \nx = i/2 = 0 /2 = 0 \n------------------------\n\nRound: 1 \n------------------------\ni = 1 \nx = i/2 = 1 /2 = 0.5 \n------------------------\n\nRound: 2 \n------------------------\ni = 2 \nx = i/2 = 2 /2 = 1 \n------------------------\n\nRound: 3 \n------------------------\ni = 3 \nx = i/2 = 3 /2 = 1.5 \n------------------------\n\nRound: 4 \n------------------------\ni = 4 \nx = i/2 = 4 /2 = 2 \n------------------------\n\nRound: 5 \n------------------------\ni = 5 \nx = i/2 = 5 /2 = 2.5 \n------------------------\n\nRound: 6 \n------------------------\ni = 6 \nx = i/2 = 6 /2 = 3 \n------------------------\n\nRound: 7 \n------------------------\ni = 7 \nx = i/2 = 7 /2 = 3.5 \n------------------------\n\nRound: 8 \n------------------------\ni = 8 \nx = i/2 = 8 /2 = 4 \n------------------------\n\nRound: 9 \n------------------------\ni = 9 \nx = i/2 = 9 /2 = 4.5 \n------------------------\n\n\n\n\n\n\n5.2.2 Loop to Calculate the Sum of Numbers\nHere is another simple example. We first assign a list with values 0,1,2,3,4,5. We then \"loop\" through all the values of this list and print them one by one. In addition, we add up all the values of this list. The command for x in range(6) assigns x equal to each value of 0,1, ...,5 one by one and we can then use x itself in each iteration.\nNote that if you want a list from 0,1,...,5 you need to define the range command with range(6). Using this loop we can step through all the values of our list and assign certain operations to each value.\n\n\nPython Code\nR Code\n\n\n\n\n# Summation variable starting with zero value\nsumx = 0\n\n# Start loop\nfor x in range(6):\n    sumx = sumx + x  # adds up the elements from 0 to 5\n    print(\"x = {}\".format(x))\n    print(\"sum(x) = {}\".format(sumx))\n\nx = 0\nsum(x) = 0\nx = 1\nsum(x) = 1\nx = 2\nsum(x) = 3\nx = 3\nsum(x) = 6\nx = 4\nsum(x) = 10\nx = 5\nsum(x) = 15\n\n\n\n\n\n# Summation variable starting with zero value\nsumx &lt;- 0\n\n# Start loop\nfor (x in 0:5) {\n  sumx &lt;- sumx + x  # adds up the elements from 0 to 5\n  cat(\"x =\", x, \"\\n\")\n  cat(\"sum(x) =\", sumx, \"\\n\")\n}\n\nx = 0 \nsum(x) = 0 \nx = 1 \nsum(x) = 1 \nx = 2 \nsum(x) = 3 \nx = 3 \nsum(x) = 6 \nx = 4 \nsum(x) = 10 \nx = 5 \nsum(x) = 15 \n\n\n\n\n\nIn the above code snipped the x variable is the counter and the sumx variable is the accumulator. The accumulator sums up the iterator in each round and adds it to the already accumulated sum of previous iterations.\n\n\n\n\n\n\nNote\n\n\n\nAn alternative, shorter, notation that is often used for accumulator type variables is sumx += x which is short for sumx = sumx + x\n\n\n\n\nPython Code\nR Code\n\n\n\n\n# Summation variable starting with zero value\nsumx = 0\n\n# Start loop\nfor x in range(6):\n    sumx += x  # adds up the elements from 0 to 5\n    print(\"x = {}\".format(x))\n    print(\"sum(x) = {}\".format(sumx))\n\nx = 0\nsum(x) = 0\nx = 1\nsum(x) = 1\nx = 2\nsum(x) = 3\nx = 3\nsum(x) = 6\nx = 4\nsum(x) = 10\nx = 5\nsum(x) = 15\n\n\n\n\nThis style is not available in R.\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nIt is bad programming style if you re-assign the iterator variable x within the code block that gets repeated and you should avoid it. Some programming languages will not even allow you to assign a value to an iterator within a loop statement.\n\n\n\n5.2.3 Loop to Calculate the Product of Numbers\nHere is another example. We write a loop that calculates the factorial of a number: \\(3!\\). Remember that \\(3! = 1 * 2 * 3\\). In order to make this happen we write a loop that sets \\(i = 1, 2,\\) and 3 and multiplies it with the product of the previous round. The variable n_fac stores the product from each round.\n\n\nPython Code\nR Code\n\n\n\n\nn = 6\nn_fac = 1\n\nfor i in range(n):\n    print(\"i = \", i)\n    n_fac = n_fac * (i+1)\n\nprint(\"The factorial of {} is: {}\".format(n, n_fac))\n\ni =  0\ni =  1\ni =  2\ni =  3\ni =  4\ni =  5\nThe factorial of 6 is: 720\n\n\n\n\n\nn &lt;- 6\nn_fac &lt;- 1\n\nfor (i in 0:(n-1)) {\n  cat(\"i =\", i, \"\\n\")\n  n_fac &lt;- n_fac * (i+1)\n}\n\ncat(\"The factorial of\", n, \"is:\", n_fac, \"\\n\")\n\ni = 0 \ni = 1 \ni = 2 \ni = 3 \ni = 4 \ni = 5 \nThe factorial of 6 is: 720 \n\n\n\n\n\nUsing a different method we can also calculate the factorial as: Here the accumulator variable n_fac is not accumulating a sum of numbers but a product.\n\n\nPython Code\nR Code\n\n\n\n\nimport math as m\nprint(\"The factorial of 6 is {}\".format(m.factorial(6)))\n\nThe factorial of 6 is 720\n\n\n\n\n\nlibrary(gmp)\n\nError in library(gmp): there is no package called 'gmp'\n\ncat(\"The factorial of 6 is\", factorial(6), \"\\n\")\n\nThe factorial of 6 is 720 \n\n\n\n\n\n\n5.2.4 Loop with Iterator Values Not Starting at Zero\nIf you use the range(5) command in the previous example, Python will generate an internal list with the values [0,1,2,3,4] and then let the loop run through the values of this list so that the iterator variable will start with value 0, then increment to value 1 in the second round, then increment to 3 in the third round and so on.\nIf you want the iterator variable of the loop to take on certain values and not start from 0 you can specify the range command slightly differently and give it a new starting value such as range(3, 6) would generate an internal list of [3,4,5] and then let the iterator variable run through that list in each round of the loop.\n\n\n\n\n\n\nNote\n\n\n\nPython uses half open intervals in its internal list generation processes. This means that the interval you hand into the range command in mathematical notation is \\[[3,6)\\]. This means it’s closed at the bottom and open on top. Closed at the bottom means that the number 3 is included in the interval and open on top means that the number 6 is excluded from the interval.\n\n\nHere is an example of a loop where the iterator variable does not start with value zero.\n\n\nPython Code\nR Code\n\n\n\n\nfor i in range(3,6):\n    print('i = {}'.format(i))\n\ni = 3\ni = 4\ni = 5\n\n\n\n\n\nfor (i in 3:5) {\n  cat(\"i =\", i, \"\\n\")\n}\n\ni = 3 \ni = 4 \ni = 5 \n\n\n\n\n\n\n5.2.5 Nested Loops\nIn this section you will see an example of a loop inside a loop, or a nested loop.\n\n\nPython Code\nR Code\n\n\n\n\nfor i in range(3,6):\n    print('Inside first loop but outside second loop i = {}'.format(i))\n\n    for j in range(100, 105):\n        print('Inside second loop: i = {} and j = {}'.format(i,j))\n\nInside first loop but outside second loop i = 3\nInside second loop: i = 3 and j = 100\nInside second loop: i = 3 and j = 101\nInside second loop: i = 3 and j = 102\nInside second loop: i = 3 and j = 103\nInside second loop: i = 3 and j = 104\nInside first loop but outside second loop i = 4\nInside second loop: i = 4 and j = 100\nInside second loop: i = 4 and j = 101\nInside second loop: i = 4 and j = 102\nInside second loop: i = 4 and j = 103\nInside second loop: i = 4 and j = 104\nInside first loop but outside second loop i = 5\nInside second loop: i = 5 and j = 100\nInside second loop: i = 5 and j = 101\nInside second loop: i = 5 and j = 102\nInside second loop: i = 5 and j = 103\nInside second loop: i = 5 and j = 104\n\n\n\n\n\nfor (i in 3:5) {\n  cat(\"Inside first loop but outside second loop i =\", i, \"\\n\")\n\n  for (j in 100:104) {\n    cat(\"Inside second loop: i =\", i, \"and j =\", j, \"\\n\")\n  }\n}\n\nInside first loop but outside second loop i = 3 \nInside second loop: i = 3 and j = 100 \nInside second loop: i = 3 and j = 101 \nInside second loop: i = 3 and j = 102 \nInside second loop: i = 3 and j = 103 \nInside second loop: i = 3 and j = 104 \nInside first loop but outside second loop i = 4 \nInside second loop: i = 4 and j = 100 \nInside second loop: i = 4 and j = 101 \nInside second loop: i = 4 and j = 102 \nInside second loop: i = 4 and j = 103 \nInside second loop: i = 4 and j = 104 \nInside first loop but outside second loop i = 5 \nInside second loop: i = 5 and j = 100 \nInside second loop: i = 5 and j = 101 \nInside second loop: i = 5 and j = 102 \nInside second loop: i = 5 and j = 103 \nInside second loop: i = 5 and j = 104 \n\n\n\n\n\nAs you can see the first loop gets executed and the iterator variable i takes on value 3. Then the code jumps to the \"inside\" loop and executes the repetitions for iterator variable j.\n\n5.2.6 Looping through the Content of a List using Indexing\nFinally, here is an example where we loop through the values of a list again. In each round we \"grab\" a number from the list and print it.\nLet's first define a list with some numbers in it.\n\n\nPython Code\nR Code\n\n\n\n\nxv = list(range(5))\nprint(\"xv= {}\".format(xv))\n\nxv= [0, 1, 2, 3, 4]\n\n\n\n\n\nxv &lt;- 0:4\ncat(\"xv =\", xv, \"\\n\")\n\nxv = 0 1 2 3 4 \n\n\n\n\n\nWe now start the loop and pick each value of this list one-by-one. The command length tells us how many arguments are in the list xv and then lets the loop run from 1 to the total number of arguments in xv. Note also the difference in the two print commands, where the second one results in formatted output.\n\n\nPython Code\nR Code\n\n\n\n\nxv = list(range(6))\nfor i in range(len(xv)):\n    print(\"i= {}\".format(i))\n    print(\"xv[i]= {:4.2f}\".format(xv[i]))\n\ni= 0\nxv[i]= 0.00\ni= 1\nxv[i]= 1.00\ni= 2\nxv[i]= 2.00\ni= 3\nxv[i]= 3.00\ni= 4\nxv[i]= 4.00\ni= 5\nxv[i]= 5.00\n\n\n\n\n\nxv &lt;- 0:5\nfor (i in 1:length(xv)) {\n  cat(\"i =\", i - 1, \"\\n\")\n  cat(\"xv[i] =\", format(xv[i], digits = 2), \"\\n\")\n}\n\ni = 0 \nxv[i] = 0 \ni = 1 \nxv[i] = 1 \ni = 2 \nxv[i] = 2 \ni = 3 \nxv[i] = 3 \ni = 4 \nxv[i] = 4 \ni = 5 \nxv[i] = 5 \n\n\n\n\n\n\n5.2.7 Looping through the Content of a List without Indexing\nIf you already have a list predefined and you want to loop through the content of that list you can use a for loop in a more direct way without explicitly indexing the list elements inside of brackets [].\n\n\nPython Code\nR Code\n\n\n\n\n# Define the list\nmyList = ['jim', 'james', 23, 12, 'car', 'bike']\n\nfor x in myList:\n    print('indexing variable x is: ', x)\n\nindexing variable x is:  jim\nindexing variable x is:  james\nindexing variable x is:  23\nindexing variable x is:  12\nindexing variable x is:  car\nindexing variable x is:  bike\n\n\n\n\n\nmyList &lt;- c('jim', 'james', 23, 12, 'car', 'bike')\n\nfor (x in myList) {\n  cat(\"indexing variable x is:\", x, \"\\n\")\n}\n\nindexing variable x is: jim \nindexing variable x is: james \nindexing variable x is: 23 \nindexing variable x is: 12 \nindexing variable x is: car \nindexing variable x is: bike \n\n\n\n\n\nIf you need to keep track of the position of the various items in the list you can use the enumerate command which internally generates a \"zipped list\" that pairs up each element in the list with its index inside of the list. Here is an example using the previous list:\n\n\nPython Code\nR Code\n\n\n\n\n# Define the list\nmyList = ['jim', 'james', 23, 12, 'car', 'bike']\n\nfor i, x in enumerate(myList):\n    print('variable i is: {} and x is: {}'.format(i, x))\n\nvariable i is: 0 and x is: jim\nvariable i is: 1 and x is: james\nvariable i is: 2 and x is: 23\nvariable i is: 3 and x is: 12\nvariable i is: 4 and x is: car\nvariable i is: 5 and x is: bike\n\n\n\n\n\nmyList &lt;- c('jim', 'james', 23, 12, 'car', 'bike')\n\nfor (i in 1:length(myList)) {\n  x &lt;- myList[i]\n  cat(\"variable i is:\", i - 1, \"and x is:\", x, \"\\n\")\n}\n\nvariable i is: 0 and x is: jim \nvariable i is: 1 and x is: james \nvariable i is: 2 and x is: 23 \nvariable i is: 3 and x is: 12 \nvariable i is: 4 and x is: car \nvariable i is: 5 and x is: bike \n\n\n\n\n\n\n5.2.8 Combining Lists and Looping Through Them\nIf you have two or more lists that you want to loop through simultaneously pulling the first elements from both lists (in tandem), followed by the second elements from both lists, etc. you can use the zip command. The zip function \"glues\" or \"zips\" the lists together and then allows you to run (or loop) through them in this pairwise fashion. The next example illustrates this.\n\n\nPython Code\nR Code\n\n\n\n\n# Define the list of spouses\nmyMaleList = ['jim', 'james', 'jack', 'john', 'jason']\nmyFemaleList = ['emma', 'clara', 'susan', 'jill', 'lisa']\n\nfor husband, wife in zip(myMaleList, myFemaleList):\n    print('The hubby is: {} and the wife is {}'.format(husband, wife))\n\nThe hubby is: jim and the wife is emma\nThe hubby is: james and the wife is clara\nThe hubby is: jack and the wife is susan\nThe hubby is: john and the wife is jill\nThe hubby is: jason and the wife is lisa\n\n\n\n\n\nmyMaleList &lt;- c('jim', 'james', 'jack', 'john', 'jason')\nmyFemaleList &lt;- c('emma', 'clara', 'susan', 'jill', 'lisa')\n\nfor (i in 1:length(myMaleList)) {\n  husband &lt;- myMaleList[i]\n  wife &lt;- myFemaleList[i]\n  cat(\"The hubby is:\", husband, \"and the wife is\", wife, \"\\n\")\n}\n\nThe hubby is: jim and the wife is emma \nThe hubby is: james and the wife is clara \nThe hubby is: jack and the wife is susan \nThe hubby is: john and the wife is jill \nThe hubby is: jason and the wife is lisa \n\n\n\n\n\nIf you want to combine this with the index of the names inside the lists you can use enumerate again. Be careful in how you use the parenthesis around the variables husband and wife in the for loop construct.\n\n\nPython Code\nR Code\n\n\n\n\n# Define the list of spouses\nmyMaleList = ['jim', 'james', 'jack', 'john', 'jason']\nmyFemaleList = ['emma', 'clara', 'susan', 'jill', 'lisa']\n\nfor i, (husband, wife) in enumerate(zip(myMaleList, myFemaleList)):\n    print(\"\"\"At index: {} the hubby is: {}\n    and the wife is {}\"\"\".format(i, husband, wife))\n\nAt index: 0 the hubby is: jim\n    and the wife is emma\nAt index: 1 the hubby is: james\n    and the wife is clara\nAt index: 2 the hubby is: jack\n    and the wife is susan\nAt index: 3 the hubby is: john\n    and the wife is jill\nAt index: 4 the hubby is: jason\n    and the wife is lisa\n\n\n\n\n\nmyMaleList &lt;- c('jim', 'james', 'jack', 'john', 'jason')\nmyFemaleList &lt;- c('emma', 'clara', 'susan', 'jill', 'lisa')\n\nfor (i in 1:length(myMaleList)) {\n  husband &lt;- myMaleList[i]\n  wife &lt;- myFemaleList[i]\n  cat(\"At index:\", i - 1, \"the hubby is:\", husband, \"\\n\")\n  cat(\"and the wife is\", wife, \"\\n\\n\")\n}\n\nAt index: 0 the hubby is: jim \nand the wife is emma \n\nAt index: 1 the hubby is: james \nand the wife is clara \n\nAt index: 2 the hubby is: jack \nand the wife is susan \n\nAt index: 3 the hubby is: john \nand the wife is jill \n\nAt index: 4 the hubby is: jason \nand the wife is lisa",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Basic Programming Techniques</span>"
    ]
  },
  {
    "objectID": "Loop.html#while-loop",
    "href": "Loop.html#while-loop",
    "title": "\n5  Basic Programming Techniques\n",
    "section": "\n5.3 While Loop",
    "text": "5.3 While Loop\nThe while loop runs and keeps repeating to do something until a certain stopping condition is met.\n\n5.3.1 While Loop 1\nIn the first example we let the iterations run as long as the value of variable x is smaller than 10. In every iteration we increase x by one unit, so that in effect the loop gets repeated 9 times.\nIn a while loop the iterator variable is not automatically incremented as in the for loop, where we explicitly state the starting and stopping values for the iterator variable. We therefore have to make sure that we increment the iterator/counter variable x within the repeatable codeblock using x = x +1 or shorter and more efficiently x += 1.\n\n\nPython Code\nR Code\n\n\n\n\nx = 0\ny = 0\nwhile (x &lt; 10):\n    y = y + x\n    print(\"X= {} and Y= {}\".format(x, y))\n    x += 1  # i.e., x = x + 1\n\nX= 0 and Y= 0\nX= 1 and Y= 1\nX= 2 and Y= 3\nX= 3 and Y= 6\nX= 4 and Y= 10\nX= 5 and Y= 15\nX= 6 and Y= 21\nX= 7 and Y= 28\nX= 8 and Y= 36\nX= 9 and Y= 45\n\n\n\n\n\nx &lt;- 0\ny &lt;- 0\n\nwhile (x &lt; 10) {\n  y &lt;- y + x\n  cat(\"X =\", x, \"and Y =\", y, \"\\n\")\n  x &lt;- x + 1\n}\n\nX = 0 and Y = 0 \nX = 1 and Y = 1 \nX = 2 and Y = 3 \nX = 3 and Y = 6 \nX = 4 and Y = 10 \nX = 5 and Y = 15 \nX = 6 and Y = 21 \nX = 7 and Y = 28 \nX = 8 and Y = 36 \nX = 9 and Y = 45 \n\n\n\n\n\nThe accumulator variable y calculates the cumulative sum of all numbers from 1 to 9, so that \\(y = 0+1+2+...+9\\). If you forget the statement that increments the counter at the end of the repeatable code block within the loop, then the loop will run infinitely long and you have to break the code with pressing ctrl + c which will stop the execution of the Python script.\n\n5.3.2 While Loop 2\nIn this last example we calculate how long it takes to repay a loan. The longer you wait to repay the loan, the more interest is accumulated and added to the outstanding debt. The key formula in this example is:\n\\[\\text{debt}_\\text{tomorrow} = \\text{debt}_\\text{today} \\times (1 + \\text{interest rate}) -\n\\text{payments}_\\text{today}\\]\n\n\nPython Code\nR Code\n\n\n\n\nr = 0.11  # Annual interest rate\n# Time between repayments in years (i.e., monthly repayments)\nperiod = 1.0/12.0\ndebt_initial = 1000.0  # Initial debt\npayments = 12.0  # Amount repaid each period\n\nmytime = 0\ndebt = debt_initial\nwhile (debt &gt; 0):\n    mytime = mytime + period\n    debt = debt*(1. + r*period) - payments\n\nprint(\"Loan will be repaid in: {} years.\".format(mytime))\n\nLoan will be repaid in: 13.250000000000025 years.\n\n\n\n\n\nr &lt;- 0.11  # Annual interest rate\nperiod &lt;- 1.0/12.0\ndebt_initial &lt;- 1000.0\npayments &lt;- 12.0\n\nmytime &lt;- 0\ndebt &lt;- debt_initial\n\nwhile (debt &gt; 0) {\n  mytime &lt;- mytime + period\n  debt &lt;- debt * (1 + r * period) - payments\n}\n\ncat(\"Loan will be repaid in:\", mytime, \"years.\\n\")\n\nLoan will be repaid in: 13.25 years.",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Basic Programming Techniques</span>"
    ]
  },
  {
    "objectID": "Loop.html#combining-branching-statements-and-loops",
    "href": "Loop.html#combining-branching-statements-and-loops",
    "title": "\n5  Basic Programming Techniques\n",
    "section": "\n5.4 Combining Branching Statements and Loops",
    "text": "5.4 Combining Branching Statements and Loops\nWe can of course combine everything we have learned so far. Let's assume you have the following programming task. You have to generate a list with numbers from 1 to 20. You then have to collect all numbers from 1 to 10 in a blue bin and add them up. All numbers from 11 to 20 are to be added up in the bin. How would you do that?\nYou use a loop that runs through all the numbers of a list and combine it with a branching statement that checks whether a number is smaller than 11. If YES (i.e., numbers are smaller 11) execute one block of code where the numbers are collected in a blue bin and if NO (i.e., numbers are greater 10) then put those numbers into the red bin.\nHere is the example code that would accomplish this.\n\n\nPython Code\nR Code\n\n\n\n\nblueBin = 0\nredBin = 0\n\nfor i in range(1,21):\n    if i &lt;= 10:\n        print('Number i = {:2d} will be put in BLUE bin'.format(i))\n        blueBin = blueBin + i\n    else:\n        print('Number i = {:2d} will be put in RED bin'.format(i))\n        redBin = redBin + i\nprint(' ')\nprint('------------------------------------------- ')\nprint('The sum of numbers in BLUE bin is {}'.format(blueBin))\nprint('The sum of numbers in RED  bin is {}'.format(redBin))\nprint('------------------------------------------- ')\n\nNumber i =  1 will be put in BLUE bin\nNumber i =  2 will be put in BLUE bin\nNumber i =  3 will be put in BLUE bin\nNumber i =  4 will be put in BLUE bin\nNumber i =  5 will be put in BLUE bin\nNumber i =  6 will be put in BLUE bin\nNumber i =  7 will be put in BLUE bin\nNumber i =  8 will be put in BLUE bin\nNumber i =  9 will be put in BLUE bin\nNumber i = 10 will be put in BLUE bin\nNumber i = 11 will be put in RED bin\nNumber i = 12 will be put in RED bin\nNumber i = 13 will be put in RED bin\nNumber i = 14 will be put in RED bin\nNumber i = 15 will be put in RED bin\nNumber i = 16 will be put in RED bin\nNumber i = 17 will be put in RED bin\nNumber i = 18 will be put in RED bin\nNumber i = 19 will be put in RED bin\nNumber i = 20 will be put in RED bin\n \n------------------------------------------- \nThe sum of numbers in BLUE bin is 55\nThe sum of numbers in RED  bin is 155\n------------------------------------------- \n\n\n\n\n\nblueBin &lt;- 0\nredBin &lt;- 0\n\nfor (i in 1:20) {\n  if (i &lt;= 10) {\n    cat(\"Number i =\", i, \"will be put in BLUE bin\\n\")\n    blueBin &lt;- blueBin + i\n  } else {\n    cat(\"Number i =\", i, \"will be put in RED bin\\n\")\n    redBin &lt;- redBin + i\n  }\n}\ncat(\"\\n\")\ncat(\"-------------------------------------------\\n\")\ncat(\"The sum of numbers in BLUE bin is\", blueBin, \"\\n\")\ncat(\"The sum of numbers in RED bin is\", redBin, \"\\n\")\ncat(\"-------------------------------------------\\n\")\n\nNumber i = 1 will be put in BLUE bin\nNumber i = 2 will be put in BLUE bin\nNumber i = 3 will be put in BLUE bin\nNumber i = 4 will be put in BLUE bin\nNumber i = 5 will be put in BLUE bin\nNumber i = 6 will be put in BLUE bin\nNumber i = 7 will be put in BLUE bin\nNumber i = 8 will be put in BLUE bin\nNumber i = 9 will be put in BLUE bin\nNumber i = 10 will be put in BLUE bin\nNumber i = 11 will be put in RED bin\nNumber i = 12 will be put in RED bin\nNumber i = 13 will be put in RED bin\nNumber i = 14 will be put in RED bin\nNumber i = 15 will be put in RED bin\nNumber i = 16 will be put in RED bin\nNumber i = 17 will be put in RED bin\nNumber i = 18 will be put in RED bin\nNumber i = 19 will be put in RED bin\nNumber i = 20 will be put in RED bin\n\n-------------------------------------------\nThe sum of numbers in BLUE bin is 55 \nThe sum of numbers in RED bin is 155 \n-------------------------------------------",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Basic Programming Techniques</span>"
    ]
  },
  {
    "objectID": "Loop.html#time-your-work",
    "href": "Loop.html#time-your-work",
    "title": "\n5  Basic Programming Techniques\n",
    "section": "\n5.5 Time Your Work",
    "text": "5.5 Time Your Work\nSometimes it is useful to know how long it takes for a script to run through. In order to accomplish this you can use the time() function from the time library. When you call it, it gives you the current time. You would therefore call the time function at the beginning of your script and store that value in some variable, say tic. This is followed by your \"main code\" that works through a series of commands. At the end of the script you call for the current time again and store it in a variable, say, toc. Then you simply take the difference between tic and toc variable and you'll have your elapsed time period. Here's an example that times a \"large\" while loop.\n\n\nPython Code\nR Code\n\n\n\n\nimport time  # Imports system time module to time your script\ntic = time.time()\n\nx = 0\nwhile (x &lt; 1000000):\n    # add some stuff that needs to be calculated, e.g.\n    y = y + x\n    x += 1\n\ntoc = time.time()\nprint(\"Time elapsed = {} seconds\".format(toc - tic))\n\nTime elapsed = 0.10620260238647461 seconds\n\n\n\n\n\ntic &lt;- Sys.time()\n\nx &lt;- 0\ny &lt;- 0\nwhile (x &lt; 1000000) {\n  # add some stuff that needs to be calculated, e.g.\n  y &lt;- y + x\n  x &lt;- x + 1\n}\n\ntoc &lt;- Sys.time()\ncat(\"Time elapsed =\", as.numeric(toc - tic), \"seconds\\n\")\n\nTime elapsed = 0.03648233 seconds\n\n\n\n\n\n\n\n\n\n\n\nKey Concepts and Summary\n\n\n\n\nA branching statement allows you to split your code into alternative execution blocks.\nA loop statement allows you to execute code blocks repeatedly.\nYou can nest loops inside of each other and you can nest branching statements as well.\n\n\n\n\n\n\n\n\n\nSelf-check questions\n\n\n\n\n\n\nGenerate a list with entries from 14 to 40 with stepsize 2.\nWrite a loop that divides the first 10 entries of your list above by 5 3. Write a loop that replaces all the elements of your list with elements that are half a big. If you list says [1,2,3,4] your new list should read [0.5,1,1.5,2].\n\n\n\n\n\n\n\nFigure 5.1: If Branching Illustration\nFigure 5.2: Loop Structure Illustration",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Basic Programming Techniques</span>"
    ]
  },
  {
    "objectID": "Debugging.html",
    "href": "Debugging.html",
    "title": "\n6  Debugging\n",
    "section": "",
    "text": "6.1 Using Print Statements to Spot Mistakes\nThe easiest method to find errors or computer-bugs is to put a lot of print() statements into your code, so you can see how specific variable values change.\nHere our program throws an error message because at some point in our loop we attempt to divide by zero, which is not defined. This is pretty obvious in this example but let's assume that we have trouble spotting the mistake. What you can do now is you can add print() statements into the loop so you can see how the values of the variables change:\nYou can now see how the variables change as the loop progresses and how the division by zero error happens eventually.",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Debugging</span>"
    ]
  },
  {
    "objectID": "Debugging.html#using-print-statements-to-spot-mistakes",
    "href": "Debugging.html#using-print-statements-to-spot-mistakes",
    "title": "\n6  Debugging\n",
    "section": "",
    "text": "Python Code\nR Code\n\n\n\n\nfor i in range(4):\n    x = 2 - i\n    y = 100 / x\n\nError: ZeroDivisionError: division by zero\n\n\n\n\n\nfor (i in 0:3) {\n  x &lt;- 2 - i\n  y &lt;- 100 / x\n}\n\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nfor i in range(4):\n    x = 2 - i\n    print('x = ', x)\n    y = 100 / x\n    print('y = ', y)\n\nError: ZeroDivisionError: division by zero\n\n\n\n\n\nfor (i in 0:3) {\n  x &lt;- 2 - i\n  cat(\"x =\", x, \"\\n\")\n  y &lt;- 100 / x\n  cat(\"y =\", y, \"\\n\")\n}\n\nx = 2 \ny = 50 \nx = 1 \ny = 100 \nx = 0 \ny = Inf \nx = -1 \ny = -100",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Debugging</span>"
    ]
  },
  {
    "objectID": "Debugging.html#using-the-debugger",
    "href": "Debugging.html#using-the-debugger",
    "title": "\n6  Debugging\n",
    "section": "\n6.2 Using the Debugger",
    "text": "6.2 Using the Debugger\nWe next import the debugger:\n\n\nPython Code\nR Code\n\n\n\nfor i in range(4):\n    import pdb; pdb.set_trace()  # XXX BREAKPOINT\n    x = 2 - i\n    y = 100 / x\n\n\n\nfor (i in 0:3) {\n  browser()  # Breakpoint\n  x &lt;- 2 - i\n  y &lt;- 100 / x\n}\n\nCalled from: eval(expr, envir, enclos)\ndebug at &lt;text&gt;#4: x &lt;- 2 - i\ndebug at &lt;text&gt;#5: y &lt;- 100/x\ndebug at &lt;text&gt;#3: browser()\ndebug at &lt;text&gt;#4: x &lt;- 2 - i\ndebug at &lt;text&gt;#5: y &lt;- 100/x\ndebug at &lt;text&gt;#3: browser()\ndebug at &lt;text&gt;#4: x &lt;- 2 - i\ndebug at &lt;text&gt;#5: y &lt;- 100/x\ndebug at &lt;text&gt;#3: browser()\ndebug at &lt;text&gt;#4: x &lt;- 2 - i\ndebug at &lt;text&gt;#5: y &lt;- 100/x\n\n\n\n\n\nThis will stop the code in the line where you set the Breakpoint. So the code will enter the loop with value i=0 and then stop the execution.\nYou can now inspect variable values from the command line. Type ? and hit enter and you will see all the commands that you can now run.\n\nIf you type n it will simply execute the next line of code. You can step through the code line by line and observe exactly what changes in each step.\nIf you type cont for continue it will run the code until it hits the Breakpoint again in the second iteration of the loop. It will then pause again at i=1 so that you can inspect all the variables again from command line.\n\n\n\n\n\n\n\nSelf-check questions\n\n\n\n\n\nDebug the following program:\nd=8\n1myvar = 80\n2myList = [23, 'jim\", my, 34]\n\nfor listItems in enumerate(2myList):\n    print('Element {} in my list is equal to {}'.format(listItems)",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Debugging</span>"
    ]
  },
  {
    "objectID": "Arrays.html",
    "href": "Arrays.html",
    "title": "\n7  Vectors and Matrices\n",
    "section": "",
    "text": "7.1 Definitions of Vectors\nA vector is a list of numbers that we can do “math” with. The numbers in the vector are indexed, so that we can access them. Note that vector indexing in Python starts with zero, not with 1. So Python counts the first element in a vector as element 0, the second as element 1, etc. We first need to import some important packages so that Python understands basic numerical procedures and definitions, like vectors and matrices and not with a list. The command np.array from the numpy package does just that.\nHere are some examples. Vectors x y year and names are assigned as follows:\nRemember that Python starts numbering the elements with 0 and not 1! So if you want to access the first element in a vector x you’d need to type: xv[0].\nIf you would like to print the vector formatted, you need to set the format option of the numpy object as:\nIf you would like to generate a certain number of elements between two boundary points you can use np.linspace(). Let us say we would like to generate some numbers between the lower bound of 2000 and the upper bound of 2003. We call this spanning a grid from 2000 to 2003 where we basically break the interval into evenly spaced sub-intervals. This is important for graphing (or plotting) mathematical functions which we do in the next chapter.\nLet us say we want to span a grid with 5 gridpoints, so that the interval from 2000 to 2003 is broken in equally wide sub-intervals, we would write the following:\nRemember from the previous chapter how arrays are very similar to lists and tuples. An array is basically a list of numbers, and numbers only! This means that indexing will work on an array, just as it worked on the list object. Same with slicing if you remember that from the previous chapter.\nHere is again a list example. Let us define it first and then extract some objects from the list (which is itself an object – remember in Python everything is an object).",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Vectors and Matrices</span>"
    ]
  },
  {
    "objectID": "Arrays.html#definitions-of-vectors",
    "href": "Arrays.html#definitions-of-vectors",
    "title": "\n7  Vectors and Matrices\n",
    "section": "",
    "text": "Python Code\nR Code\n\n\n\n\nimport numpy as np\n\n# You can document your script files using the ``#`` symbol.\n# This allows you to add commentary to your codes.\n\nxv = np.array([1, 3.3333, 4.8976, 9])\nyv = np.array([9.233, 0.3453, 3.29999, 2.8])\n\nprint(\"xv = {}\".format(xv))\nprint(\"yv = {}\".format(yv))\nprint(\"xv[0] = {}\".format(xv[0]))\nprint(\"xv[1] = {}\".format(xv[1]))\nprint(\"xv[2] = {}\".format(xv[2]))\n\nxv = [1.     3.3333 4.8976 9.    ]\nyv = [9.233   0.3453  3.29999 2.8    ]\nxv[0] = 1.0\nxv[1] = 3.3333\nxv[2] = 4.8976\n\n\n\n\n\n# You can document your script files using the ``#`` symbol.\n# This allows you to add commentary to your codes.\n\nxv &lt;- c(1, 3.3333, 4.8976, 9)\nyv &lt;- c(9.233, 0.3453, 3.29999, 2.8)\n\ncat(\"xv =\", xv, \"\\n\")\ncat(\"yv =\", yv, \"\\n\")\ncat(\"xv[1] =\", xv[1], \"\\n\")\ncat(\"xv[2] =\", xv[2], \"\\n\")\ncat(\"xv[3] =\", xv[3], \"\\n\")\n\nxv = 1 3.3333 4.8976 9 \nyv = 9.233 0.3453 3.29999 2.8 \nxv[1] = 1 \nxv[2] = 3.3333 \nxv[3] = 4.8976 \n\n\n\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nnp.set_printoptions(precision=2)\nprint(\"xv= {}\".format(xv))\nprint(\"yv= {}\".format(yv))\n\nxv= [1.   3.33 4.9  9.  ]\nyv= [9.23 0.35 3.3  2.8 ]\n\n\n\n\n\noptions(digits = 2)  # Set the number of digits to display\n\ncat(\"xv =\", xv, \"\\n\")\ncat(\"yv =\", yv, \"\\n\")\n\nxv = 1 3.3 4.9 9 \nyv = 9.2 0.35 3.3 2.8 \n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote that if you like a vector: 2000,2001,2002,2003 you need to write the arange command with the upper limit+1.\n\n\n\n\nPython Code\nR Code\n\n\n\n\nyear  = np.arange(2000,2004,1)   # np.arange(from, to, stepsize)\nprint(\"year= {}\".format(year))\n\nyear= [2000 2001 2002 2003]\n\n\n\n\n\nyear &lt;- seq(2000, 2003, by = 1)  # seq(from, to, by)\ncat(\"year =\", year, \"\\n\")\n\nyear = 2000 2001 2002 2003 \n\n\n\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nsomev = np.linspace(2000,2003,5) # np.linspace(from, to, nr. of steps)\nprint(\"somev= {}\".format(somev))\n\nsomev= [2000.   2000.75 2001.5  2002.25 2003.  ]\n\n\n\n\n\nsomev &lt;- seq(2000, 2003, length.out = 5)  # seq(from, to, length.out)\ncat(\"somev =\", somev, \"\\n\")\n\nsomev = 2000 2001 2002 2002 2003 \n\n\n\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\n# A list of strings is simply:\nnames_list = [\"Tom\", \"Dick\", \"Harry\", \"Patrick\"]\n\n# A tuple of strings is simply:\nnames_tuple = (\"Tom\", \"Dick\", \"Harry\", \"Patrick\")\n\nprint(\"names_list= {}\".format(names_list))\nprint(\"names_tuple= {}\".format(names_tuple))\n\nprint(\"names_list[1]= {}\".format(names_list[1]))\nprint(\"names_list[3]= {}\".format(names_list[3]))\n\nnames_list= ['Tom', 'Dick', 'Harry', 'Patrick']\nnames_tuple= ('Tom', 'Dick', 'Harry', 'Patrick')\nnames_list[1]= Dick\nnames_list[3]= Patrick\n\n\n\n\n\n# A list of strings is simply:\nnames_list &lt;- c(\"Tom\", \"Dick\", \"Harry\", \"Patrick\")\n\n# A vector of strings is equivalent to a tuple in Python\nnames_vector &lt;- c(\"Tom\", \"Dick\", \"Harry\", \"Patrick\")\n\ncat(\"names_list =\", names_list, \"\\n\")\ncat(\"names_vector =\", names_vector, \"\\n\")\n\ncat(\"names_list[2] =\", names_list[2], \"\\n\")\ncat(\"names_list[4] =\", names_list[4], \"\\n\")\n\nnames_list = Tom Dick Harry Patrick \nnames_vector = Tom Dick Harry Patrick \nnames_list[2] = Dick \nnames_list[4] = Patrick",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Vectors and Matrices</span>"
    ]
  },
  {
    "objectID": "Arrays.html#simple-calculations-with-vectors",
    "href": "Arrays.html#simple-calculations-with-vectors",
    "title": "\n7  Vectors and Matrices\n",
    "section": "\n7.2 Simple Calculations with Vectors",
    "text": "7.2 Simple Calculations with Vectors\nLet us do some simple math with arrays (or vectors, which are one dimensional arrays).\n\n\nPython Code\nR Code\n\n\n\n\nimport numpy as np\n# Element-by-element operations\nx1 = np.array([1,3,4,9])\nx2 = np.array([2,5,6,3])\n#\nprint(\" --- OUTPUT: --- \")\nprint(\"x1= {}\".format(x1))\nprint(\"x2= {}\".format(x2))\nprint(\" ---------------- \")\nprint(\"x1+x2= {}\".format(x1+x2))\nprint(\"x1*x2= {}\".format(x1*x2))\n\n --- OUTPUT: --- \nx1= [1 3 4 9]\nx2= [2 5 6 3]\n ---------------- \nx1+x2= [ 3  8 10 12]\nx1*x2= [ 2 15 24 27]\n\n\n\n\n\n# Element-by-element operations\nx1 &lt;- c(1, 3, 4, 9)\nx2 &lt;- c(2, 5, 6, 3)\ncat(\" --- OUTPUT: --- \\n\")\ncat(\"x1 =\", x1, \"\\n\")\ncat(\"x2 =\", x2, \"\\n\")\ncat(\" ---------------- \\n\")\ncat(\"x1 + x2 =\", x1 + x2, \"\\n\")\ncat(\"x1 * x2 =\", x1 * x2, \"\\n\")\n\n --- OUTPUT: --- \nx1 = 1 3 4 9 \nx2 = 2 5 6 3 \n ---------------- \nx1 + x2 = 3 8 10 12 \nx1 * x2 = 2 15 24 27 \n\n\n\n\n\nAs you can see, the numbers are added element-by-element and they are multiplied element-by-element.\nThis is different behavior from what we have seen so far from lists. Let us repeat the above example, but instead of numpy-arrays we use lists instead. We would then have:\n\n\nPython Code\nR Code\n\n\n\n\nx1_list = [1,3,4,9]\nx2_list = [2,5,6,3]\n#\nprint(\" --- OUTPUT: --- \")\nprint(\"x1_list = {}\".format(x1_list ))\nprint(\"x2_list = {}\".format(x2_list ))\nprint(\" ---------------- \")\nprint(\"x1_list + x2_list = {}\".format(x1_list +x2_list ))\n\n --- OUTPUT: --- \nx1_list = [1, 3, 4, 9]\nx2_list = [2, 5, 6, 3]\n ---------------- \nx1_list + x2_list = [1, 3, 4, 9, 2, 5, 6, 3]\n\n\n\n\n\nx1_list &lt;- c(1, 3, 4, 9)\nx2_list &lt;- c(2, 5, 6, 3)\n\ncat(\" --- OUTPUT: --- \\n\")\ncat(\"x1_list =\", x1_list, \"\\n\")\ncat(\"x2_list =\", x2_list, \"\\n\")\ncat(\" ---------------- \\n\")\ncat(\"x1_list + x2_list =\", x1_list + x2_list, \"\\n\")\n\n --- OUTPUT: --- \nx1_list = 1 3 4 9 \nx2_list = 2 5 6 3 \n ---------------- \nx1_list + x2_list = 3 8 10 12 \n\n\n\n\n\nThis just joins the lists together. It does not add the numbers in the list.\nIf, on the other hand, we try to multiply the lists we get:\n\n\nPython Code\nR Code\n\n\n\n\nprint(\"x1_list*x2_list= {}\".format(x1_list*x2_list))\n\nError: TypeError: can't multiply sequence by non-int of type 'list'\n\n\n\n\n\ncat(\"x1_list * x2_list =\", x1_list * x2_list, \"\\n\")\n\nx1_list * x2_list = 2 15 24 27 \n\n\n\n\n\nThis results in an error message. You cannot really do “math” on lists because the content of lists can be numbers, words, other weird objects and it is not guaranteed that doing math with these is possible. Hence, Python will not let you do “math” with lists. You can only do “list things” such as adding stuff to it, printing it, extracting info from it, etc.",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Vectors and Matrices</span>"
    ]
  },
  {
    "objectID": "Arrays.html#simple-calculations-with-matrices",
    "href": "Arrays.html#simple-calculations-with-matrices",
    "title": "\n7  Vectors and Matrices\n",
    "section": "\n7.3 Simple Calculations with Matrices",
    "text": "7.3 Simple Calculations with Matrices\nMatrices are “two dimensional” vectors. Think of a speadsheet with rows and columns that can only be filled with numbers. In Python we define as matrix again with the array() function. Here is a simple Matrix with 2 rows and 2 columns. We call this a 2-by-2 or \\(2\\times2\\) matrix.\n\n\nPython Code\nR Code\n\n\n\n\nimport numpy as np\nA = np.array([[2,3],[4,5]])\nB = np.array([[2,6],[1,3]])\n#\nprint(\" --- OUTPUT: --- \")\nprint(\"A= \\n {}\".format(A))\nprint(\"B= \\n {}\".format(B))\nprint(\" ---------------- \")\nprint(\"A*B= \\n {}\".format(A*B))\nprint(\"A-B= \\n {}\".format(A-B))\nprint(\" ---------------- \")\n\n --- OUTPUT: --- \nA= \n [[2 3]\n [4 5]]\nB= \n [[2 6]\n [1 3]]\n ---------------- \nA*B= \n [[ 4 18]\n [ 4 15]]\nA-B= \n [[ 0 -3]\n [ 3  2]]\n ---------------- \n\n\n\n\n\nA &lt;- matrix(c(2, 4, 3, 5), nrow = 2, byrow = TRUE)\nB &lt;- matrix(c(2, 1, 6, 3), nrow = 2, byrow = TRUE)\n\ncat(\" --- OUTPUT: --- \\n\")\ncat(\"A= \\n\", A, \"\\n\")\ncat(\"B= \\n\", B, \"\\n\")\ncat(\" ---------------- \\n\")\ncat(\"A * B= \\n\", A * B, \"\\n\")\ncat(\"A - B= \\n\", A - B, \"\\n\")\ncat(\" ---------------- \\n\")\n\n --- OUTPUT: --- \nA= \n 2 3 4 5 \nB= \n 2 6 1 3 \n ---------------- \nA * B= \n 4 18 4 15 \nA - B= \n 0 -3 3 2 \n ---------------- \n\n\n\n\n\nYou can again see that when you add or multiply matrices, the operation is done element-by-element. This means that the number in position 0,0 (row 1, column 1) in matrix A is multiplied with the number in the same position 0,0 (row 1, column 1) in matrix B.\nPython has some built in functions to help you generate often used matrices automatically, so you do not always have to type them in.\nIf you want to generate matrices filled with either zeros or ones of a particular size in Python you can use the following:\n\n\nPython Code\nR Code\n\n\n\n\nimport numpy as np\nA = np.zeros((3,5), float)\nB = np.ones((4,3), float)\n\nprint(\" --- OUTPUT: --- \")\nprint(\"A= \\n {}\".format(A))\nprint(\" ---------------- \")\nprint(\"B= \\n {}\".format(B))\n\n --- OUTPUT: --- \nA= \n [[0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0.]]\n ---------------- \nB= \n [[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]]\n\n\n\n\n\nA &lt;- matrix(0, nrow = 3, ncol = 5)\nB &lt;- matrix(1, nrow = 4, ncol = 3)\n\ncat(\" --- OUTPUT: --- \\n\")\ncat(\"A= \\n\", A, \"\\n\")\ncat(\" ---------------- \\n\")\ncat(\"B= \\n\", B, \"\\n\")\n\n --- OUTPUT: --- \nA= \n 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n ---------------- \nB= \n 1 1 1 1 1 1 1 1 1 1 1 1 \n\n\n\n\n\nIf you want a matrix with integer numbers, then simply define the matrix as datatype int so that:\n\n\nPython Code\nR Code\n\n\n\n\nimport numpy as np\nA = np.zeros((3,5), int)\nb = np.ones((4,3), int)\n\nprint(\" --- OUTPUT: --- \")\nprint(\"A= \\n {}\".format(A))\nprint(\" ---------------- \")\nprint(\"B= \\n {}\".format(B))\n\n --- OUTPUT: --- \nA= \n [[0 0 0 0 0]\n [0 0 0 0 0]\n [0 0 0 0 0]]\n ---------------- \nB= \n [[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]]\n\n\n\n\n\nA &lt;- matrix(0, nrow = 3, ncol = 5, byrow = TRUE)\nB &lt;- matrix(1, nrow = 4, ncol = 3, byrow = TRUE)\n\ncat(\" --- OUTPUT: --- \\n\")\ncat(\"A= \\n\", A, \"\\n\")\ncat(\" ---------------- \\n\")\ncat(\"B= \\n\", B, \"\\n\")\n\n --- OUTPUT: --- \nA= \n 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n ---------------- \nB= \n 1 1 1 1 1 1 1 1 1 1 1 1 \n\n\n\n\n\nIf you want to create an identity matrix with the value one in the main diagonal and zeros everywhere else you can:\n\n\nPython Code\nR Code\n\n\n\n#| results: hold\n\nimport numpy as np\nC = np.identity(3)\n\nprint(\" --- OUTPUT: --- \")\n\n --- OUTPUT: --- \n\nprint(\"C= \\n {}\".format(C))\n\nC= \n [[1. 0. 0.]\n [0. 1. 0.]\n [0. 0. 1.]]\n\n\n\n\n\nC &lt;- diag(1, nrow = 3)\n\ncat(\" --- OUTPUT: --- \\n\")\ncat(\"C= \\n\", C, \"\\n\")\n\n --- OUTPUT: --- \nC= \n 1 0 0 0 1 0 0 0 1",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Vectors and Matrices</span>"
    ]
  },
  {
    "objectID": "Arrays.html#vector-manipulation",
    "href": "Arrays.html#vector-manipulation",
    "title": "\n7  Vectors and Matrices\n",
    "section": "\n7.4 Vector Manipulation",
    "text": "7.4 Vector Manipulation\n\n7.4.1 Transposing Vectors\nA vector of order \\(n&gt;0\\) is a set of ordered numbers. \\(a = \\left[ \\begin{array}{c} 4 \\\\ 3 \\end{array} \\right], \\:\ne_{1} = \\left[ \\begin{array}{c} 1 \\\\ 0 \\\\ 0 \\end{array} \\right], \\: ...\\)\nThese are column vectors. Row vectors are transposed column vectors, that is \\(a'=[4 \\: 3], \\: e'_{1}=[1 \\: 0 \\: 0], \\: ...\\)\nIn Python vectors are formed as column vectors by default. We can simply transpose vectors using the transpose function t() as follows:\n\n\nPython Code\nR Code\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport math as m\nfrom scipy import stats as st\nimport time  # Imports system time module to time your script\n\nplt.close('all')  # close all open figures\n\n\n\n\nlibrary(ggplot2)  # Load the ggplot2 library for plotting\ngraphics.off()  # Close all open figures\n\n# Other libraries are automatically loaded in R when needed\n\n# There's no direct equivalent to the 'time' module in Python for timing in R.\n# However, you can use the 'system.time()' function to measure the execution time of expressions.\n# You can proceed with the rest of your R code here.\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n#| results: hold\n\na = np.array([4,3])      # column vector\naprime = a.transpose()   # row vector\nprint(\"a= {}\".format(a))\n\na= [4 3]\n\nprint(\"a'= {}\".format(aprime))\n\na'= [4 3]\n\n\n\n\n\na &lt;- c(4, 3)  # column vector\naprime &lt;- t(a)  # transpose to get row vector\n\ncat(\"a =\", a, \"\\n\")\ncat(\"a' =\", aprime, \"\\n\")\n\na = 4 3 \na' = 4 3 \n\n\n\n\n\n\n7.4.2 Length of Vectors\nA vector (at least a two dimensional one) has a convenient geometric representation. It is an arrow, where the two coordinates indicate the direction and length of this arrow. Vector \\(a = \\left[ \\begin{array}{c} 4\n\\\\ 3 \\end{array} \\right]\\) points to the upper right (i.e. 4 over, 3 up). The length of a vector can be calculated using the Pythagoras theorem for the triangle. The length of vector \\(a = \\left[ \\begin{array}{c} a_1 \\\\ a_2\n\\end{array} \\right]\\) where \\(a_1\\) and \\(a_2\\) are simply numbers, can be calculated as \\(\\|a\\| = \\sqrt{a_1^2 + a_2^2}.\\) For our example, the vector norm for \\(a = \\left[ \\begin{array}{c} 4 \\\\ 3 \\end{array} \\right]\n\\text{ is } \\rightarrow \\|a\\| = \\sqrt{4^2 + 3^2} = 5.\\) In Python we can simply define a vector and calculate its norm (or length) as\n\n\nPython Code\nR Code\n\n\n\n\na = np.array([4,3])\nnorma = np.sqrt(np.sum(a**2))\nprint(\"norm(a) = \", norma)\nprint(\"norm(a) = \", np.linalg.norm(a))   # built in norm() command\n\nnorm(a) =  5.0\nnorm(a) =  5.0\n\n\n\n\n\na &lt;- c(4, 3)\nnorma &lt;- sqrt(sum(a^2))\n\ncat(\"norm(a) =\", norma, \"\\n\")\ncat(\"norm(a) =\", norm(a), \"\\n\")  # built-in norm() command\n\nError in norm(a): 'A' must be a numeric matrix\n\n\nnorm(a) = 5 \n\n\n\n\n\n\n7.4.3 Adding Two Vectors\nAdding vectors is simple. We just add all numbers of two vectors ‘element-by-element’. So that \\(a + b = \\left[ \\begin{array}{c} a_1  + b_1 \\\\\na_2+b_2 \\end{array} \\right].\\) In Python this is done with\n\n\nPython Code\nR Code\n\n\n\n\na = np.array([4,3])\nb = np.array([12,5])\nprint(\"a= \", a)\nprint(\"b= \", b)\nprint(\"a+b=\", a+b)   # adding up vectors element-by-element\n\na=  [4 3]\nb=  [12  5]\na+b= [16  8]\n\n\n\n\n\na &lt;- c(4, 3)\nb &lt;- c(12, 5)\n\ncat(\"a =\", a, \"\\n\")\ncat(\"b =\", b, \"\\n\")\ncat(\"a + b =\", a + b, \"\\n\")  # adding up vectors element-by-element\n\na = 4 3 \nb = 12 5 \na + b = 16 8 \n\n\n\n\n\n\n7.4.4 Multiplication of Vectors\nA vector can be multiplied by a number (we call it a scalar denoted as :math:` lambda` to distinguish it from vectors and the numbers that it contains). The scalar is multiplied with all numbers of the vector. If we multiply the vector with \\(\\lambda &gt; 1\\) then the arrow that the vector symbolizes is becoming longer. If we multiply the vector with \\(0 &lt; \\lambda &lt; 1\\) the arrow gets shorter. If we multiply the vector with a negative number \\(\\lambda &lt; 0\\) then the arrow changes direction. More formally this is \\(\\lambda * a =\n\\left[ \\begin{array}{c} \\lambda *a_1 \\\\ \\lambda *a_2 \\end{array} \\right].\\)\nIn Python it’s simply\n\n\nPython Code\nR Code\n\n\n\n\na = np.array([4,3])\nanorm  = np.sqrt(np.sum(a**2)) # norm of vector a\nprint(\"a=\", a)\nprint(\"anorm=\", anorm)\nb = 5*a\nbnorm = np.sqrt(np.sum(b**2)) # norm of longer vector\nprint(\"b=\", b)\nprint(\"bnorm=\", bnorm)\nc = 0.5*a\ncnorm = np.sqrt(np.sum(c**2)) # norm of shorter vector\nprint(\"c=\", c)\nprint(\"cnorm=\", cnorm )\nd = -3*a       # vector changes direction\ndnorm = np.sqrt(np.sum(d**2))\nprint(\"d=\", d)\nprint(\"dnorm=\", dnorm)\n\na= [4 3]\nanorm= 5.0\nb= [20 15]\nbnorm= 25.0\nc= [2.  1.5]\ncnorm= 2.5\nd= [-12  -9]\ndnorm= 15.0\n\n\n\n\n\na &lt;- c(4, 3)\nanorm &lt;- sqrt(sum(a^2))  # norm of vector a\n\ncat(\"a =\", a, \"\\n\")\ncat(\"anorm =\", anorm, \"\\n\")\n\nb &lt;- 5 * a\nbnorm &lt;- sqrt(sum(b^2))  # norm of longer vector\n\ncat(\"b =\", b, \"\\n\")\ncat(\"bnorm =\", bnorm, \"\\n\")\n\nc &lt;- 0.5 * a\ncnorm &lt;- sqrt(sum(c^2))  # norm of shorter vector\n\ncat(\"c =\", c, \"\\n\")\ncat(\"cnorm =\", cnorm, \"\\n\")\n\nd &lt;- -3 * a  # vector changes direction\ndnorm &lt;- sqrt(sum(d^2))\n\ncat(\"d =\", d, \"\\n\")\ncat(\"dnorm =\", dnorm, \"\\n\")\n\na = 4 3 \nanorm = 5 \nb = 20 15 \nbnorm = 25 \nc = 2 1.5 \ncnorm = 2.5 \nd = -12 -9 \ndnorm = 15 \n\n\n\n\n\nWhen multiplying two vectors we form a so called ‘inner product’ as follows: \\(a \\times b = \\sum_{i=1}^{n}a_i*b_i.\\)\nThe following example shows this with numbers:\n\\[a = \\left[ \\begin{array}{c} 4 \\\\ 3 \\end{array} \\right] \\text{ and }  b =\n\\left[ \\begin{array}{c} 12 \\\\ 5 \\end{array} \\right]\\]\nthen\n\\(a \\times b = 4*12 + 3*5.\\) In Python the inner product is simply:\n\n\nPython Code\nR Code\n\n\n\n\nav = np.array([4,3])\nbv = np.array([12,5])\nprint(\"a= \", av)\nprint(\"b= \", bv)\nprint(\"a*b =\", np.sum(a*b))   # inner product\n\na=  [4 3]\nb=  [12  5]\na*b = 125\n\n\n\n\n\nav &lt;- c(4, 3)\nbv &lt;- c(12, 5)\n\ncat(\"a =\", av, \"\\n\")\ncat(\"b =\", bv, \"\\n\")\ncat(\"a * b =\", sum(av * bv), \"\\n\")  # inner product\n\na = 4 3 \nb = 12 5 \na * b = 63",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Vectors and Matrices</span>"
    ]
  },
  {
    "objectID": "Arrays.html#matrix-manipulation",
    "href": "Arrays.html#matrix-manipulation",
    "title": "\n7  Vectors and Matrices\n",
    "section": "\n7.5 Matrix Manipulation",
    "text": "7.5 Matrix Manipulation\n\n7.5.1 Indexing and Accessing Elements of a Matrix\n\n\nPython Code\nR Code\n\n\n\n\nA = np.array([[11,12,13,14],[21,22,23,24],[31,32,33,34]])\n\nprint(\"A=\", A)\nprint(\"---------------\")\nprint()\n\n# Element row 2, column 3 (remember Python starts indexing at 0!!)\nprint(\"A[1,2] = \", A[1,2])\nprint(\"---------------\")\nprint(\"A[0,:] = \", A[0,:])   # First row\nprint(\"---------------\")\nprint(\"A[:,0] = \", A[:,0])   # First column\nprint(\"---------------\")\nprint(\"A[1:,:] = \", A[1:,])  # All, except first row\n\nA= [[11 12 13 14]\n [21 22 23 24]\n [31 32 33 34]]\n---------------\n\nA[1,2] =  23\n---------------\nA[0,:] =  [11 12 13 14]\n---------------\nA[:,0] =  [11 21 31]\n---------------\nA[1:,:] =  [[21 22 23 24]\n [31 32 33 34]]\n\n\n\n\n\nA &lt;- matrix(c(11, 21, 31, 12, 22, 32, 13, 23, 33, 14, 24, 34), nrow = 3, byrow = TRUE)\n\ncat(\"A =\", A, \"\\n\")\ncat(\"---------------\\n\\n\")\n\n# Element row 2, column 3 (remember R starts indexing at 1!!)\ncat(\"A[2, 3] =\", A[2, 3], \"\\n\")\ncat(\"---------------\\n\")\ncat(\"A[1,] =\", A[1,], \"\\n\")   # First row\ncat(\"---------------\\n\")\ncat(\"A[,1] =\", A[,1], \"\\n\")   # First column\ncat(\"---------------\\n\")\ncat(\"A[-1,] =\", A[-1,], \"\\n\")  # All, except first row\n\nA = 11 22 33 21 32 14 31 13 24 12 23 34 \n---------------\n\nA[2, 3] = 13 \n---------------\nA[1,] = 11 21 31 12 \n---------------\nA[,1] = 11 22 33 \n---------------\nA[-1,] = 22 33 32 14 13 24 23 34 \n\n\n\n\n\nIf you want to remove columns or rows you can use the take method and assign the result to a new matrix. Let’s say you would like to eliminate the second column from a matrix A.\n\n\nPython code\nR Code\n\n\n\n\nprint(\"A=\", A)\nprint(\"---------------\")\n\n# Remove column 2 (or take column 1, 3, and 4)\nB = A.take([0,2,3], axis=1)\nprint(\"B =\", B )\n\nA= [[11 12 13 14]\n [21 22 23 24]\n [31 32 33 34]]\n---------------\nB = [[11 13 14]\n [21 23 24]\n [31 33 34]]\n\n\n\n\n\ncat(\"A =\", A, \"\\n\")\ncat(\"---------------\\n\")\n\n# Remove column 2 (or take column 1, 3, and 4)\nB &lt;- A[, c(1, 3, 4)]\ncat(\"B =\", B, \"\\n\")\n\nA = 11 22 33 21 32 14 31 13 24 12 23 34 \n---------------\nB = 11 22 33 31 13 24 12 23 34 \n\n\n\n\n\nIf you want to replace matrix elements based on certain criteria you can use the criteria as a logical statement in combination with the choose method. In the next example we replace all the elements of the matrix that are larger than 90 with the number 90. We start by setting some elements of the matrix equal to 99.\n\n\nPython code\nR Code\n\n\n\n\nA[:,0] = 99 # Fill first column with 99\nprint(\"A = \", A)\nprint(\"---------------\")\n\n# Replace all elements &gt; 90 with number 90\nB = (A&gt;90).choose(A,90)\nprint(\"(A&gt;90).choose(A,90) = \", B)\n\nA =  [[99 12 13 14]\n [99 22 23 24]\n [99 32 33 34]]\n---------------\n(A&gt;90).choose(A,90) =  [[90 12 13 14]\n [90 22 23 24]\n [90 32 33 34]]\n\n\n\n\n\nA[, 1] &lt;- 99  # Fill first column with 99\ncat(\"A =\", A, \"\\n\")\ncat(\"---------------\\n\")\n\n# Replace all elements &gt; 90 with number 90\nB &lt;- ifelse(A &gt; 90, 90, A)\ncat(\"(A &gt; 90) * (A, 90) =\", B, \"\\n\")\n\nA = 99 99 99 21 32 14 31 13 24 12 23 34 \n---------------\n(A &gt; 90) * (A, 90) = 90 90 90 21 32 14 31 13 24 12 23 34 \n\n\n\n\n\nIf you want to run a loop “through” a matrix you can first find out the dimensions of the matrix using the shape method and then write nested loops, one for each dimension. Note the indentation of the various print statements in the next example!\n\n\nPython code\nR Code\n\n\n\n\nA = np.array([[11,12,13,14],[21,22,23,24],[31,32,33,34]])\nprint(\"A=\", A)\nprint(\"---------------\")\nprint(\" Start loops \")\nprint(\"---------------\")\n\nnrRows, nrCols = A.shape\nfor i in range(nrRows):\n    print(\"Row {}\".format(i+1))\n    print(\"---------------\")\n\n    for j in range(nrCols):\n        print(\"The element in row {} and column {} is: {}\".format(i+1, j+1, A[i,j]))\n\n    print(\"Done with row {}\".format(i+1))\n    print(\"---------------\")\n\nprint(\"---------------\")\nprint(\" All Done \")\nprint(\"---------------\")\n\nA= [[11 12 13 14]\n [21 22 23 24]\n [31 32 33 34]]\n---------------\n Start loops \n---------------\nRow 1\n---------------\nThe element in row 1 and column 1 is: 11\nThe element in row 1 and column 2 is: 12\nThe element in row 1 and column 3 is: 13\nThe element in row 1 and column 4 is: 14\nDone with row 1\n---------------\nRow 2\n---------------\nThe element in row 2 and column 1 is: 21\nThe element in row 2 and column 2 is: 22\nThe element in row 2 and column 3 is: 23\nThe element in row 2 and column 4 is: 24\nDone with row 2\n---------------\nRow 3\n---------------\nThe element in row 3 and column 1 is: 31\nThe element in row 3 and column 2 is: 32\nThe element in row 3 and column 3 is: 33\nThe element in row 3 and column 4 is: 34\nDone with row 3\n---------------\n---------------\n All Done \n---------------\n\n\n\n\n\nA &lt;- matrix(c(11, 21, 31, 12, 22, 32, 13, 23, 33, 14, 24, 34), nrow = 3, byrow = TRUE)\n\ncat(\"A =\", A, \"\\n\")\ncat(\"---------------\\n\")\ncat(\" Start loops \\n\")\ncat(\"---------------\\n\")\n\nnrRows &lt;- nrow(A)\nnrCols &lt;- ncol(A)\n\nfor (i in 1:nrRows) {\n  cat(\"Row \", i, \"\\n\")\n  cat(\"---------------\\n\")\n\n  for (j in 1:nrCols) {\n    cat(\"The element in row \", i, \" and column \", j, \" is: \", A[i, j], \"\\n\")\n  }\n\n  cat(\"Done with row \", i, \"\\n\")\n  cat(\"---------------\\n\")\n}\n\ncat(\"---------------\\n\")\ncat(\" All Done \\n\")\ncat(\"---------------\\n\")\n\nA = 11 22 33 21 32 14 31 13 24 12 23 34 \n---------------\n Start loops \n---------------\nRow  1 \n---------------\nThe element in row  1  and column  1  is:  11 \nThe element in row  1  and column  2  is:  21 \nThe element in row  1  and column  3  is:  31 \nThe element in row  1  and column  4  is:  12 \nDone with row  1 \n---------------\nRow  2 \n---------------\nThe element in row  2  and column  1  is:  22 \nThe element in row  2  and column  2  is:  32 \nThe element in row  2  and column  3  is:  13 \nThe element in row  2  and column  4  is:  23 \nDone with row  2 \n---------------\nRow  3 \n---------------\nThe element in row  3  and column  1  is:  33 \nThe element in row  3  and column  2  is:  14 \nThe element in row  3  and column  3  is:  24 \nThe element in row  3  and column  4  is:  34 \nDone with row  3 \n---------------\n---------------\n All Done \n---------------\n\n\n\n\n\n\n7.5.2 Transposing Matrices\nMatrices are “two dimensional” vectors. In Python we define a matrix as\n\n\nPython code\nR Code\n\n\n\n\nA = np.array([[2,3],[4,5]])\nB = np.array([[2,6],[1,3]])\nprint(\"A=\", A)\nprint(\"B=\", B)\n\nA= [[2 3]\n [4 5]]\nB= [[2 6]\n [1 3]]\n\n\n\n\n\nA &lt;- matrix(c(2, 4, 3, 5), nrow = 2, byrow = TRUE)\nB &lt;- matrix(c(2, 1, 6, 3), nrow = 2, byrow = TRUE)\n\ncat(\"A =\", A, \"\\n\")\ncat(\"B =\", B, \"\\n\")\n\nA = 2 3 4 5 \nB = 2 6 1 3 \n\n\n\n\n\nTransposing matrices requires again the t() command. It writes each column as row of a new matrix. So that the transpose of matrix \\(A\\) in the above example becomes:\n\n\nPython code\nR Code\n\n\n\n\nA = np.array([[2,3],[4,5]])\nB = np.array([[2,6],[1,3]])\nAtrans = A.transpose()\nprint(\"A=\", A)\nprint(\"A'=\", Atrans)\n\nA= [[2 3]\n [4 5]]\nA'= [[2 4]\n [3 5]]\n\n\n\n\n\nA &lt;- matrix(c(2, 4, 3, 5), nrow = 2, byrow = TRUE)\nAtrans &lt;- t(A)\n\ncat(\"A =\", A, \"\\n\")\ncat(\"A' =\", Atrans, \"\\n\")\n\nA = 2 3 4 5 \nA' = 2 4 3 5 \n\n\n\n\n\nIf we transpose the transpose of matrix A, we get the original matrix A back.\n\n7.5.3 Adding Matrices\nWhen adding two matrices \\(A\\) and \\(B\\) we simply add all the elements of each matrix ‘element-by-element’. Note that the dimensions (i.e. the number of rows and columns) of the two matrices have to be identical. So if matrix \\(A\\) has dimension \\(m \\times n\\), that is \\(m\\) rows and \\(n\\) columns, then matrix \\(B\\) needs to be of dimensions \\(m\n\\times n\\) as well.\n\n\nPython code\nR Code\n\n\n\n\nA = np.array([[2,3],[4,5]])\nB = np.array([[2,6],[1,3]])\nC =  A+B\nprint(\"A=\", A)\nprint(\"B=\", B)\nprint(\"C=\", C)\n\nA= [[2 3]\n [4 5]]\nB= [[2 6]\n [1 3]]\nC= [[4 9]\n [5 8]]\n\n\n\n\n\nA &lt;- matrix(c(2, 4, 3, 5), nrow = 2, byrow = TRUE)\nB &lt;- matrix(c(2, 1, 6, 3), nrow = 2, byrow = TRUE)\nC &lt;- A + B\n\ncat(\"A =\", A, \"\\n\")\ncat(\"B =\", B, \"\\n\")\ncat(\"C =\", C, \"\\n\")\n\nA = 2 3 4 5 \nB = 2 6 1 3 \nC = 4 9 5 8 \n\n\n\n\n\n\n7.5.4 Multiplying Matrices\nWhen multiplying two matrices \\(A\\) and \\(B\\) we need to make sure that the number of columns of matrix \\(A\\) is equal the number of rows of matrix \\(B\\). So if \\(A\\) has dimension \\(m \\times n\\) then \\(B\\) needs to have dimension \\(n \\times r\\) since matrix multiplication implies that we form the ‘inner product’ of each row of \\(A\\) with each column of \\(B\\). This results in a new matrix of dimension \\(m \\times r\\). Here is an example. Given matrices \\(A = \\left[ \\begin{array}{ccc} 12 & 3 &6 \\\\\n9 &-1 & -4 \\end{array} \\right] \\text{ and } B = \\left[ \\begin{array}{cc} 7 & 8\n\\\\ -2 &0 \\\\ 1 & 11 \\end{array} \\right]\\)\nthe product of \\(A\\) \\((2 \\times 3)\\) and \\(B\\) of dimension \\((3 \\times 2)\\) is a matrix \\(C\\) with dimension \\((2 \\times 2)\\):\n\\[AB = \\left[ \\begin{array}{cc} 12*7+3*(-2)+6*1 & 12*8+3*0+6*11 \\\\\n9*7+(-1)*(-2)+(-4)*1 & 9*8+(-1)*0+(-4)*11 \\end{array} \\right].\\]\nIn Python matrix multiplication is achieved using the command dot() or the @ operator. This last operator is new and will only work with Python 3.5 and newer.\n\n\nPython code\nR Code\n\n\n\n\nA = np.array([[12,3,6],[3,-1,-4]])\nB = np.array([[7,8],[-2,0],[1,11]])\nC = np.dot(A,B) # matrix multiplication\nD = A @ B # new matrix multiplication operator\n\nprint(\"A=\", A)\nprint(\"B=\", B)\nprint(\"C=\", C)\nprint(\"D=\", D)\n\nA= [[12  3  6]\n [ 3 -1 -4]]\nB= [[ 7  8]\n [-2  0]\n [ 1 11]]\nC= [[ 84 162]\n [ 19 -20]]\nD= [[ 84 162]\n [ 19 -20]]\n\n\n\n\n\nA &lt;- matrix(c(12, 3, 6, 3, -1, -4), nrow = 2, byrow = TRUE)\nB &lt;- matrix(c(7, 8, -2, 0, 1, 11), nrow = 3, byrow = TRUE)\nC &lt;- A %*% B  # matrix multiplication\n\ncat(\"A =\", A, \"\\n\")\ncat(\"B =\", B, \"\\n\")\ncat(\"C =\", C, \"\\n\")\n\nA = 12 3 3 -1 6 -4 \nB = 7 -2 1 8 0 11 \nC = 84 19 162 -20 \n\n\n\n\n\n\n7.5.5 Multiplying a Matrix with a Vector\nVectors are simply \\(n \\times 1\\) or \\(1 \\times n\\) dimensional matrices so that the same rules as above apply for multiplying a matrix with a vector.\n\n\nPython code\nR Code\n\n\n\n\nA = np.array([[12,3,6],[3,-1,-4]])\nb = np.array([7,-2,1])\nC = np.dot(A,b) # matrix multiplied by vector: (m x n) x (n x 1) = (m x 1)\nD = A @ b # new matrix multiplication operator\nprint(\"A=\", A)\nprint(\"b=\", b)\nprint(\"C=\", C)\nprint(\"D=\", D)\n\nA= [[12  3  6]\n [ 3 -1 -4]]\nb= [ 7 -2  1]\nC= [84 19]\nD= [84 19]\n\n\n\n\n\nA &lt;- matrix(c(12, 3, 6, 3, -1, -4), nrow = 2, byrow = TRUE)\nb &lt;- c(7, -2, 1)\nC &lt;- A %*% b  # matrix multiplied by vector\n\ncat(\"A =\", A, \"\\n\")\ncat(\"b =\", b, \"\\n\")\ncat(\"C =\", C, \"\\n\")\n\nA = 12 3 3 -1 6 -4 \nb = 7 -2 1 \nC = 84 19 \n\n\n\n\n\n\n\n\n\n\n\nKey Concepts and Summary\n\n\n\n\nA vector is a list of numbers.\nA matrix is a 2 dimensional vector.\nA numpy array is a higher dimensional matrix.\nAn array is a higher dimensional list i.e., contents do not have to be numbers\nVectors, matrices, and arrays can be indexed and their content can be overwritten\n\n\n\n\n\n\n\n\n\nSelf-Check Questions\n\n\n\n\n\n\nGenerate a 3x4 matrix with some random numbers\nPrint the first 2 elements of this matrix of the first row\nReplace entry in second row and third column with 100 and print the matrix",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Vectors and Matrices</span>"
    ]
  },
  {
    "objectID": "Plot.html",
    "href": "Plot.html",
    "title": "\n8  Plotting using matplotlib\n",
    "section": "",
    "text": "8.1 Plotting Vectors and Arrays",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Plotting using `matplotlib`</span>"
    ]
  },
  {
    "objectID": "Plot.html#plotting-vectors-and-arrays",
    "href": "Plot.html#plotting-vectors-and-arrays",
    "title": "\n8  Plotting using matplotlib\n",
    "section": "",
    "text": "8.1.1 Plotting Simple Vectors\nWe first define a grid vector xv. We then plot the first vector using the plot() command in Figure 8.1 below:\n\n\nPython Code\nR Code\n\n\n\n\nxv = np.array([1, 2, 3, 4, 5])\ncarsv = np.array([1, 3, 6, 4, 9])\n\n# Set the theme to gray, similar to gray ggplot() theme in R\nsns.set_theme()\nplt.plot(xv, carsv, 'b-', linewidth=2)\nplt.title('Cars', fontsize=14)\n# Save graphs in subfolder Graphs under name: fig1.pdf\n#plt.savefig('./Graphs/fig0.pdf')\n#plt.show()\n\n\n\n\n\n\nFigure 8.1: Figure with Simple Plot\n\n\n\n\n\n\n\nlibrary(ggplot2)\n\nxv &lt;- c(1, 2, 3, 4, 5)\ncarsv &lt;- c(1, 3, 6, 4, 9)\n\ndata &lt;- data.frame(xv, carsv)\n\nggplot(data, aes(x = xv, y = carsv)) +\n  geom_line(color = \"blue\", linewidth = 2) +\n  labs(title = \"Cars\", fontsize = 14) +\n  theme_gray()  # Using a custom theme for nicer plots\n\n\n\n\n\n\nFigure 8.2: Figure with Simple Plot\n\n\n\n\n\n\n\n\n8.1.2 Plotting Two Vectors\nWe first define a couple of vectors.\n\n\nPython Code\nR Code\n\n\n\n\n# Define vectors with 5 values each\nxv     = np.array([1, 2, 3, 4, 5])\ncarsv   = np.array([1, 3, 6, 4, 9])\ntrucksv = np.array([2, 5, 4, 5, 12])\nsuvsv   = np.array([4, 4, 6, 6, 16])\n\n\n\n\nxv &lt;- c(1, 2, 3, 4, 5)\ncarsv &lt;- c(1, 3, 6, 4, 9)\ntrucksv &lt;- c(2, 5, 4, 5, 12)\nsuvsv &lt;- c(4, 4, 6, 6, 16)\n\n\n\n\nWe then plot the carsv and the trucksv vector into one graph in Figure 8.3.\n\n\nPython Code\nR Code\n\n\n\n\nfig, ax = plt.subplots()\nax.plot(xv,carsv, 'k-o', xv,trucksv,'b-.')\n# Create a title with a red, bold/italic font\nax.set_title('Autos')\nax.legend(['cars', 'trucks'],loc='best')\nplt.show()\n\n\n\n\n\n\nFigure 8.3: Figure with Simple Vector Based Plot\n\n\n\n\n\n\n\nggplot(data, aes(x = xv)) +\n  geom_line(aes(y = carsv, color = \"cars\"), linetype = \"solid\", size = 1) +\n  geom_line(aes(y = trucksv, color = \"trucks\"), linetype = \"dotted\", size = 1) +\n  labs(title = \"Autos\") +\n  scale_color_manual(values = c(\"cars\" = \"black\", \"trucks\" = \"blue\")) +\n  theme_gray() +\n  theme(legend.position = \"bottom\")\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\n\n\nFigure 8.4: Figure with Simple Vector Based Plot\n\n\n\n\n\n\n\n\n8.1.3 Graph 3 Car Types\nFinally, we graph all three car types into one figure. This time we save the graph as fig1.pdf into subfolder Graphs. Figure 8.5 shows the resulting graph.\n\n\nPython Code\nR Code\n\n\n\n\n\nfig, ax = plt.subplots()\nax.plot(xv, carsv, 'b-o', xv, trucksv,'r-^', xv, suvsv, 'g:s')\nax.set_title('Autos')\nax.set_xlabel('Days')\nax.set_ylabel('Total')\nax.set_xlim([0.5,5.5])\n#ylim(min(cars,trucks),max(cars,trucks))\n# Create a legend\n\n(0.5, 5.5)\n\nax.legend(['cars', 'trucks', 'suvs'], loc = 'best')\n# Save graphs in subfolder Graphs under name: fig1.pdf\n#plt.savefig('./Graphs/fig1.pdf')\nplt.show()\n\n\n\n\n\n\nFigure 8.5: Figure with Multiple Plots\n\n\n\n\n\n\n\nggplot(data, aes(x = xv)) +\n  geom_line(aes(y = carsv, color = \"cars\"), linetype = \"solid\", size = 1, shape = 18) +\n  geom_line(aes(y = trucksv, color = \"trucks\"), linetype = \"solid\", size = 1, shape = 17) +\n  geom_line(aes(y = suvsv, color = \"suvs\"), linetype = \"dotted\", size = 1, shape = 15) +\n  labs(title = \"Autos\", x = \"Days\", y = \"Total\") +\n  scale_color_manual(values = c(\"cars\" = \"blue\", \"trucks\" = \"red\", \"suvs\" = \"green\")) +\n  scale_shape_manual(values = c(\"cars\" = 18, \"trucks\" = 17, \"suvs\" = 15)) +\n  coord_cartesian(xlim = c(0.5, 5.5)) +\n  theme_gray() +\n  theme(legend.position = \"best\")\n\nWarning in geom_line(aes(y = carsv, color = \"cars\"), linetype = \"solid\", :\nIgnoring unknown parameters: `shape`\n\n\nWarning in geom_line(aes(y = trucksv, color = \"trucks\"), linetype = \"solid\", :\nIgnoring unknown parameters: `shape`\n\n\nWarning in geom_line(aes(y = suvsv, color = \"suvs\"), linetype = \"dotted\", :\nIgnoring unknown parameters: `shape`\n\n\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's shape values.\n\n\n\n\n\n\n\nFigure 8.6: Figure with Multiple Plots",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Plotting using `matplotlib`</span>"
    ]
  },
  {
    "objectID": "Plot.html#plotting-functions",
    "href": "Plot.html#plotting-functions",
    "title": "\n8  Plotting using matplotlib\n",
    "section": "\n8.2 Plotting Functions",
    "text": "8.2 Plotting Functions\n\n8.2.1 First Example\nIf we want to plot a more general function like the \\(y = \\sqrt{x}\\) we first need to define a grid of x values and then calculate the corresponding y-values for each grid point. This results in x and y coordinates for a number of points that we can then add to a coordinate system. After connecting these points in the graph, we get our function plot of the square root function.\nEach row represents the x and y coordinates of points that we now plot into the coordinate system. Let’s define the vectors first.\n\n\nPython Code\nR Code\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nxv = np.array([0, 1, 2, 3, 4])\nyv = np.zeros(len(xv))\n\n\nprint('--------------')\nprint('x      |    y  ')\nprint('--------------')\nfor i in range(len(xv)):\n    yv[i] = np.sqrt(xv[i])\n    print('{:5.2f}  | {:5.2f}'.format(xv[i],yv[i]))\n\nprint('--------------')\n\n--------------\nx      |    y  \n--------------\n 0.00  |  0.00\n 1.00  |  1.00\n 2.00  |  1.41\n 3.00  |  1.73\n 4.00  |  2.00\n--------------\n\n\n\n\n\nxv &lt;- c(0, 1, 2, 3, 4)\nyv &lt;- numeric(length(xv))\n\ncat('--------------\\n')\ncat('x      |    y  \\n')\ncat('--------------\\n')\n\nfor (i in 1:length(xv)) {\n  yv[i] &lt;- sqrt(xv[i])\n  cat(sprintf('%5.2f  | %5.2f\\n', xv[i], yv[i]))\n}\n\ncat('--------------\\n')\n\n--------------\nx      |    y  \n--------------\n 0.00  |  0.00\n 1.00  |  1.00\n 2.00  |  1.41\n 3.00  |  1.73\n 4.00  |  2.00\n--------------\n\n\n\n\n\nWe next plot these points into a coordinate system using the plot() function from the matplotlib.pyplot sub-library. Figure 8.7 shows the graph.\n\n\nPython Code\nR Code\n\n\n\n\nplt.plot(xv, yv, 'o')\nplt.show()\n\n\n\n\n\n\nFigure 8.7: Simple Plot\n\n\n\n\n\n\n\nplot(xv, yv, type = \"p\", pch = 1, lty = 0)\n\n\n\n\n\n\nFigure 8.8: Simple Plot\n\n\n\n\nIn the above plot the arguments are:\n\n\npch determines the marker shape according to:\n\n\nargument\nshape\n\n\n\npch = 0\nsquare\n\n\npch = 1\ncircle\n\n\npch = 2\ntriangle point up\n\n\npch = 3\nplus\n\n\npch = 4\ncross\n\n\npch = 5\ndiamond\n\n\npch = 6\ntriangle point down\n\n\npch = 7\nsquare cross\n\n\npch = 8\nstar\n\n\npch = 9\ndiamond plus\n\n\npch = 10\ncircle plus\n\n\npch = 11\ntriangles up and down\n\n\npch = 12\nsquare plus\n\n\npch = 13\ncircle cross\n\n\npch = 14\nsquare and triangle down\n\n\npch = 15\nfilled square\n\n\npch = 16\nfilled circle\n\n\npch = 17\nfilled triangle point-up\n\n\npch = 18\nfilled diamond\n\n\npch = 19\nsolid circle\n\n\npch = 20\nbullet (smaller circle)\n\n\npch = 21\nfilled circle blue\n\n\npch = 22\nfilled square blue\n\n\npch = 23\nfilled diamond blue\n\n\npch = 24\nfilled triangle point-up blue\n\n\npch = 25\nfilled triangle point down blue\n\n\n\n\n\ntype character indicating the type of plotting. Allowed values are:\n\n\nsymbol\nexplanation\n\n\n\n“p”\npoints\n\n\n“l”\nlines\n\n\n“b”\nboth points and lines\n\n\n“c”\nempty points joined by lines\n\n\n“o”\noverplotted points and lines\n\n\n“s”\nstair steps\n\n\n“n”\ndoes not produce any points or lines\n\n\n\n\n\nlty line types can either be specified as an integer:\n\n0=blank\n1=solid (default)\n2=dashed\n3=dotted\n4=dotdash\n5=longdash\n6=twodash, or as one of the character strings\n“blank”\n“solid”\n“dashed”\n“dotted”\n“dotdash”\n“longdash”, or\n“twodash”,\n\n\n\nwhere “blank” uses ‘invisible lines’ (i.e., does not draw them).\n\n\n\nIf you would like to connect the dots, you can change the code to:\n\n\nPython Code\nR Code\n\n\n\n\nplt.plot(xv, yv, '-o')\nplt.show()\n\n\n\n\n\n\nFigure 8.9: Simple Plot with Connected Dots\n\n\n\n\n\n\n\nplot(xv, yv, type = \"b\", pch = 19, lty =1)\n\n\n\n\n\n\nFigure 8.10: Simple Plot with Connected Dots\n\n\n\n\n\n\n\nThis graph looks still a bit choppy. If you would like a smoother graph you need to evaluate the function using more points. We can also generate the x-grid automatically using the linspace function from the numpy library. We then calculate the corresponding y values with :math:` y = sqrt(x)` for each one of the x grid-points and record them in a yv vector.\n\n\nPython Code\nR Code\n\n\n\n\nxv = np.linspace(0, 4, 30) # Generates 30 points between 0 and 4\nyv = np.zeros(len(xv))\n\nfor i in range(len(xv)):\n    yv[i] = np.sqrt(xv[i])\n\n\nplt.plot(xv, yv, '-o')\nplt.show()\n\n\n\n\n\n\n\nFinally we use a very powerful feature that all functions of the numpy library have in common. It is called vector evaluation. This means that any function in the numpy library can be applied on a vector without a loop which results in a new vector containing the results of the function evaluations on each point in the original vector. Sounds complicated but is really easy. And just to make the function even smoother we add some more points and plot it in the color red, look:\n\nxv = np.linspace(0, 4, 50) # Generates 30 points between 0 and 4\nyv = np.sqrt(xv)  # Vector evaluation, sqrt() is applied to each point in xv\n\nplt.plot(xv, yv, 'r-o')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nxv &lt;- seq(0, 4, length.out = 30)  # Generates 30 points between 0 and 4\nyv &lt;- sqrt(xv)\n\nplot(xv, yv, type = 'l', pch = 'o')\n\n\n\n\n\n\n\n\n\n\n\n8.2.2 Second Example Using subplots()\n\nHere is another example of a simple function, the \\(y = sin(x)\\) function. When we plot this function we use a more powerful plotting function called subplots(). This will allow us to plot multiple graphs into a single figure. I now also add labels to the graph and a legend. We also use the sin() function from the numpy library which allows us to use vector evaluation again so that we do not have to write a loop to evaluate the x-grid values.\n\n\n\n\n\n\nNote\n\n\n\nYou should always have a title and labels in your figures!\n\n\n\n\nPython Code\nR Code\n\n\n\n\nxv = np.linspace(0, 10, 200)\nyv = np.sin(xv)\n\nfig, ax = plt.subplots()\nax.plot(xv, yv, 'r-', linewidth=2, label='sine function', alpha=0.6)\nax.set_title('Plotting the sin() function')\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.legend(loc='best')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nlibrary(ggplot2)\n\nxv &lt;- seq(0, 10, length.out = 200)\nyv &lt;- sin(xv)\n\ndata &lt;- data.frame(x = xv, y = yv)\n\nggplot(data, aes(x = x, y = y)) +\n  geom_line(color = \"red\", linetype = \"solid\", alpha = 0.6) +\n  labs(title = \"Plotting the sin() function\", x = \"x\", y = \"y\") +\n  theme_minimal() +\n  theme(legend.position = \"best\")\n\n\n\n\n\n\n\n\n\n\n\n8.2.3 Plotting Multiple Functions into a Graph\nHere is another example with some more functions. We again first define the input vector xv with the values we want to evaluate the function at and then specify the “output” vector yv as \\(y = f(x)\\). We use the following examples:\n\n\n\n\\(f(x) = 50 \\times sin(x)\\),\n\n\\(f(x) = x^2\\),\n\n\\(f(x) = 3 \\times (x^2)/2 - 5\\), and finally\n\n\\(f(x) = 5 \\times (x^2)/2 - \\sqrt{x}\\).\n\n\n\n\nPython Code\nR Code\n\n\n\n\nxv = np.arange(1, 10, 0.1)\ny1v = 50*np.sin(xv)\ny2v = xv**2\ny3v = 3.0*(xv**2)/2 - 5\ny4v = 5.0*(xv**2)/2 - np.sqrt(xv)\n\n\n\n\nxv &lt;- seq(1, 10, by = 0.1)\ny1v &lt;- 50 * sin(xv)\ny2v &lt;- xv^2\ny3v &lt;- 3.0 * (xv^2) / 2 - 5\ny4v &lt;- 5.0 * (xv^2) / 2 - sqrt(xv)\n\ndata &lt;- data.frame(x = xv, y1 = y1v, y2 = y2v, y3 = y3v, y4 = y4v)\n\n\n\n\nWe have now two columns of values: x and y that we can plot against each other into a coordinate system.\n\n\nPython Code\nR Code\n\n\n\n\nfig, ax = plt.subplots()\nax.plot(xv, y1v, \\\n        xv, y2v, \\\n        xv, y3v, \\\n        xv, y4v)\nax.legend(['sin(x)', r'$x^2$', 'y3', 'y4'], loc = 'best')\nax.set_title('Many Functions')\nax.set_xlabel('x')\nax.set_ylabel('y')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nlibrary(ggplot2)\nggplot(data) +\n  geom_line(aes(x = x, y = y1), color = \"blue\", linetype = \"solid\", size = 1, alpha = 0.6) +\n  geom_line(aes(x = x, y = y2), color = \"green\", linetype = \"dashed\", size = 1, alpha = 0.6) +\n  geom_line(aes(x = x, y = y3), color = \"red\", linetype = \"dotted\", size = 1, alpha = 0.6) +\n  geom_line(aes(x = x, y = y4), color = \"purple\", linetype = \"dotdash\", size = 1, alpha = 0.6) +\n  labs(title = \"Multiple Curves\", x = \"x\", y = \"y\") +\n  theme_minimal() +\n  theme(legend.position = \"top\")",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Plotting using `matplotlib`</span>"
    ]
  },
  {
    "objectID": "Plot.html#subplots",
    "href": "Plot.html#subplots",
    "title": "\n8  Plotting using matplotlib\n",
    "section": "\n8.3 Subplots",
    "text": "8.3 Subplots\nIf we have more than one figure it might be good to put them all into one graph. In the following example we plot 6 figures into one picture. We plot into 3 rows and 2 columns. You can obviously rearrange all this.\n\n\nPython Code\nR Code\n\n\n\n\n# Creates  a 3 x 2 grid of subplots\nnum_rows = 3\nnum_cols = 2\ntitle_size = 26\n\nfig = plt.figure(figsize=(8, 10))\nfig.suptitle(\"Figure with multiple subplots\", \\\n    fontsize=title_size, fontweight='bold')\nplt.subplots_adjust(wspace=0.2, hspace=0.3)\n\n# [1]\nax = plt.subplot2grid((num_rows, num_cols), (0,0))\nax.plot([1,2,3])\nax.set_title('figure 1')\nax.set_xlabel('x')\nax.set_ylabel('y')\n# [2]\nax = plt.subplot2grid((num_rows, num_cols), (0,1))\nax.plot(np.random.rand(12), np.random.rand(12), 'bo')\nax.set_title('figure 2')\nax.set_xlabel('x')\nax.set_ylabel('y')\n# [3]\nax = plt.subplot2grid((num_rows, num_cols), (1,0))\nax.plot(np.array([1,2,3]), np.array([1,1,1]))\nax.set_title('figure 3')\nax.set_xlabel('x')\nax.set_ylabel('y')\n# [4]\nax = plt.subplot2grid((num_rows, num_cols), (1,1))\nax.plot(np.linspace(1,12,12), np.random.rand(12), 'r^')\nax.set_title('figure 4')\nax.set_xlabel('x')\nax.set_ylabel('y')\n# [5]\nax = plt.subplot2grid((num_rows, num_cols), (2,0))\nax.plot([1,2,1],':')\nax.set_title('figure 5')\nax.set_xlabel('x')\nax.set_ylabel('y')\n# [6]\nax = plt.subplot2grid((num_rows, num_cols), (2,1))\nax.plot(np.linspace(1,12,12), np.random.rand(12), 'k-x')\nax.set_title('figure 6')\nax.set_xlabel('x')\nax.set_ylabel('y')\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\nlibrary(ggplot2)\nlibrary(gridExtra)\n\n# Create plots for each subplot\nplot1 &lt;- ggplot() +\n  geom_line(data = data.frame(x = c(1, 2, 3), y = c(1, 2, 3)), aes(x = x, y = y)) +\n  labs(title = \"figure 1\", x = \"x\", y = \"y\")\n\nplot2 &lt;- ggplot() +\n  geom_point(data = data.frame(x = runif(12), y = runif(12)), aes(x = x, y = y), color = \"blue\") +\n  labs(title = \"figure 2\", x = \"x\", y = \"y\")\n\nplot3 &lt;- ggplot() +\n  geom_line(data = data.frame(x = c(1, 2, 3), y = c(1, 1, 1)), aes(x = x, y = y)) +\n  labs(title = \"figure 3\", x = \"x\", y = \"y\")\n\nplot4 &lt;- ggplot() +\n  geom_point(data = data.frame(x = seq(1, 12, length.out = 12), y = runif(12)), aes(x = x, y = y), color = \"red\", shape = 3) +\n  labs(title = \"figure 4\", x = \"x\", y = \"y\")\n\nplot5 &lt;- ggplot() +\n  geom_line(data = data.frame(x = c(1, 2, 1), y = c(1, 1, 1)), aes(x = x, y = y), linetype = \"dotted\") +\n  labs(title = \"figure 5\", x = \"x\", y = \"y\")\n\nplot6 &lt;- ggplot() +\n  geom_line(data = data.frame(x = seq(1, 12, length.out = 12), y = runif(12)), aes(x = x, y = y), color = \"black\", linetype = \"dashed\") +\n  labs(title = \"figure 6\", x = \"x\", y = \"y\")\n\n# Combine plots into a 3x2 grid\ngrid.arrange(plot1, plot2, plot3, plot4, plot5, plot6, ncol = 2)",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Plotting using `matplotlib`</span>"
    ]
  },
  {
    "objectID": "Plot.html#d-graphs",
    "href": "Plot.html#d-graphs",
    "title": "\n8  Plotting using matplotlib\n",
    "section": "\n8.4 3D-Graphs",
    "text": "8.4 3D-Graphs\nFinally, we can also plot 3-D graphs in Python. The function we would like to plot is\n\\[f(x,y) = 3.0 \\frac{y^2}{2.0} + x - \\frac{\\sqrt{x \\times y}}{5.0}.\\]\nWe start by defining an x-grid and a y-grid vector. We then evaluate the function at these values.\n\n\nPython Code\nR Code\n\n\n\n\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\nimport numpy as np\n\nplt.style.use('_mpl-gallery')\n\n# Define x and y grid vectors\nxv = np.arange(1, 10, 1)\nyv = np.arange(1, 10, 1)\nn = len(xv)\n\n# Evaluation function at grid values\nzv = 3 * yv**2 /2 + xv - np.sqrt(xv*yv) /5\n\nax = plt.figure(figsize=(6, 7)).add_subplot(projection='3d')\nax.plot(xv, yv, zv, zdir='z', label='parametric curve')\nax.set_title('Function in 2 variables')\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.set_zlabel('f(x,y)')\nax.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\nlibrary(rgl)\n\n# Define x and y grid vectors\nxv &lt;- seq(1, 10, by = 1)\nyv &lt;- seq(1, 10, by = 1)\nn &lt;- length(xv)\n\n# Evaluation function at grid values\nzv &lt;- 3 * yv^2 / 2 + xv - sqrt(xv * yv) / 5\n\n# Create a 3D scatter plot\nplot3d(x = xv, y = yv, z = zv, type = \"l\", col = \"blue\",\n       xlab = \"x\", ylab = \"y\", zlab = \"f(x, y)\",\n       main = \"Function in 2 variables\")\n\nrglwidget()\n\n3D plot\n\n\n\n\n\n\n\nThe problem with this approach is that the function gets only evaluated at the 45-degree line, that is at points (x=1, y=1), (x=2, y=2), …, (x=10, y=10). This is not really what we had in mind.",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Plotting using `matplotlib`</span>"
    ]
  },
  {
    "objectID": "Plot.html#d-utility-function-graphs",
    "href": "Plot.html#d-utility-function-graphs",
    "title": "\n8  Plotting using matplotlib\n",
    "section": "\n8.6 3D-Utility Function Graphs",
    "text": "8.6 3D-Utility Function Graphs\nWe first start with some definitions of the consumption and leisure grid. We then evaluate the utility at all the consumption-leisure combination points.\n\n\nPython Code\nR Code\n\n\n\n\ntitleSize = 22\nlegendSize = 16\nlabelSize = 18\ntickSize = 16\n\n# Define grids in x and y dimension\nlv = np.linspace(0.0, 1.05, 20)\ncv = np.linspace(0.0, 1.05, 20)\n\n# Span meshgrid over entire x/y plane\nL,C = np.meshgrid(lv, cv)\n\n# Evaluate function at each point in the x/y plane\nU = np.sqrt(L) + np.sqrt(C)\n\n\n\n\n# Define grids in x and y dimension\nlv &lt;- seq(0.0, 1.05, length.out = 20)\ncv &lt;- seq(0.0, 1.05, length.out = 20)\n\n\n# Evaluate function at each point in the x/y plane\n\nU_values &lt;- function(L,C) {\n    sqrt(L) + sqrt(C)\n    }\n\n# Span grid\nU = outer(lv, cv, U_values)\n\n\n\n\nWe can now plot the utility function. We plot it first as Wire-Frame graph.\n\n\nPython Code\nR Code\n\n\n\n\n# Plot the result\nax = plt.figure(figsize=(6, 7)).add_subplot(projection='3d')\nax.plot_wireframe(L,C, U, rstride=1, cstride=1)\nax.set_title(r'Utility Function: $U(c,\\ell)=\\sqrt{c}+\\sqrt{\\ell}$', fontsize=titleSize)\nax.set_xlabel('$\\ell$', fontsize=labelSize)\nax.set_ylabel('c', fontsize=labelSize)\nax.set_zlabel('$U(c,\\ell)$', fontsize=labelSize)\nax.set_xlim([0,1])\nax.set_ylim([0,1])\nax.view_init(elev=25., azim=225)\nplt.show()\n\n(0.0, 1.0)\n(0.0, 1.0)\n\n\n\n\n\n\n\n\n\n\n\n# Create a wireframe plot\npersp(lv, cv, U,  # Pass l, c, U as vectors and matrix\n       xlab = \"l\", ylab = \"c\", zlab = \"u(l, c)\",\n       main = \"Utility of leisure and consumption\")\n\n\n\n\n\n\n\n\n\n\nWe can also fill in the graph a bit more using the plot_surface command.\n\n\nPython Code\nR Code\n\n\n\n\n# Plot the result\nax = plt.figure(figsize=(6, 7)).add_subplot(projection='3d')\nax.plot_surface(L,C, U, rstride=1, cstride=1, cmap = plt.cm.jet, \\\n                linewidth=0, antialiased=False)\nax.set_title(r'Utility Function: $U(c,\\ell)=\\sqrt{c}+\\sqrt{\\ell}$', fontsize=titleSize)\nax.set_xlabel('$\\ell$', fontsize=labelSize)\nax.set_ylabel('c', fontsize=labelSize)\nax.set_zlabel('$U(c,\\ell)$', fontsize=labelSize)\nax.set_xlim([0,1])\nax.set_ylim([0,1])\nax.view_init(elev=25., azim=225)\nplt.show()\n\n(0.0, 1.0)\n(0.0, 1.0)\n\n\n\n\n\n\n\n\n\n\n\n# Create a wireframe plot\npersp(lv, cv, U,  # Pass l, c, U as vectors and matrix\n       xlab = \"l\", ylab = \"c\", zlab = \"u(l, c)\",\n       main = \"Utility of leisure and consumption\",\n       col='pink', shade=.4, theta = 30, phi = 15, ticktype='detailed')",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Plotting using `matplotlib`</span>"
    ]
  },
  {
    "objectID": "Functions.html",
    "href": "Functions.html",
    "title": "\n9  Functions\n",
    "section": "",
    "text": "9.1 Function Basics\nIt takes a number of inputs---inputs can be scalars, lists, tuples or objects---and produces a number of outputs---outputs can be scalars, lists, tuples or objects.\ninput1\ninput1function\nfunctioninput1-&gt;function\noutput1\noutput1function-&gt;output1\noutput2\noutput2function-&gt;output2\noutput...\noutput...function-&gt;output...\ninput2\ninput2input2-&gt;function\ninput ...\ninput ...input ...-&gt;function\nIn Python we use the keyword def to start the function definition code block:\ninput1 and input2 are the input arguments. They can be scalars, lists, tuples, objects and even other functions. Variables obj1 and obj2 are output objects that can again be scalars, lists, objects or functions.\nThe codeblock defined as function can then be called by its name assigned to the output arguments:",
    "crumbs": [
      "**ADVANCED TECHNIQUES**",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "Functions.html#a-simple-demonstration-example",
    "href": "Functions.html#a-simple-demonstration-example",
    "title": "\n9  Functions\n",
    "section": "\n9.2 A Simple Demonstration Example",
    "text": "9.2 A Simple Demonstration Example\nLet's start with a simple example to demonstrate how powerful functional programming can be. The task is to plot the composite function\n\\[\\begin{aligned}\nf(x) =\n\\begin{cases}\n    x^2 & x &lt; 1 \\\\\n    x - 2 & 1 \\leq x &lt; 4 \\\\\n    \\sqrt{x} & 4 \\leq x\n\\end{cases}\n\\end{aligned}\\]\nfor two separate domains: \\(x\\in[-2, 6]\\) and \\(x\\in[1, 10]\\).\nWhen plotting a function we typically want to build a table with \\(x\\) values and the corresponding function values \\(y = f(x)\\).\n\n\n\n\\(x\\) values\nFunction Values: \\(y=f(x)\\)\n\n\n\n\n\\(x_0=0\\)\n\\(y_0 = f(0)\\)\n\n\n\\(x_1=0.5\\)\n\\(y_1 = f(0.5)\\)\n\n\n\\(x_2=1\\)\n\\(y_2 = f(1)\\)\n\n\n\\(x_3=1.5\\)\n\\(y_3 = f(1.5)\\)\n\n\netc.\netc.\n\n\n\nEach row in this table describes a point in a \\(x-y\\) coordinate system. In order to plot the function we collect all the \\(x\\) values in a vector xv and all the functional values in a vector yv. We then call the plot command plt.plot(xv, yv) to generate the figure.\nThe problem is now that we have to do this 2 times as you can see in the following script. Where I have indicated the code block that gets repeated.\n\n\nPython Code\nR Code\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport math as m\nimport seaborn as sns\n# Apply the default theme\nsns.set_theme()\n\n# Creates  a 1 x 2 grid of subplots\nnum_rows = 1\nnum_cols = 2\ntitle_size = 22\n\n# Define empty canvas object\nfig = plt.figure(figsize=(7, 7))\nfig.suptitle(\"Function Plot with Multiple Domains\", \\\n    fontsize=title_size, fontweight='bold')\nplt.subplots_adjust(wspace=0.2, hspace=0.3)\n\n# Domain [-2, 6]\n# ---------------------------------------\n# Repeat Code Block\n# ---------------------------------------\nxv = np.linspace(-2, 6, 100)\nyv = np.zeros(len(xv))\n\nfor i in range(len(yv)):\n    x = xv[i]  # current gridpoint\n    if x &lt; 1:\n        y = x**2\n    elif 1 &lt;= x &lt; 4:\n        y = x -2\n    else:\n        y = m.sqrt(x)\n    # Now we store the functional value in\n    # the yv vector at current position i\n    yv[i] = y\n# ---------------------------------------\n\n# [1] We then plot the first figure.\nax = plt.subplot2grid((num_rows, num_cols), (0,0))\nax.plot(xv, yv)\nax.set_title('Domain: [-2, 6]')\n\n# Domain [1, 10]\n# ---------------------------------------\n# Repeat Code Block\n# ---------------------------------------\nxv = np.linspace(1, 10, 100)\nyv = np.zeros(len(xv))\n\nfor i in range(len(yv)):\n    x = xv[i]  # current gridpoint\n    if x &lt; 1:\n        y = x**2\n    elif 1 &lt;= x &lt; 4:\n        y = x -2\n    else:\n        y = m.sqrt(x)\n    # Now we store the functional value in\n    # the yv vector at current position i\n    yv[i] = y\n# ---------------------------------------\n\n# [2] We then plot the second figure.\nax = plt.subplot2grid((num_rows, num_cols), (0,1))\nax.plot(xv, yv)\nax.set_title('Domain: [1, 10]')\n#\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# Load required libraries\nlibrary(ggplot2)\nlibrary(gridExtra)\n\n# Create a function to generate the plots\ngenerate_plot &lt;- function(x_range, y_range, title) {\n  df &lt;- data.frame(x = x_range, y = y_range)\n\n  p &lt;- ggplot(df, aes(x, y)) +\n    geom_line() +\n    labs(title = title) +\n    theme_minimal()\n\n  return(p)\n}\n\n# Define the x ranges for the two domains\nx_range1 &lt;- seq(-2, 6, length.out = 100)\nx_range2 &lt;- seq(1, 10, length.out = 100)\n\n# Define the y ranges for the two domains\ny_range1 &lt;- rep(0, length(x_range1))\ny_range2 &lt;- rep(0, length(x_range2))\n\nfor (i in 1:length(x_range1)) {\n  x &lt;- x_range1[i]\n  if (x &lt; 1) {\n    y_range1[i] &lt;- x^2\n  } else if (1 &lt;= x && x &lt; 4) {\n    y_range1[i] &lt;- x - 2\n  } else {\n    y_range1[i] &lt;- sqrt(x)\n  }\n}\n\nfor (i in 1:length(x_range2)) {\n  x &lt;- x_range2[i]\n  if (x &lt; 1) {\n    y_range2[i] &lt;- x^2\n  } else if (1 &lt;= x && x &lt; 4) {\n    y_range2[i] &lt;- x - 2\n  } else {\n    y_range2[i] &lt;- sqrt(x)\n  }\n}\n\n# Generate the plots\nplot1 &lt;- generate_plot(x_range1, y_range1, \"Domain: [-2, 6]\")\nplot2 &lt;- generate_plot(x_range2, y_range2, \"Domain: [1, 10]\")\n\n# Arrange the plots side by side\ngrid.arrange(plot1, plot2, ncol = 2)\n\n\n\n\n\n\n\n\n\n\nThere is a better way to program this using functions. The strategy is to code the repeated code block only once and assign a name to it. Then, whenever the code block needs to be executed it can simply be called by its name. This will make the script shorter and it will also be easier to maintain.\nWe use the def keyword to define the function. We will call our function myFunc. The function needs to be on top of your script so that the code block will be named before you call it by its name.\n\n\nPython Code\nR Code\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport math as m\n\ndef myFunc(low, high):\n    # The function needs two inputs, the lower and\n    # upper bound of the function domain!\n    # -------------------------------------------\n    # Repeat Code Block is now only defined once!\n    # -------------------------------------------\n    xv = np.linspace(low, high, 100)\n    yv = np.zeros(len(xv))\n\n    for i in range(len(yv)):\n        x = xv[i]  # current gridpoint\n        if x &lt; 1:\n            y = x**2\n        elif 1 &lt;= x &lt; 4:\n            y = x -2\n        else:\n            y = m.sqrt(x)\n        # Now we store the functional value in\n        # the yv vector at current position i\n        yv[i] = y\n    # -------------------------------------------\n    # In the return statement we declare the output of the function.\n    # In this example the output is composed of 2 vectors: xv and yv.\n    # When you call this function, make sure you call it with two\n    # vectors as output such as: vec1, vec2 = myFunc(low, high)\n    # The results will then be stored in the two\n    # vectors vec1 anc vec2\n    return xv, yv\n\n# Creates  a 1 x 2 grid of subplots\nnum_rows = 1\nnum_cols = 2\ntitle_size = 26\n\n# Define empty canvas object\nfig = plt.figure(figsize=(7, 8))\nfig.suptitle(\"Function Plot with Multiple Domains\", \\\n    fontsize=title_size, fontweight='bold')\nplt.subplots_adjust(wspace=0.2, hspace=0.3)\n\n# Domain [-2, 6]\nx1v, y1v = myFunc(-2, 6)\n# Domain [1, 10]\nx2v, y2v = myFunc(1, 10)\n\n# [1] We then plot the first figure.\nax = plt.subplot2grid((num_rows, num_cols), (0,0))\nax.plot(x1v, y1v)\nax.set_title('Domain: [-2, 6]')\n# [2] We then plot the second figure.\nax = plt.subplot2grid((num_rows, num_cols), (0,1))\nax.plot(x2v, y2v)\nax.set_title('Domain: [1, 10]')\n#\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# Load required libraries\nlibrary(ggplot2)\nlibrary(gridExtra)\n\n# Create a function that generates the y values for a given x range\nmyFunc &lt;- function(x_range) {\n  y_range &lt;- numeric(length(x_range))\n\n  for (i in 1:length(y_range)) {\n    x &lt;- x_range[i]\n    if (x &lt; 1) {\n      y_range[i] &lt;- x^2\n    } else if (1 &lt;= x && x &lt; 4) {\n      y_range[i] &lt;- x - 2\n    } else {\n      y_range[i] &lt;- sqrt(x)\n    }\n  }\n\n  return(y_range)\n}\n\n# Define the x ranges for the two domains\nx_range1 &lt;- seq(-2, 6, length.out = 100)\nx_range2 &lt;- seq(1, 10, length.out = 100)\n\n# Generate the y values for the two domains using the myFunc function\ny_range1 &lt;- myFunc(x_range1)\ny_range2 &lt;- myFunc(x_range2)\n\n# Create a function to generate the plots\ngenerate_plot &lt;- function(x_range, y_range, title) {\n  df &lt;- data.frame(x = x_range, y = y_range)\n\n  p &lt;- ggplot(df, aes(x, y)) +\n    geom_line() +\n    labs(title = title) +\n    theme_minimal()\n\n  return(p)\n}\n\n# Generate the plots\nplot1 &lt;- generate_plot(x_range1, y_range1, \"Domain: [-2, 6]\")\nplot2 &lt;- generate_plot(x_range2, y_range2, \"Domain: [1, 10]\")\n\n# Arrange the plots side by side\ngrid.arrange(plot1, plot2, ncol = 2)\n\n\n\n\n\n\n\n\n\n\nAs you can see this second script is much shorter than the first. It is also easier to maintain and fix. If you have to add more domain plots you simply call the function more times which is just one extra line of code as opposed to copying the entire code block again as in the first version of the script.\nSecond, if you find that your function definition contains a mistake, you only have to fix it once in the function definition and all the subsequent function calls and corresponding plots will automatically be updated to the latest and correct version. In the first version of the code you would have to make changes twice which is more work and more error prone.",
    "crumbs": [
      "**ADVANCED TECHNIQUES**",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "Functions.html#simple-user-defined-function-in-separate-file",
    "href": "Functions.html#simple-user-defined-function-in-separate-file",
    "title": "\n9  Functions\n",
    "section": "\n9.3 Simple User Defined Function in Separate File",
    "text": "9.3 Simple User Defined Function in Separate File\nIn Python we can write the following to define a simple function. We start with two simple function definitions and save them in a file called myFunctions.py\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport math as m\nfrom scipy import stats as st\n# Imports system time module to time your script\nimport time\n# Needed for re-loading user defined function-modules\nimport importlib\n\nplt.close('all')  # close all open figures\n\nWe next define our own functions and save them as myFunctions.py\n\n\nPython Code\nR Code\n\n\n\n\n# File 1: myFunctions.py\ndef hw1(r1, r2):\n    s = m.sin(r1 + r2)\n    return s\n\ndef hw2(r1, r2):\n    s = m.sin(r1 + r2)\n    print(\"Hello, World! sin({0:4.2f}+{1:4.2f}) = {2:4.2f}\".format(r1, r2, s))\n\n\n\n\n# Define a function hw1 that calculates sin(r1 + r2)\nhw1 &lt;- function(r1, r2) {\n  s &lt;- sin(r1 + r2)\n  return(s)\n}\n\n# Define a function hw2 that calculates sin(r1 + r2) and prints a message\nhw2 &lt;- function(r1, r2) {\n  s &lt;- sin(r1 + r2)\n  cat(sprintf(\"Hello, World! sin(%g+%g)=%g\\n\", r1, r2, s))\n}\n\n\n\n\nWe save this new Python script as Lecture_Functions/myFunctions.py\nIn a separate Python script we can now import this previous file (or function library) containing our functions with the import command. You can then use the functions that are defined within your library using the “dot” notation similar to when you imported, say, the numpy library and then used functions that are defined within the numpy library using np.sqrt() etc.\n\n\nPython Code\nR Code\n\n\n\n\n# NOTE: If the myFunctions.py is stored in the same location than the script\n# file you are currently running, then you do not need these complicated import\n# statements on the next two lines.\n\n# File 2 stored in: Lecture_Functions/myFunctions.py\nimport sys\nsys.path.insert(0, '/home/jjung/Dropbox/Towson/Teaching/3_ComputationalEconomics/QuartoTextbook/Lecture_Functions/')\n\n# Skip the above and start here if your function file is stored in the same\n# location as your script file.\n\nimport myFunctions as mfunc\n# This next line makes sure that if you\n# edited the file myfunctions.py -&gt; the\n# import is updated!\nimportlib.reload(mfunc)\n\n# Now we call these functions with function arguments\nprint(mfunc.hw1(2.6, 4.0))\nmfunc.hw2(2.5,5.6)\n\n&lt;module 'myFunctions' from '/home/jjung/Dropbox/Towson/Teaching/3_ComputationalEconomics/QuartoTextbook/Lecture_Functions/myFunctions.py'&gt;\n0.31154136351337786\nHello, World! sin(2.5+5.6)=0.96989\n\n\n\n\n\n# Load the myFunctions.R script (assuming it's stored in the same directory)\n#source(\"myFunctions.R\")\nsource(\"/home/jjung/Dropbox/Towson/Teaching/3_ComputationalEconomics/QuartoTextbook/Lecture_Functions/myFunctions.R\")\n\n# Now we can call the functions from myFunctions.R\nresult1 &lt;- hw1(2.6, 4.0)\ncat(\"Result 1:\", result1, \"\\n\")\n\nhw2(2.5, 5.6)\n\nResult 1: 0.3115414 \nHello, World! sin(2.5+5.6)=0.96989",
    "crumbs": [
      "**ADVANCED TECHNIQUES**",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "Functions.html#advanced-graphing-using-loops-and-functions",
    "href": "Functions.html#advanced-graphing-using-loops-and-functions",
    "title": "\n9  Functions\n",
    "section": "\n9.4 Advanced Graphing using Loops and Functions",
    "text": "9.4 Advanced Graphing using Loops and Functions\n\n9.4.1 Graphing Functions with two Input Arguments z = f(x,y)\nWe next want to plot a function with two input variables:\n\\[f(x,y) = sin(x \\times y).\\]\nWe first define an input grid for values of \\(x\\) and store the grid in vector xv, followed by an input grid for values of \\(y\\) which is stored in vector yv.\n\n\nPython Code\nR Code\n\n\n\n\nxv = np.linspace(1, 5, 10)\nyv = np.arange(1, 5, 10)\n\n# Meshgrid spans a grid-field over the 2 dimensions\nX, Y = np.meshgrid(xv, xv)\n\n# X and Y are both matrices now\nxn, yn = X.shape\n\n# We next need to evaluate the function\n# repeatedly over the entire grid-field\n\n# Define matrix size n x n with zero entries\nf = np.zeros((xn, yn),float)\nfor i in range(xn):\n    for j in range(yn):\n        #print(i,j)\n        # Here you want to use matrix X\n        # and not the gridvector xv\n        f[i,j] = np.sin(X[i,j]*Y[i,j])\n\n\n\n\n# Define the vectors for xv and yv\nxv &lt;- seq(1, 5, length.out = 10)\nyv &lt;- seq(1, 5, length.out = 10)\n\n# Create a meshgrid using expand.grid\nmeshgrid &lt;- expand.grid(x = xv, y = yv)\n\n# Extract the dimensions of the grid\nxn &lt;- length(xv)\nyn &lt;- length(yv)\n\n# Initialize an empty matrix for f\nf &lt;- matrix(0, nrow = xn, ncol = yn)\n\n# Loop through the grid and evaluate the function\nfor (i in 1:xn) {\n  for (j in 1:yn) {\n    x &lt;- meshgrid[i, \"x\"]\n    y &lt;- meshgrid[j, \"y\"]\n    f[i, j] &lt;- sin(x * y)\n  }\n}\n\n\n\n\nWe use two methods to plot the 3-D function, a wireframe graph and a surface graph.\n\n\nPython Code\nR Code\n\n\n\n\n# Set up a figure twice as tall as it is wide\nfig = plt.figure(figsize=(8, 12))\nfig.suptitle('Two Subplots')\n\nax = fig.add_subplot(2,1,1, projection='3d')\nax.plot_wireframe(X, Y, f, rstride=1, cstride=1)\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.set_zlabel('f(x,y)')\nax.set_title(r'$sin(x \\times y)$')\n\nax = fig.add_subplot(2,1,2, projection='3d')\nax.plot_surface(X, Y, f, rstride=1, cstride=1, cmap = plt.cm.jet, \\\n                linewidth=0, antialiased=False)\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.set_zlabel('f(x,y)')\nax.set_title(r'$sin(x \\times y)$')\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\nlibrary('latex2exp')\n\n# Define the vectors for xv and yv\nxv &lt;- seq(1, 5, length.out = 10)\nyv &lt;- seq(1, 5, length.out = 10)\n\n# Extract the dimensions of the grid\nxn &lt;- length(xv)\nyn &lt;- length(yv)\n\n# Initialize an empty matrix for f\nf &lt;- matrix(0, nrow = xn, ncol = yn)\n\n# Loop through the grid and evaluate the function\nfor (i in 1:xn) {\n    for (j in 1:yn) {\n        x &lt;- xv[i]\n        y &lt;- yv[j]\n        f[i, j] &lt;- sin(x * y)\n    }\n}\n\n# Create a new plotting window and set the plotting area into a 1*2 array\npar(mfrow = c(1, 2))\n\n# Create a wireframe plot\npersp(xv, yv, f,  # Pass X, Y, Z as matrices directly\n        xlab = \"x\", ylab = \"y\", zlab = \"f(x, y)\",\n        main = TeX(\"$sin(x \\\\times y)$\"))\n\n# Create a wireframe plot\npersp(xv, yv, f,  # Pass X, Y, Z as matrices directly\n      xlab = \"x\", ylab = \"y\", zlab = \"f(x, y)\",\n      main = TeX(\"$sin(x \\\\times y)$\"),\n      col='pink', shade=.4, theta = 30, phi = 15, ticktype='detailed')\n\n\n\n\n\n\n\n\n\n\n\n9.4.2 Same Thing but Different Function\nThis time we define the function first using the def command:\n\\[g = f(x, y)=(1 + y * 2) ^ {(-x / y)} * (1 + y * 1) ^ {(x / y)}\\]\nWe then span a grid over x and y and evaluate the function g at each combination of (x,y) using the expand.grid command.\nThe grid space between (x,y) is created using the meshgrid command. The function g is then evaluated at every point (x,y) over the grid. The ax.plot_wireframe command produces the picture.\n\n\nPython Code\nR Code\n\n\n\n\n# Define function\ndef g(x, y):\n    res = (1 + y * 2) ** (-x / y) * (1 + y * 1) ** (x / y)\n    return res\n\nxv = np.linspace(0.01, 1, 20)\nyv = np.linspace(0.01, 1, 20)\nX, Y = np.meshgrid(xv, yv)\n\nxn, yn = X.shape\n\nf = np.zeros((xn,xn),float)   # Define matrix size nxn with zero entries\nfor i in range(xn):\n    for j in range(yn):\n        f[i,j] = g(X[i,j], Y[i,j])\n\n\n\n\n# Define the function g(x, y)\ng &lt;- function(x, y) {\n  res &lt;- (1 + y * 2) ^ (-x / y) * (1 + y * 1) ^ (x / y)\n  return(res)\n}\n\n# Define the x and y vectors\nxv &lt;- seq(0.01, 1, length.out = 20)\nyv &lt;- seq(0.01, 1, length.out = 20)\n\n# Get the dimensions\nxn &lt;- length(xv)\nyn &lt;- length(yv)\n\n# Initialize the matrix f with zeros\nf &lt;- matrix(0, nrow = xn, ncol = yn)\n\n# Fill the matrix f with values computed from the function g\nfor (i in 1:xn) {\n  for (j in 1:yn) {\n    f[i, j] &lt;- g(xv[i], yv[j])\n  }\n}\n\n\n\n\nWe next plot the results again.\n\n\nPython Code\nR Code\n\n\n\n\nax = plt.figure(figsize=(6, 7)).add_subplot(projection='3d')\nax.plot_wireframe(X, Y, f, rstride=2, cstride=2)\nax.set_title('g(x,y)')\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.set_zlabel('f(x,y)')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# Create a wireframe plot\npersp(xv, yv, f,  # Pass X, Y, Z as matrices directly\n      xlab = \"x\", ylab = \"y\", zlab = \"f(x, y)\",\n      main = \"g(x,y)\")",
    "crumbs": [
      "**ADVANCED TECHNIQUES**",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "Functions.html#functions-with-default-arguments",
    "href": "Functions.html#functions-with-default-arguments",
    "title": "\n9  Functions\n",
    "section": "\n9.5 Functions with Default Arguments",
    "text": "9.5 Functions with Default Arguments\nA default argument is an argument that assumes a default value if a value is not provided in the function call for that argument. The following example illustrates default arguments in a simple function with two inputs, a name and a number, that the function then prints in the terminal window.\n\n\nPython Code\nR Code\n\n\n\n\ndef f_printInfo(name, age = 35):\n    \"This prints the passed variable values\"\n    print('-----------------')\n    print(\"Name: {}\".format(name))\n    print(\"Age: {}\".format(age))\n    print('-----------------')\n    return\n\n\n\n\nf_printInfo &lt;- function(name, age = 35) {\n  cat(\"-----------------\\n\")\n  cat(\"Name:\", name, \"\\n\")\n  cat(\"Age:\", age, \"\\n\")\n  cat(\"-----------------\\n\")\n}\n\n\n\n\nWe next call the function by differently assigning the name and age variables.\n\n\nPython Code\nR Code\n\n\n\n\nf_printInfo(age=50, name=\"Mike\")\n\n-----------------\nName: Mike\nAge: 50\n-----------------\n\n\n\n\n\nf_printInfo(\"Mike\", 50)  # Provide both name and age\n\n-----------------\nName: Mike \nAge: 50 \n-----------------\n\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nf_printInfo(name=\"Mike\")\n\n-----------------\nName: Mike\nAge: 35\n-----------------\n\n\n\n\n\nf_printInfo(\"Mike\")     # Provide only name, age will use the default value\n\n-----------------\nName: Mike \nAge: 35 \n-----------------\n\n\n\n\n\nThis next function call is problematic as it reverses the variable order!\n\n\nPython Code\nR Code\n\n\n\n\nf_printInfo(50, \"John\")\n\n-----------------\nName: 50\nAge: John\n-----------------\n\n\n\n\n\nf_printInfo(50, \"John\")\n\n-----------------\nName: 50 \nAge: John \n-----------------\n\n\n\n\n\nIf you want to reverse the order you need to provide the keyword argument\nso that the function can assign the values correctly.\n\n\nPython Code\nR Code\n\n\n\n\nf_printInfo(name=\"Mike\", age=50)\n\n-----------------\nName: Mike\nAge: 50\n-----------------\n\n\n\n\n\nf_printInfo(name = \"Mike\", age = 50)\n\n-----------------\nName: Mike \nAge: 50 \n-----------------\n\n\n\n\n\nAnd this one throws a syntax error since we are inconsistent with out function call by providing a keyword argument for one of the input variables but not for the other and we reverse the order at the same time. Here the interpreter will not be able to figure out the correct correspondence between inputs and variable assignments and therefore it throws an error.\n\n\nPython Code\nR Code\n\n\n\n\nf_printInfo(name=\"Mike\", 50)\n\npositional argument follows keyword argument (&lt;string&gt;, line 1)\n\n\n\n\nR does not care about these inconsistencies.\n\nf_printInfo(name=\"Mike\", 50)\n\n-----------------\nName: Mike \nAge: 50 \n-----------------",
    "crumbs": [
      "**ADVANCED TECHNIQUES**",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "Functions.html#scope-of-variables-in-functions",
    "href": "Functions.html#scope-of-variables-in-functions",
    "title": "\n9  Functions\n",
    "section": "\n9.6 Scope of Variables in Functions",
    "text": "9.6 Scope of Variables in Functions\nWhen we use functions we need to distinguish between variables that are local to functions and that can therefore be readily accessed and manipulated by the functions and variables that are defined outside of a function. These variables usually cannot be manipulated directly from within a function.\nPython distinguishes various scope levels that are summarized in Figure 9.1.\n\n\n\n\n\nFigure 9.1: Scope of Variables\n\n\nThe next code sample illustrate the scoping issues that can arise.\n\n\nPython Code\nR Code\n\n\n\n\ndef myFun(x):\n    x += 1\n    print('x in myFun = ', x)\n\n# Call function\nx = 10\nmyFun(5)\nprint('x outside function = ', x)\n\nx in myFun =  6\nx outside function =  10\n\n\n\n\n\nmyFun &lt;- function(x) {\n  x &lt;- x + 1\n  print(paste(\"x in myFun =\", x))\n}\n\n# Call the function\nx &lt;- 10\nmyFun(5)\nprint(paste(\"x outside function =\", x))\n\n[1] \"x in myFun = 6\"\n[1] \"x outside function = 10\"\n\n\n\n\n\nNow let's try to access a variable that is defined outside of the function in what is called the global name space as opposed to the local name space inside of the function.\n\n\nPython Code\nR Code\n\n\n\n\ndef myFun2(x):\n    x += 1\n    print('x inside myFun2 = ', x)\n    print('y inside myFun2 = ', y)\n\n# Call function\ny = 10\nmyFun2(5)\n\nx inside myFun2 =  6\ny inside myFun2 =  10\n\n\n\n\n\nmyFun2 &lt;- function(x) {\n  x &lt;- x + 1\n  print(paste(\"x inside myFun2 =\", x))\n  print(paste(\"y inside myFun2 =\", y))\n}\n\n# Call the function\ny &lt;- 10\nmyFun2(5)\n\n[1] \"x inside myFun2 = 6\"\n[1] \"y inside myFun2 = 10\"\n\n\n\n\n\nHere we see that it is still possible to access variable y despite the fact that it is not handed in explicitly.\n\n\n\n\n\n\nWarning\n\n\n\nThis is bad programming style and should be avoided. Always try to be as explicit as possible. If you want to use input argument y in your function, then define it explicitly as input argument.\n\n\nLet us now try to change the value of variable y inside of the function.\n\n\nPython Code\nR Code\n\n\n\n\ndef myFun3(x):\n    x += 1\n    print('x inside myFun3 = ', x)\n    y = 5\n    print('y inside myFun3 = ', y)\n\n# Call function\ny = 10\nmyFun3(5)\nprint('y outside function =', y)\n\nx inside myFun3 =  6\ny inside myFun3 =  5\ny outside function = 10\n\n\n\n\n\nmyFun3 &lt;- function(x) {\n  x &lt;- x + 1\n  print(paste(\"x inside myFun3 =\", x))\n  y &lt;- 5\n  print(paste(\"y inside myFun3 =\", y))\n}\n\n# Call the function\ny &lt;- 10\nmyFun3(5)\nprint(paste(\"y outside function =\", y))\n\n[1] \"x inside myFun3 = 6\"\n[1] \"y inside myFun3 = 5\"\n[1] \"y outside function = 10\"\n\n\n\n\n\nHere we use variable y again and define it as a local variable inside the function. However, this change is only valid inside the local name space of the function. Once we are outside the function the value of y is 10 again. So y has now two instances, one in the local name space inside the function and another one in the global name space outside of the function.\nLet's next try to manipulate a variable that is not explicitly handed into the function.\n\n\nPython Code\nR Code\n\n\n\n\ndef myFun4(x):\n    x += 1\n    print('x inside myFun4 = ', x)\n    print('y inside myFun4 = ', y)\n    y = 1\n    print('y inside myFun4 = ', y)\n\n# Call function\ny = 10\nmyFun4(5)\nprint('y outside function =', y)\n\nError: UnboundLocalError: cannot access local variable 'y' where it is not associated with a value\n\n\ny outside function = 10\n\n\n\n\n\nmyFun4 &lt;- function(x) {\n  x &lt;- x + 1\n  print(paste(\"x inside myFun4 =\", x))\n  print(paste(\"y inside myFun4 =\", y))\n  y &lt;- 1\n  print(paste(\"y inside myFun4 =\", y))\n}\n\n# Call the function\ny &lt;- 10\nmyFun4(5, y)\n\nError in myFun4(5, y): unused argument (y)\n\nprint(paste(\"y outside function =\", y))\n\n[1] \"y outside function = 10\"\n\n\n\n\n\nHere we get an error because the interpreter defines y as local variable and the first print statement happens before the local variable y is defined.\nWe could finally use variable y as a global variable in which case we can change it outside and inside the function.\n\n\n\n\n\n\nWarning\n\n\n\nAgain, this is considered bad programming style as it can very quickly lead to errors that will be difficult to spot.\n\n\n\n\nPython Code\nR Code\n\n\n\n\ndef myFun5(x):\n    global y\n    x += 1\n    print('x inside myFun5 = ', x)\n    print('y inside myFun5 = ', y)\n    y += 1\n    print('y inside myFun5 = ', y)\n\n# Call function\ny = 10\nprint('y outside function =', y)\nmyFun5(5)\nprint('y outside function =', y)\n\ny outside function = 10\nx inside myFun5 =  6\ny inside myFun5 =  10\ny inside myFun5 =  11\ny outside function = 11\n\n\n\n\n\nmyFun5 &lt;- function(x) {\n  x &lt;- x + 1\n  print(paste(\"x inside myFun5 =\", x))\n  print(paste(\"y inside myFun5 =\", y))\n  y &lt;&lt;- y + 1\n  print(paste(\"y inside myFun5 =\", y))\n}\n\n# Call the function\ny &lt;- 10\nprint(paste(\"y outside function =\", y))\nmyFun5(5)\nprint(paste(\"y outside function =\", y))\n\n[1] \"y outside function = 10\"\n[1] \"x inside myFun5 = 6\"\n[1] \"y inside myFun5 = 10\"\n[1] \"y inside myFun5 = 11\"\n[1] \"y outside function = 11\"",
    "crumbs": [
      "**ADVANCED TECHNIQUES**",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "Functions.html#scope-of-lists-and-arrays-in-functions",
    "href": "Functions.html#scope-of-lists-and-arrays-in-functions",
    "title": "\n9  Functions\n",
    "section": "\n9.7 Scope of Lists and Arrays in Functions",
    "text": "9.7 Scope of Lists and Arrays in Functions\nThe scoping is a little tricky with lists. Check out the following code:\n\n\nPython Code\nR Code\n\n\n\n\ndef myList(inList):\n    # This creates a local name that points to the same list.\n    # If you change this local name list you actually also\n    # change the original list\n    localList = inList\n    print('inside function: ', localList)\n    localList.append('bruno')\n    print('inside function: ', localList)\n    return localList\n\n\n\n\nmyList &lt;- function(inList) {\n  # This creates a local name that points to the same list.\n  # If you change this local name list, you actually also\n  # change the original list\n  localList &lt;- inList\n  print(paste(\"inside function:\", localList))\n  localList &lt;- append(localList, \"bruno\")\n  print(paste(\"inside function:\", localList))\n  return(localList)\n}\n\n\n\n\nCalling this function you may expect that the local list should be different from the list that is handed in from the global namespace. However, the following will happen when you call the function:\n\n\nPython Code\nR Code\n\n\n\n\nqueue = [\"Steve\", \"Russell\", \"Alison\", \"Liam\"]\nprint('outside: ', queue)\nmyList(queue)\nprint('outside: ', queue)\n\noutside:  ['Steve', 'Russell', 'Alison', 'Liam']\ninside function:  ['Steve', 'Russell', 'Alison', 'Liam']\ninside function:  ['Steve', 'Russell', 'Alison', 'Liam', 'bruno']\n['Steve', 'Russell', 'Alison', 'Liam', 'bruno']\noutside:  ['Steve', 'Russell', 'Alison', 'Liam', 'bruno']\n\n\n\n\n\n# Test the function\nqueue &lt;- c(\"Steve\", \"Russell\", \"Alison\", \"Liam\")\nprint(paste(\"outside:\", queue))\nqueue &lt;- myList(queue)\nprint(paste(\"outside:\", queue))\n\n[1] \"outside: Steve\"   \"outside: Russell\" \"outside: Alison\"  \"outside: Liam\"   \n[1] \"inside function: Steve\"   \"inside function: Russell\"\n[3] \"inside function: Alison\"  \"inside function: Liam\"   \n[1] \"inside function: Steve\"   \"inside function: Russell\"\n[3] \"inside function: Alison\"  \"inside function: Liam\"   \n[5] \"inside function: bruno\"  \n[1] \"outside: Steve\"   \"outside: Russell\" \"outside: Alison\"  \"outside: Liam\"   \n[5] \"outside: bruno\"  \n\n\n\n\n\nWe see that the local operation on the list has now affected the global list as well. Why is that? It has to do with how Python treats list assignments. When you assign a list to a new name, you do not create a new list object. The new name simply points to the same location in the computer's memory where the original list is saved. This preserves space. If you now start manipulating the list under its new name, it will translate into changes when calling the same list under its old name (in the global namespace) as well.\nIn the previous example with numbers we did not have to worry about this. When we assigned a new scalar to a variable name, it immediately generates a new object. Local changes to this separate instance would therefore not affect the variable in the global namespace.\n\n\n\n\n\n\nNote\n\n\n\nIf you want the same behavior when working with lists, you need to deepcopy the list. This will effectively create a new list object inside the function scope. Changes in this new object will not trigger changes in the old list object that resides in the global namespace.\n\n\nTry this definition:\n\n\nPython Code\nR Code\n\n\n\n\nimport copy\n\ndef myList2(inList):\n    # This creates a new local list object\n    localList = copy.deepcopy(inList)\n    print('inside function: ', localList)\n    localList.append('bruno')\n    print('inside function: ', localList)\n    return localList\n\n\n\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following object is masked from 'package:gridExtra':\n\n    combine\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nmyList2 &lt;- function(inList) {\n  # This creates a new local list object\n  localList &lt;- copy(inList)\n  print(paste(\"inside function:\", localList))\n  localList &lt;- append(localList, c(\"bruno\"))\n  print(paste(\"inside function:\", localList))\n  return(localList)\n}\n\n\n\n\nIf you call this, we now have a separate list in the global and local namespace.\n\n\nPython Code\nR Code\n\n\n\n\nqueue2 = [\"Steve\", \"Russell\", \"Alison\", \"Liam\"]\nprint('outside: ', queue2)\nmyList2(queue2)\nprint('outside: ', queue2)\n\noutside:  ['Steve', 'Russell', 'Alison', 'Liam']\ninside function:  ['Steve', 'Russell', 'Alison', 'Liam']\ninside function:  ['Steve', 'Russell', 'Alison', 'Liam', 'bruno']\n['Steve', 'Russell', 'Alison', 'Liam', 'bruno']\noutside:  ['Steve', 'Russell', 'Alison', 'Liam']\n\n\n\n\n\n# Test the function\nqueue &lt;- list(\"Steve\", \"Russell\", \"Alison\", \"Liam\")\nprint(paste(\"outside:\", unlist(queue)))\nqueue &lt;- myList2(queue)\n\nError in copy(inList): could not find function \"copy\"\n\nprint(paste(\"outside:\", unlist(queue)))\n\n[1] \"outside: Steve\"   \"outside: Russell\" \"outside: Alison\"  \"outside: Liam\"   \n[1] \"outside: Steve\"   \"outside: Russell\" \"outside: Alison\"  \"outside: Liam\"   \n\n\n\n\n\nIf you deal with numpy arrays you do not have to worry about this. As a new assignment of a numpy array will always generate a new object (just like a number assignment did in the previous section) and not a new pointer to an existing space in memory. Try this:\n\n\nPython Code\nR Code\n\n\n\n\ndef myArray(inArray):\n    # This creates a local name that is a new object\n    localArray = inArray\n    print('inside function: ', localArray)\n    localArray = np.append(localArray,4)\n    print('inside function: ', localArray)\n    return localArray\n\n\n\n\nmyArray &lt;- function(inArray) {\n  # This creates a local name that is a new object\n  localArray &lt;- inArray\n  print(paste(\"inside function:\", localArray))\n  localArray &lt;- append(localArray, 4)\n  print(paste(\"inside function:\", localArray))\n  return(localArray)\n}\n\n\n\n\nAnd calling it:\n\n\nPython Code\nR Code\n\n\n\n\nqueue = np.array([1,2,3])\nprint('outside: ', queue)\nmyArray(queue)\nprint('outside: ', queue)\n\noutside:  [1 2 3]\ninside function:  [1 2 3]\ninside function:  [1 2 3 4]\narray([1, 2, 3, 4])\noutside:  [1 2 3]\n\n\n\n\n\n# Test the function\noriginalArray &lt;- c(1, 2, 3)\nprint(paste(\"outside:\", originalArray))\nresultArray &lt;- myArray(originalArray)\nprint(paste(\"outside:\", resultArray))\n\n[1] \"outside: 1\" \"outside: 2\" \"outside: 3\"\n[1] \"inside function: 1\" \"inside function: 2\" \"inside function: 3\"\n[1] \"inside function: 1\" \"inside function: 2\" \"inside function: 3\"\n[4] \"inside function: 4\"\n[1] \"outside: 1\" \"outside: 2\" \"outside: 3\" \"outside: 4\"\n\n\n\n\n\n\n\n\n\n\n\nKey Concepts and Summary\n\n\n\n\nFunctions allow you to collect a code block that gets repeated a lot.\nFunctions take input variables and produce an output variable or variables.\nFunctions allow you to keep your codes shorter\n\n\n\n\n\n\n\n\n\nSelf-check questions\n\n\n\n\n\n\nProgram a function that calculates the standard deviation of the elements of an input vector.\nThen evaluate the function with this vector \\(\\vec{x}=[0.4, 0.6,0.9,1.8,4.2,2.9]\\)\n\n\n\n\n\n\n\n\nFigure 9.1: Scope of Variables",
    "crumbs": [
      "**ADVANCED TECHNIQUES**",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "OOP.html",
    "href": "OOP.html",
    "title": "\n10  Object Oriented Programming\n",
    "section": "",
    "text": "10.1 Introduction\nA Programming Paradigm is a way or style of programming. There are many different paradigms and sometimes they overlap. Some of the main ones are:\nProgramming Paradigms\nProgramming ParadigmsImperative\nImperativeProgramming Paradigms-&gt;Imperative\nFunctional\nFunctionalProgramming Paradigms-&gt;Functional\nObject Oriented\nObject OrientedProgramming Paradigms-&gt;Object Oriented\n...others\n...othersProgramming Paradigms-&gt;...others\nThe Imperative Paradigm can best be understood as a sequence of commands that are executed one by one as in: first do this, then do that, etc. It can contain loop and branch statements. The programs we have written so far follow this paradigm.\nThe Functional Paradigm uses mathematical functions as a core principle of building a program. Functions can then be called to evaluate an expression and use the resulting value for further calculations using functions. Functions can also be nested, i.e., a function that calls another function etc. We have used functions earlier, so imagine an almost exclusive use of functions throughout your program.\nThe Object Oriented Programming (OOP) Paradigm defines objects (i.e., typically a data construct that contains functions that can be called to execute calculations on its data) that send messages to each other.\nObjects are like lists or arrays combined with functions that can be called on these lists or arrays. In essence an object is a container holding the data together with methods (or functions) that can be applied to these data. In OOP functions are typically referred to as methods.\nimport math as m\nimport time # Imports system time module to time your script\nBefore using an object, we need to define the blueprint for it. We use the class method to do this and define the blueprint for an animal-object.\nWhen defining object we make the rough distinction between data that the object carries - these are usually variables with the prefix .self and functions that can be called on these data and that are defined within the object. These functions are called methods in object-oriented parlance. In python they are defined very similarly to functions from the previous chapter.\nYou can look at the class blueprint of the animal object using the help() function\nhelp(Animal)\n\nHelp on class Animal in module __main__:\n\nclass Animal(builtins.object)\n |  Animal(name='Animal Doe', weight=0.0)\n |  \n |  This is the animal class. It's the top class.\n |  \n |  Methods defined here:\n |  \n |  __init__(self, name='Animal Doe', weight=0.0)\n |      Initialize the animal-object with a\n |      default name variable\n |  \n |  eatFood(self, foodAmount=0.0)\n |      Method: eatFood(foodAmount=0)\n |      translates food input 'foodAmount'\n |      into additional weight according to the\n |      following formula:\n |      new_weight = old_weight + sqrt(foodAmount)\n |  \n |  showMyself(self)\n |      Method: showMyself()\n |      prints out all the variables.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |  \n |  __dict__\n |      dictionary for instance variables (if defined)\n |  \n |  __weakref__\n |      list of weak references to the object (if defined)\nWe next generate an animal object. Here we create the first animal. Its name is Birdy and Birdy weighs 5 gramms.\nYou can access the variables (or embedded data) of the animal using the animal object and the 'dot' notation.\nOr you can simply call the showMyself() method that was defined within the class or blueprint of the animal object.\nNow we let the animal eat, by calling the method eatFood() on the bird object.\nanimal1.eatFood(9)\nprint(\"The animal's new weight is = {}\".format(animal1.weight))\n\nThe animal's new weight is = 8.0\nAnother way to see the change is to call the same showMyself() method that we called earlier so you see that the animal1 object is actually storing the change in weight permanently.\nanimal1.showMyself()\n\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is Birdy\nMy weight is 8.0 pounds\n-------------------------------",
    "crumbs": [
      "**ADVANCED TECHNIQUES**",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Object Oriented Programming</span>"
    ]
  },
  {
    "objectID": "OOP.html#introduction",
    "href": "OOP.html#introduction",
    "title": "\n10  Object Oriented Programming\n",
    "section": "",
    "text": "Note\n\n\n\nLater we will define more blueprints for sub-classes within animals that inherit some common features of animals and then add more specific features that are particular to that animal.\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nimport math as m\n\nclass Animal(object):\n    \"\"\"This is the animal class. It's the top class.\"\"\"\n\n    def __init__(self, name = 'Animal Doe', weight = 0.0):\n        \"\"\"Initialize the animal-object with a\n        default name variable\"\"\"\n        self.name = name\n        self.weight = weight\n\n    def showMyself(self):\n        \"\"\"Method: showMyself()\n        prints out all the variables.\"\"\"\n        print(\"\\n\")\n        print(\"Hello, let me introduce myself.\")\n        print(\"-------------------------------\")\n        print(\"My name is {}\".format(self.name))\n        print(\"My weight is {} pounds\".format(self.weight))\n        print(\"-------------------------------\\n\")\n\n    def eatFood(self, foodAmount = 0.0):\n        \"\"\"Method: eatFood(foodAmount=0)\n        translates food input 'foodAmount'\n        into additional weight according to the\n        following formula:\n        new_weight = old_weight + sqrt(foodAmount)\"\"\"\n        self.weight += m.sqrt(foodAmount)\n\n\n\n\n# Create a class called \"Animal\"\nsetClass(\"Animal\",\n         slots = list(name = \"character\", weight = \"numeric\"),\n         prototype = list(name = \"Animal Doe\", weight = 0.0))\n\n# Define a method for the class\nsetMethod(\"show\", \"Animal\",\n   function(object) {\n   cat(\"\\n\")\n   cat(\"Hello, let me introduce myself.\\n\")\n   cat(\"-------------------------------\\n\")\n   cat(\"My name is\", object@name, \"\\n\")\n   cat(\"My weight is\", object@weight, \"pounds\\n\")\n   cat(\"-------------------------------\\n\\n\")\n   })\n\n# Create an instance of the Animal class\nmyAnimal &lt;- new(\"Animal\", name = \"Joe\")\n\n# Use methods of the Animal class\nmyAnimal\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is Joe \nMy weight is 0 pounds\n-------------------------------\n\n\n\n\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nanimal1 = Animal(name = 'Birdy', weight = 5.0)\n\n\n\n\n# Create an instance of the Animal class\nanimal1 &lt;- new(\"Animal\", name = \"Birdy\", weight = 5.0)\n\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nprint(\"The name of the first animal is {}\".format(animal1.name))\nprint(\"The weight of the first animal is {}\".format(animal1.weight))\n\nThe name of the first animal is Birdy\nThe weight of the first animal is 5.0\n\n\n\n\n\n# Access slots of the Animal instance\ncat(\"The name of the first animal is\", animal1@name, \"\\n\")\ncat(\"The weight of the first animal is\", animal1@weight, \"\\n\")\n\nThe name of the first animal is Birdy \nThe weight of the first animal is 5 \n\n\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nanimal1.showMyself()\n\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is Birdy\nMy weight is 5.0 pounds\n-------------------------------\n\n\n\n\n\n# If you call the name of the object it automatically callse\n# the show method\nanimal1\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is Birdy \nMy weight is 5 pounds\n-------------------------------\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nOOP programming in R is very tedious, I therefore will only provide Python examples from here onwards.",
    "crumbs": [
      "**ADVANCED TECHNIQUES**",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Object Oriented Programming</span>"
    ]
  },
  {
    "objectID": "OOP.html#inheritance-and-subclasses",
    "href": "OOP.html#inheritance-and-subclasses",
    "title": "\n10  Object Oriented Programming\n",
    "section": "\n10.2 Inheritance and Subclasses",
    "text": "10.2 Inheritance and Subclasses\nWe next generate a new class that inherits features of the animal class but is more specific. We call it the bird class. A bird is an animal but it has certain bird specific features that other animals do not share. Here is the blueprint.\nNote that it is derived from the Animal class so that the Bird class inherits all the methods and variable definitions of its superclass of Animals. However, it adds a couple more variables and methods. Plus it overrides the old method showMyself() with a more comprehensive output.\n\n\n\n\n\n\nNote\n\n\n\nInheritance saves us a lot of typing. As you generate other particual animal objects, you will not have to retype the methods that all animals share. This makes codes more condensed, re-usable and readable.\n\n\n\n\nPython Code\nR Code\n\n\n\n\nclass Bird(Animal):\n    \"\"\"This is the bird class, derived from the\n    animal class.\"\"\"\n\n    def __init__(self, name='Bird Doe', weight=0, color='na',\nspeed=0):\n        \"\"\"Initialize the bird-object calling the animal init method\n        but also adding additional variables\"\"\"\n        Animal.__init__(self, name, weight)\n        self.color = color\n        self.speed = speed\n\n    def showMyself(self):\n        \"\"\"Method: showMyself()\n        prints out all the variables.\"\"\"\n        print(\"\\n\")\n        print(\"Hello, let me introduce myself.\")\n        print(\"-------------------------------\")\n        print(\"My name is {}\".format(self.name))\n        print(\"My weight is {} grams\".format(self.weight))\n        print(\"My color is {}\".format(self.color))\n        print(\"My speed is {}\".format(self.speed))\n        print(\"-------------------------------\\n\")\n\n    def flyTraining(self, workoutLength=0):\n        \"\"\"Method: flyTraining(workoutLength)\n        Augments the flight speed of the bird as a function\n        of the bird objects workoutLength:\n        new_speed = old_speed + log(workoutLength)\"\"\"\n        self.speed += m.log(workoutLength)\n\n\n\n\n# Define a subclass called \"Bird\" that inherits from the \"Animal\" class\nBird &lt;- setClass(\"Bird\", contains = \"Animal\",\n                 slots = list(color = \"character\", speed = \"numeric\"),\n                 prototype = list(color = \"na\", speed = 0))\n\n# Define a method for the class\nsetMethod(\"show\", \"Bird\",\n   function(object) {\n   cat(\"\\n\")\n   cat(\"Hello, let me introduce myself.\\n\")\n   cat(\"-------------------------------\\n\")\n   cat(\"My name is\", object@name, \"\\n\")\n   cat(\"My weight is\", object@weight, \"pounds\\n\")\n   cat(\"My color is\", object@color, \"\\n\")\n   cat(\"My speed is\", object@speed, \"\\n\")\n   cat(\"-------------------------------\\n\\n\")\n   })\n\n\n\n\nHere we redefined the showMyself() method from the animal class. When we call it on the bird object, it will use this new definition of the method.\nNow let's look at the bird's class blueprint\n\nhelp(Bird)\n\nHelp on class Bird in module __main__:\n\nclass Bird(Animal)\n |  Bird(name='Bird Doe', weight=0, color='na', speed=0)\n |  \n |  This is the bird class, derived from the\n |  animal class.\n |  \n |  Method resolution order:\n |      Bird\n |      Animal\n |      builtins.object\n |  \n |  Methods defined here:\n |  \n |  __init__(self, name='Bird Doe', weight=0, color='na', speed=0)\n |      Initialize the bird-object calling the animal init method\n |      but also adding additional variables\n |  \n |  flyTraining(self, workoutLength=0)\n |      Method: flyTraining(workoutLength)\n |      Augments the flight speed of the bird as a function\n |      of the bird objects workoutLength:\n |      new_speed = old_speed + log(workoutLength)\n |  \n |  showMyself(self)\n |      Method: showMyself()\n |      prints out all the variables.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from Animal:\n |  \n |  eatFood(self, foodAmount=0.0)\n |      Method: eatFood(foodAmount=0)\n |      translates food input 'foodAmount'\n |      into additional weight according to the\n |      following formula:\n |      new_weight = old_weight + sqrt(foodAmount)\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from Animal:\n |  \n |  __dict__\n |      dictionary for instance variables (if defined)\n |  \n |  __weakref__\n |      list of weak references to the object (if defined)\n\n\nWe next generate our first bird object.\n\n\nPython Code\nR Code\n\n\n\n\nbird1 = Bird('Herman', 12, 'blue', 40)\nbird1.showMyself()\n\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is Herman\nMy weight is 12 grams\nMy color is blue\nMy speed is 40\n-------------------------------\n\n\n\n\n\n# Create an instance of the Bird class\nbird1 &lt;- new(\"Bird\", name = \"Herman\", weight = 12, color = \"blue\", speed = 40)\n\n# Access slots and use methods of the Bird instance\nbird1\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is Herman \nMy weight is 12 pounds\nMy color is blue \nMy speed is 40 \n-------------------------------\n\n\n\n\n\nWe let the bird eat and then we train him a bit.\n\nbird1.eatFood(foodAmount=9)\nbird1.flyTraining(workoutLength=10)\nbird1.showMyself()\n\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is Herman\nMy weight is 15.0 grams\nMy color is blue\nMy speed is 42.30258509299404\n-------------------------------\n\n\nWe next generate another bird, but this time we leave out some of the features when we generate it. Python will then simply assign the default values that we defined in the class blueprint above.\n\nbird2 = Bird('Tweets', speed=12)\nbird2.showMyself()\n\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is Tweets\nMy weight is 0 grams\nMy color is na\nMy speed is 12\n-------------------------------",
    "crumbs": [
      "**ADVANCED TECHNIQUES**",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Object Oriented Programming</span>"
    ]
  },
  {
    "objectID": "OOP.html#generating-multiple-objects",
    "href": "OOP.html#generating-multiple-objects",
    "title": "\n10  Object Oriented Programming\n",
    "section": "\n10.3 Generating Multiple Objects",
    "text": "10.3 Generating Multiple Objects\nGenerating a list full of bird objects from two lists with names and weights of animals, but no colors or speeds\n\n\nPython Code\nR Code\n\n\n\n\nbirdObjectList = []\nname_list = ['Birdy', 'Chip', 'Tweets', 'Feather', 'Gull']\nweight_list = [4.3, 2.3, 5.6, 5.0, 15.3]\n\nfor i, (name, weight) in enumerate(zip(name_list, weight_list)):\n    print(\"Nr. {}: name = {}, weight = {}\".format(i, name, weight))\n    # Here we create the bird objects and store them in\n    # the birdObjectList\n    birdObjectList.append(Bird(name=name, weight=weight))\n\n# Here we print what we have so far\n\nNr. 0: name = Birdy, weight = 4.3\nNr. 1: name = Chip, weight = 2.3\nNr. 2: name = Tweets, weight = 5.6\nNr. 3: name = Feather, weight = 5.0\nNr. 4: name = Gull, weight = 15.3\n\nprint(birdObjectList)\n\n[&lt;__main__.Bird object at 0x7f550409dad0&gt;, &lt;__main__.Bird object at 0x7f550406f2d0&gt;, &lt;__main__.Bird object at 0x7f55040973d0&gt;, &lt;__main__.Bird object at 0x7f550409db10&gt;, &lt;__main__.Bird object at 0x7f550409db50&gt;]\n\n\n\n\n\n# Create a list to store Bird objects\nbirdObjectList &lt;- list()\n\n# Define the lists of attributes\nname_list &lt;- c('Birdy', 'Chip', 'Tweets', 'Feather', 'Gull')\nweight_list &lt;- c(4.3, 2.3, 5.6, 5.0, 15.3)\n\n# Loop to create Bird objects and store them in the list\nfor (i in 1:length(name_list)) {\n  birdObjectList[[i]] &lt;- new(\"Bird\", name = name_list[i], weight = weight_list[i])\n  cat(\"Nr.\", i, \": name =\", birdObjectList[[i]]@name, \"weight =\", birdObjectList[[i]]@weight, \"\\n\")\n}\n\nNr. 1 : name = Birdy weight = 4.3 \nNr. 2 : name = Chip weight = 2.3 \nNr. 3 : name = Tweets weight = 5.6 \nNr. 4 : name = Feather weight = 5 \nNr. 5 : name = Gull weight = 15.3 \n\n# Print the list of Bird objects\nprint(birdObjectList)\n\n[[1]]\n\nHello, let me introduce myself.\n-------------------------------\nMy name is Birdy \nMy weight is 4.3 pounds\nMy color is na \nMy speed is 0 \n-------------------------------\n\n\n[[2]]\n\nHello, let me introduce myself.\n-------------------------------\nMy name is Chip \nMy weight is 2.3 pounds\nMy color is na \nMy speed is 0 \n-------------------------------\n\n\n[[3]]\n\nHello, let me introduce myself.\n-------------------------------\nMy name is Tweets \nMy weight is 5.6 pounds\nMy color is na \nMy speed is 0 \n-------------------------------\n\n\n[[4]]\n\nHello, let me introduce myself.\n-------------------------------\nMy name is Feather \nMy weight is 5 pounds\nMy color is na \nMy speed is 0 \n-------------------------------\n\n\n[[5]]\n\nHello, let me introduce myself.\n-------------------------------\nMy name is Gull \nMy weight is 15.3 pounds\nMy color is na \nMy speed is 0 \n-------------------------------\n\n\n\n\n\nWe can access the bird objects created in this list by list indexation and calling on methods defined on the bird class.\nLet's graph the 3rd bird in the list and remember that indexing starts at 0.\n\n\nPython Code\nR Code\n\n\n\n\nprint('birdObjectList[2] =', birdObjectList[2])\nprint('birdObjectList[2].name =', birdObjectList[2].name)\nprint('birdObjectList[2].weight =', birdObjectList[2].weight)\nprint('birdObjectList[2].color =', birdObjectList[2].color)\nprint('birdObjectList[2].speed =', birdObjectList[2].speed)\n\nbirdObjectList[2] = &lt;__main__.Bird object at 0x7f55040973d0&gt;\nbirdObjectList[2].name = Tweets\nbirdObjectList[2].weight = 5.6\nbirdObjectList[2].color = na\nbirdObjectList[2].speed = 0\n\n\n\n\n\ncat('birdObjectList[[2]]@name  =', birdObjectList[[2]]@name, '\\n')\ncat('birdObjectList[[2]]@weight=', birdObjectList[[2]]@weight, '\\n')\ncat('birdObjectList[[2]]@color =', birdObjectList[[2]]@color, '\\n')\ncat('birdObjectList[[2]]@speed =', birdObjectList[[2]]@speed, '\\n')\n\nbirdObjectList[[2]]@name  = Chip \nbirdObjectList[[2]]@weight= 2.3 \nbirdObjectList[[2]]@color = na \nbirdObjectList[[2]]@speed = 0 \n\n\n\n\n\nOr we could have also done:\n\n\nPython Code\nR Code\n\n\n\n\nbirdObjectList[2].showMyself()\n\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is Tweets\nMy weight is 5.6 grams\nMy color is na\nMy speed is 0\n-------------------------------\n\n\n\n\n\nbirdObjectList[[2]]\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is Chip \nMy weight is 2.3 pounds\nMy color is na \nMy speed is 0 \n-------------------------------\n\n\n\n\n\n\n\n\n\n\n\nKey Concepts and Summary\n\n\n\n\nObject oriented programming\nMethods and functions\nAttributes and variables\n\n\n\n\n\n\n\n\n\nSelf-check questions\n\n\n\n\n\n\nGenerate a student class with attributes age, GPA, and gender\nInstantiate 5 students",
    "crumbs": [
      "**ADVANCED TECHNIQUES**",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Object Oriented Programming</span>"
    ]
  },
  {
    "objectID": "Data-1.html",
    "href": "Data-1.html",
    "title": "\n11  Working with Data I: Data Cleaning\n",
    "section": "",
    "text": "11.1 Create DataFrame from Multiple Lists\nIf you scrape information from a website or a pdf document, you often end up with your data stored across various lists. Sometimes these lists are simply holding the column information of a specific variable, sometimes the lists are nested lists, where one list contains the information of all variables per observation. pandas is intelligent enough (usually) to handle them all in a very similar way. I next illustrate the two most often found list structures in data work.",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Working with Data I: Data Cleaning</span>"
    ]
  },
  {
    "objectID": "Data-1.html#create-dataframe-from-multiple-lists",
    "href": "Data-1.html#create-dataframe-from-multiple-lists",
    "title": "\n11  Working with Data I: Data Cleaning\n",
    "section": "",
    "text": "11.1.1 Every List Holds Information of a Separate Variable\nLet us assume you observe information about 4! people. The unit of observation is therefore a person. For each person you know the name, age, and the city where they live. This information is stored in 3! separate lists.\nThere is an easy way to combine these lists into a DataFrame for easy statistical analysis. The process has two steps:\n\n\nUse the zip() command to combine the lists\nAssign the \"zipped\" lists to a Pandas DataFrame\n\n\n\n\nPython Code\nR Code\n\n\n\n\nimport pandas as pd\n\nnames = ['Katie', 'Nick', 'James', 'Eva']\nages = [32, 32, 36, 31]\nlocations = ['London', 'Baltimore', 'Atlanta', 'Madrid']\n\n# Now zip the lists together\nzipped = list(zip(names, ages, locations))\n\n# Assign the zipped lists into a DataFrame\nmyData = pd.DataFrame(zipped, columns=['Name', 'Age', 'Location'])\nprint(myData)\n\n    Name  Age   Location\n0  Katie   32     London\n1   Nick   32  Baltimore\n2  James   36    Atlanta\n3    Eva   31     Madrid\n\n\n\n\n\n# Define the vectors\nnames &lt;- c('Katie', 'Nick', 'James', 'Eva')\nages &lt;- c(32, 32, 36, 31)\nlocations &lt;- c('London', 'Baltimore', 'Atlanta', 'Madrid')\n\n# Create a data frame\nmyData &lt;- data.frame(Name = names, Age = ages, Location = locations)\n\n# Print the data frame\nprint(myData)\n\n   Name Age  Location\n1 Katie  32    London\n2  Nick  32 Baltimore\n3 James  36   Atlanta\n4   Eva  31    Madrid\n\n\n\n\n\n\n11.1.2 Every List Holds Information of one Unit of Observation\nIn this example, the information is stored per person. So each person is stored in a list that contains all 3! variables. Then these person lists are stored in another list. We now are dealing with a nested list.\nThe steps to move the information from the lists into a DataFrame are pretty much the same. Pandas is intelligent in that way and recognizes the structure of the data.\nAgain the process has two steps:\n\n\nUse the zip() command to combine the lists\nAssign the \"zipped\" lists to a Pandas DataFrame\n\n\n\n\nPython Code\nR Code\n\n\n\n\nimport pandas as pd\n\n# This is the structure of your data\ndata = [['Katie', 32, 'London'], ['Nik', 32, 'Toronto'], ['James', 36, 'Atlanta'], ['Evan', 31, 'Madrid']]\n\n# Assign the multi-dimensional (or nested) list to DataFrame\nmyData = pd.DataFrame(data, columns=['Name', 'Age', 'Location'])\nprint(myData)\n\n    Name  Age Location\n0  Katie   32   London\n1    Nik   32  Toronto\n2  James   36  Atlanta\n3   Evan   31   Madrid\n\n\n\n\n\n# This is the structure of your data\ndata &lt;- list(\n  c('Katie', 32, 'London'),\n  c('Nik', 32, 'Toronto'),\n  c('James', 36, 'Atlanta'),\n  c('Evan', 31, 'Madrid')\n)\n\n# Assign the nested list to a DataFrame\nmyData &lt;- data.frame(\n  Name = sapply(data, `[`, 1),\n  Age = sapply(data, `[`, 2),\n  Location = sapply(data, `[`, 3)\n)\n\n# Print the data frame\nprint(myData)\n\n   Name Age Location\n1 Katie  32   London\n2   Nik  32  Toronto\n3 James  36  Atlanta\n4  Evan  31   Madrid",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Working with Data I: Data Cleaning</span>"
    ]
  },
  {
    "objectID": "Data-1.html#read-small-data-set-from-a-comma-separated-.csv-file",
    "href": "Data-1.html#read-small-data-set-from-a-comma-separated-.csv-file",
    "title": "\n11  Working with Data I: Data Cleaning\n",
    "section": "\n11.2 Read Small Data Set from a Comma Separated (.csv) File",
    "text": "11.2 Read Small Data Set from a Comma Separated (.csv) File\nIt is more common that your data is stored in a file such as a text file, Excel spreadsheet, or a file format of some other data management software such as Stata, R, SAS, or SPSS. The Pandas library does provide you with routines (i.e., commands) that will allow you to import data directly from the most common file formats.\nIn our first example, we will work with data stored as a comma separated file, called Lecture_Data_Excel_a.csv &lt;Lecture_Data/Lecture_Data_Excel_a.csv&gt;. We first import this file using the pd.read_csv command from the Pandas library.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom scipy import stats as st\nimport math as m\nimport seaborn as sns\nimport time  # Imports system time module to time your script\n\nplt.close('all')  # close all open figures\n\n\n\nPython Code\nR Code\n\n\n\n\n# Read in small data from .csv file\n# Filepath\nfilepath = 'Lecture_Data/'\n# In windows you can also specify the absolute path to your data file\n# filepath = 'C:/Dropbox/Towson/Teaching/3_ComputationalEconomics/Lectures/Lecture_Data/'\n\n# ------------- Load data --------------------\ndf = pd.read_csv(filepath + 'Lecture_Data_Excel_a.csv', dtype={'Frequency': float})\n\n# Let's have a look at it.\nprint(df)\n\n                 Area  Frequency  Unnamed: 2  Unnamed: 3\n0          Accounting       73.0         NaN         NaN\n1             Finance       52.0         NaN         NaN\n2  General management       36.0         NaN         NaN\n3     Marketing sales       64.0         NaN         NaN\n4               other       28.0         NaN         NaN\n\n\nAlternatively we could have use the following command:\n\ndf = pd.read_table(filepath + 'Lecture_Data_Excel_a.csv', sep=',')\n\n# Let's have a look at it.\nprint(df)\n\n                 Area  Frequency  Unnamed: 2  Unnamed: 3\n0          Accounting         73         NaN         NaN\n1             Finance         52         NaN         NaN\n2  General management         36         NaN         NaN\n3     Marketing sales         64         NaN         NaN\n4               other         28         NaN         NaN\n\n\n\n\n\n# Filepath\nfilepath &lt;- 'Lecture_Data/'\n# In Windows, you can also specify the absolute path to your data file\n# filepath &lt;- 'C:/Dropbox/Towson/Teaching/3_ComputationalEconomics/Lectures/Lecture_Data/'\n\n# Load data\ndf &lt;- read.csv(paste0(filepath, 'Lecture_Data_Excel_a.csv'))\n\n# Let's have a look at it\nprint(df)\n\n                Area Frequency  X X.1\n1         Accounting        73 NA  NA\n2            Finance        52 NA  NA\n3 General management        36 NA  NA\n4    Marketing sales        64 NA  NA\n5              other        28 NA  NA\n\n\n\n\n\nThe best way to import Excel files directly is probably to use the built in importer in Pandas.\n\n\n\n\n\n\nImportant\n\n\n\nIn order for this to work you need to make sure that the xlrd package is installed. Open a terminal window and type:\nconda install xlrd\nPress yes at the prompt and it will install the package.\n\n\nYou can use it as follows:\n\n\nPython Code\nR Code\n\n\n\n\n# Read entire excel spreadsheet\ndf = pd.read_excel(filepath + 'Lecture_Data_Excel_a.xlsx', \\\n     sheet_name = 'Lecture_Data_Excel_a', header = 0, usecols = 'A:D')\n\nMissing optional dependency 'openpyxl'.  Use pip or conda to install openpyxl.\n\n# Let's have a look at it.\nprint(df)\n\n                 Area  Frequency  Unnamed: 2  Unnamed: 3\n0          Accounting         73         NaN         NaN\n1             Finance         52         NaN         NaN\n2  General management         36         NaN         NaN\n3     Marketing sales         64         NaN         NaN\n4               other         28         NaN         NaN\n\n\n\n\n\n# Load the readxl package\nlibrary(readxl)\n\n# Filepath\nfilepath &lt;- 'Lecture_Data/'\n# In Windows, you can also specify the absolute path to your data file\n# filepath &lt;- 'C:/Dropbox/Towson/Teaching/3_ComputationalEconomics/Lectures/Lecture_Data/'\n\n# Read entire Excel spreadsheet\ndf &lt;- read_excel(paste0(filepath, 'Lecture_Data_Excel_a.xlsx'), sheet = 'Lecture_Data_Excel_a', col_names = TRUE)\n\n# Let's have a look at it\nprint(df)\n\n# A tibble: 5 × 4\n  Area               Frequency `Unnamed: 2` `Unnamed: 3`\n  &lt;chr&gt;                  &lt;dbl&gt; &lt;lgl&gt;        &lt;lgl&gt;       \n1 Accounting                73 NA           NA          \n2 Finance                   52 NA           NA          \n3 General management        36 NA           NA          \n4 Marketing sales           64 NA           NA          \n5 other                     28 NA           NA          \n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote how I also specified the excel sheet_name this is convenient in case you have more complex Excel spreadsheets with multiple tabs in it.\n\n\nThe DataFrame has an index for each row and a column header. We can query a DataFrame as follows:\n\n\nPython Code\nR Code\n\n\n\n\nprint('Shape', df.shape)\nprint('-------------------------')\nprint('Number of rows', len(df))\nprint('-------------------------')\nprint('Column headers', df.columns)\nprint('-------------------------')\nprint('Data types', df.dtypes)\nprint('-------------------------')\nprint('Index', df.index)\nprint('-------------------------')\n\nShape (5, 4)\n-------------------------\nNumber of rows 5\n-------------------------\nColumn headers Index(['Area', 'Frequency', 'Unnamed: 2', 'Unnamed: 3'], dtype='object')\n-------------------------\nData types Area           object\nFrequency       int64\nUnnamed: 2    float64\nUnnamed: 3    float64\ndtype: object\n-------------------------\nIndex RangeIndex(start=0, stop=5, step=1)\n-------------------------\n\n\n\n\n\n# Shape - Number of Rows and Columns\ncat(\"Shape: \", nrow(df), \" rows, \", ncol(df), \" columns\\n\")\n\n# Number of Rows\ncat(\"Number of rows: \", nrow(df), \"\\n\")\n\n# Column Headers\ncat(\"Column headers: \", colnames(df), \"\\n\")\n\n# Data Types\ncat(\"Data types: \", sapply(df, class), \"\\n\")\n\n# Index\ncat(\"Index: \", 1:nrow(df), \"\\n\")\n\nShape:  5  rows,  4  columns\nNumber of rows:  5 \nColumn headers:  Area Frequency Unnamed: 2 Unnamed: 3 \nData types:  character numeric logical logical \nIndex:  1 2 3 4 5 \n\n\n\n\n\nDrop column 3 and 4 and let's have a look at the data again.\n\n\nPython Code\nR Code\n\n\n\n\n# axis = 1 means that you are dropping a column\ndf.drop('Unnamed: 2', axis=1, inplace=True)\n\ndf.drop('Unnamed: 3', axis=1, inplace=True)\n\n# Let's have a look at it, it's a nested list\nprint(df)\n\n                 Area  Frequency\n0          Accounting         73\n1             Finance         52\n2  General management         36\n3     Marketing sales         64\n4               other         28\n\n\n\n\n\n# Load the dplyr library if you haven't already\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n# Remove columns by name\ndf &lt;- df %&gt;% select(!c('Unnamed: 2', 'Unnamed: 3'))\n\n# Print the modified data frame\nprint(df)\n\n# A tibble: 5 × 2\n  Area               Frequency\n  &lt;chr&gt;                  &lt;dbl&gt;\n1 Accounting                73\n2 Finance                   52\n3 General management        36\n4 Marketing sales           64\n5 other                     28\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nSometimes column headers have white spaces in them. It is probably a good idea to remove all white spaces from header names. You can use the replace() command to accomplish this:\n\n\n\n\nPython Code\nR Code\n\n\n\n\ndf.columns = df.columns.str.replace('\\s+', '', regex=True)\n\n\n\n\n# Remove spaces from column names\ncolnames(df) &lt;- gsub(\"\\\\s+\", \"\", colnames(df))\n\n\n\n\nThe \\s+ is a regular expression which is basically a pattern matching language. The s stands for space and the + means look for one or more spaces and replace them with '', well, nothing i.e. a blank string.\nWe can make new columns using information from the existing columns.\n\n\n\n\n\n\nNote\n\n\n\nMaking new columns in the DataFrame is very similar to making new variables in Stata using the generate or gen command.\n\n\nMore specifically, we next generate a new variable called relFrequency that contains the relative frequencies.\n\n\nPython Code\nR Code\n\n\n\n\n# Make new column with relative frequency\ndf['relFrequency'] = df['Frequency']/df['Frequency'].sum()\n\n# Let's have a look at it, it's a nested list\nprint(df)\n\n                 Area  Frequency  relFrequency\n0          Accounting         73      0.288538\n1             Finance         52      0.205534\n2  General management         36      0.142292\n3     Marketing sales         64      0.252964\n4               other         28      0.110672\n\n\n\n\n\n# Make a new column with relative frequency\ndf$relFrequency &lt;- df$Frequency / sum(df$Frequency)\n\n# Print the data frame\nprint(df)\n\n# A tibble: 5 × 3\n  Area               Frequency relFrequency\n  &lt;chr&gt;                  &lt;dbl&gt;        &lt;dbl&gt;\n1 Accounting                73        0.289\n2 Finance                   52        0.206\n3 General management        36        0.142\n4 Marketing sales           64        0.253\n5 other                     28        0.111\n\n\n\n\n\nWe can also just grab the relative frequencies out of the DataFrame and store it in the familiar a numpy array. This is now a vector. You can only do this if the information in the column is only numbers.\n\n\nPython Code\nR Code\n\n\n\n\nxv = df['relFrequency'].values\n\nprint('Array xv is:', xv)\n\nArray xv is: [0.28853755 0.2055336  0.14229249 0.25296443 0.11067194]\n\n\n\n\n\nxv &lt;- df$relFrequency\n\ncat('Array xv is:', xv, '\\n')\n\nArray xv is: 0.2885375 0.2055336 0.1422925 0.2529644 0.1106719 \n\n\n\n\n\nYou can now do simple calculations with this vector as you did in the previous chapters such as:\n\n\nPython Code\nR Code\n\n\n\n\nprint('The sum of the vector xv is: ', xv.sum())\n\nThe sum of the vector xv is:  1.0\n\n\n\n\n\n# Calculate the sum of the vector xv\nsum_xv &lt;- sum(xv)\ncat(\"The sum of the vector xv is:\", sum_xv, \"\\n\")\n\nThe sum of the vector xv is: 1 \n\n\n\n\n\nLet us make an additional column so we have more data to play with:\n\n\nPython Code\nR Code\n\n\n\n\ndf['random'] = df['Frequency']/np.sqrt(df['Frequency'].sum())\n\n# Let's have a look at it.\nprint(df)\n\n                 Area  Frequency  relFrequency    random\n0          Accounting         73      0.288538  4.589471\n1             Finance         52      0.205534  3.269212\n2  General management         36      0.142292  2.263301\n3     Marketing sales         64      0.252964  4.023646\n4               other         28      0.110672  1.760345\n\n\n\n\n\n# Add a new column 'random'\ndf$random &lt;- df$Frequency / sqrt(sum_xv)\n\n# Print the modified data frame\nprint(df)\n\n# A tibble: 5 × 4\n  Area               Frequency relFrequency random\n  &lt;chr&gt;                  &lt;dbl&gt;        &lt;dbl&gt;  &lt;dbl&gt;\n1 Accounting                73        0.289     73\n2 Finance                   52        0.206     52\n3 General management        36        0.142     36\n4 Marketing sales           64        0.253     64\n5 other                     28        0.111     28",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Working with Data I: Data Cleaning</span>"
    ]
  },
  {
    "objectID": "Data-1.html#some-pandas-tricks",
    "href": "Data-1.html#some-pandas-tricks",
    "title": "\n11  Working with Data I: Data Cleaning\n",
    "section": "\n11.3 Some Pandas Tricks",
    "text": "11.3 Some Pandas Tricks\n\n11.3.1 Renaming Variables\nFor renaming column names we use a dictionary.\n\n\n\n\n\n\nNote\n\n\n\nRemember, dictionaries are similar to lists but the indexing of the elements of a dictionary is not done with 0,1,2, etc. but we user defined keys so that a dictionary consists of key - value pairs such as:\n{'key1': value1, 'key2': value2, ... }\n\n\nIt works as follows. You see how the dictionary that you hand-in here defines the old column name as key and the new column name as the associated value.\n\n\nPython Code\nR Code\n\n\n\n\ndf = df.rename(columns={'Area': 'area', 'Frequency': 'absFrequency'})\n\nprint(df.head(3))\n\n                 area  absFrequency  relFrequency    random\n0          Accounting            73      0.288538  4.589471\n1             Finance            52      0.205534  3.269212\n2  General management            36      0.142292  2.263301\n\n\n\n\n\n# Rename columns 'Area' to 'area' and 'Frequency' to 'absFrequency'\ncolnames(df)[colnames(df) == \"Area\"] &lt;- \"area\"\ncolnames(df)[colnames(df) == \"Frequency\"] &lt;- \"absFrequency\"\n\n# Display the first 3 rows of the modified data frame\nhead(df, 3)\n\n# A tibble: 3 × 4\n  area               absFrequency relFrequency random\n  &lt;chr&gt;                     &lt;dbl&gt;        &lt;dbl&gt;  &lt;dbl&gt;\n1 Accounting                   73        0.289     73\n2 Finance                      52        0.206     52\n3 General management           36        0.142     36\n\n\n\n\n\nThe head(x) method allows us to print x rows from the top of the DataFrame, whereas the tail(x) method does the same from the bottom of the DataFrame.\n\n11.3.2 Dropping and Adding Columns\nWe next add a new column at a specific position in the DataFrame. Here it is going to be the third column and since Python indexes starting from zero, this is indicated as loc=2.\n\n\nPython Code\nR Code\n\n\n\n\n# Drop a column first so everything fits\ndf = df.drop('random', axis=1)\n\n# Create a new column with some missing values\ndf['team'] = pd.Series([2,4, np.NaN,6,10], index=df.index)\n\n# or insert new column at specific location\ndf.insert(loc=2, column='position', value=[np.NaN,1, np.NaN,1,3])\n\nprint(df)\n\n                 area  absFrequency  position  relFrequency  team\n0          Accounting            73       NaN      0.288538   2.0\n1             Finance            52       1.0      0.205534   4.0\n2  General management            36       NaN      0.142292   NaN\n3     Marketing sales            64       1.0      0.252964   6.0\n4               other            28       3.0      0.110672  10.0\n\n\n\n\nR indexes starting from one. So the third position is going to be following df[,2]:\n\n# Drop the 'random' column\ndf$random &lt;- NULL\n\n# Create a new 'team' column with missing values\ndf$team &lt;- c(2, 4, NA, 6, 10)\n\n# Insert a new 'position' column at the second position with specific values\ndf &lt;- data.frame(df[,1:2], position = c(NA, 1, NA, 1, 3), df[,3:ncol(df)])\n\n# Print the updated dataframe\nprint(df)\n\n                area absFrequency position relFrequency team\n1         Accounting           73       NA    0.2885375    2\n2            Finance           52        1    0.2055336    4\n3 General management           36       NA    0.1422925   NA\n4    Marketing sales           64        1    0.2529644    6\n5              other           28        3    0.1106719   10\n\n\n\n\n\n\n11.3.3 Missing Values of NaN's\nCount NaNs\nCount the number of rows with missing values.\n\n\nPython Code\nR Code\n\n\n\n\nnans = df.shape[0] - df.dropna().shape[0]\nprint('{} rows have missing values'.format(nans))\n\n2 rows have missing values\n\n\n\n\n\nnans &lt;- sum(rowSums(is.na(df)) &gt; 0)\ncat(nans, 'rows have missing values\\n')\n\n2 rows have missing values\n\n\n\n\n\nSelect rows with NaNs or overwrite NaNs\nIf you want to select the rows with missing values you can index them with the isnull() method.\n\n\nPython Code\nR Code\n\n\n\n\nprint(df[df.isnull().any(axis=1)])\n\n                 area  absFrequency  position  relFrequency  team\n0          Accounting            73       NaN      0.288538   2.0\n2  General management            36       NaN      0.142292   NaN\n\n\n\n\n\n# Print rows with missing values\nprint(df[apply(is.na(df), 1, any), ])\n\n                area absFrequency position relFrequency team\n1         Accounting           73       NA    0.2885375    2\n3 General management           36       NA    0.1422925   NA\n\n\n\n\n\nOr if you want to search specific columns for missing values you can do\n\n\nPython Code\nR Code\n\n\n\n\nprint(df[df['team'].isnull()])\n\n                 area  absFrequency  position  relFrequency  team\n2  General management            36       NaN      0.142292   NaN\n\n\n\n\n\n# Print rows where 'team' has missing values\nprint(df[is.na(df$team), ])\n\n                area absFrequency position relFrequency team\n3 General management           36       NA    0.1422925   NA\n\n\n\n\n\nOr if you want to grab all the rows without missing observations you can index the DataFrame with the notnull() method.\n\n\nPython Code\nR Code\n\n\n\n\nprint(df[df['team'].notnull()])\n\n              area  absFrequency  position  relFrequency  team\n0       Accounting            73       NaN      0.288538   2.0\n1          Finance            52       1.0      0.205534   4.0\n3  Marketing sales            64       1.0      0.252964   6.0\n4            other            28       3.0      0.110672  10.0\n\n\n\n\n\n# Print rows where 'team' is not null\nprint(df[!is.na(df$team), ])\n\n             area absFrequency position relFrequency team\n1      Accounting           73       NA    0.2885375    2\n2         Finance           52        1    0.2055336    4\n4 Marketing sales           64        1    0.2529644    6\n5           other           28        3    0.1106719   10\n\n\n\n\n\nDelete rows with NaNs\n\n\nPython Code\nR Code\n\n\n\n\nprint(df.dropna())\n\n              area  absFrequency  position  relFrequency  team\n1          Finance            52       1.0      0.205534   4.0\n3  Marketing sales            64       1.0      0.252964   6.0\n4            other            28       3.0      0.110672  10.0\n\n\n\n\n\n# Remove rows with missing values\ndf_temp &lt;- na.omit(df)\n\n# Print the resulting DataFrame\nprint(df_temp)\n\n             area absFrequency position relFrequency team\n2         Finance           52        1    0.2055336    4\n4 Marketing sales           64        1    0.2529644    6\n5           other           28        3    0.1106719   10\n\n\n\n\n\nYou can also reassign it to the original DataFrame or assign a new one.\n\n\nPython Code\nR Code\n\n\n\n\ndf2 = df.dropna()\nprint(df2)\n\n              area  absFrequency  position  relFrequency  team\n1          Finance            52       1.0      0.205534   4.0\n3  Marketing sales            64       1.0      0.252964   6.0\n4            other            28       3.0      0.110672  10.0\n\n\n\n\n\n# Create a new DataFrame without missing values\ndf2 &lt;- df[complete.cases(df), ]\n\n# Print the resulting DataFrame\nprint(df2)\n\n             area absFrequency position relFrequency team\n2         Finance           52        1    0.2055336    4\n4 Marketing sales           64        1    0.2529644    6\n5           other           28        3    0.1106719   10\n\n\n\n\n\nOverwriting NaN with specific values If we want to overwrite the NaN entries with values, we can use the fillna() method. In this example we replace all missing values with zeros.\n\n\nPython Code\nR Code\n\n\n\n\ndf.fillna(value=0, inplace=True)\nprint(df)\n\n                 area  absFrequency  position  relFrequency  team\n0          Accounting            73       0.0      0.288538   2.0\n1             Finance            52       1.0      0.205534   4.0\n2  General management            36       0.0      0.142292   0.0\n3     Marketing sales            64       1.0      0.252964   6.0\n4               other            28       3.0      0.110672  10.0\n\n\n\n\n\n# Replace missing values with 0\ndf[is.na(df)] &lt;- 0\n\n# Print the DataFrame\nprint(df)\n\n                area absFrequency position relFrequency team\n1         Accounting           73        0    0.2885375    2\n2            Finance           52        1    0.2055336    4\n3 General management           36        0    0.1422925    0\n4    Marketing sales           64        1    0.2529644    6\n5              other           28        3    0.1106719   10\n\n\n\n\n\n\n11.3.4 Dropping and Adding Rows to a DataFrame\nWe can use the iloc method to add empty rows to the DataFrame.\n\n\nPython Code\nR Code\n\n\n\n\ndf.loc[df.iloc[-1].name + 1,:] = np.nan\nprint(df.tail(3))\n\n              area  absFrequency  position  relFrequency  team\n3  Marketing sales          64.0       1.0      0.252964   6.0\n4            other          28.0       3.0      0.110672  10.0\n5              NaN           NaN       NaN           NaN   NaN\n\n\n\n\n\n# Create a row with missing values\nnew_row &lt;- data.frame(area = NA, absFrequency = NA, position = NA, relFrequency = NA, team = NA)\n\n# Add the new row to the DataFrame\ndf &lt;- rbind(df, new_row)\n\n# Print the last 3 rows\nprint(tail(df, 3))\n\n             area absFrequency position relFrequency team\n4 Marketing sales           64        1    0.2529644    6\n5           other           28        3    0.1106719   10\n6            &lt;NA&gt;           NA       NA           NA   NA\n\n\n\n\n\nWe can then fill this empty row with data.\n\n\nPython Code\nR Code\n\n\n\n\ndf.loc[df.index[-1], 'area'] = 'Economics'\ndf.loc[df.index[-1], 'absFrequency'] = 25\nprint(df)\n\n                 area  absFrequency  position  relFrequency  team\n0          Accounting          73.0       0.0      0.288538   2.0\n1             Finance          52.0       1.0      0.205534   4.0\n2  General management          36.0       0.0      0.142292   0.0\n3     Marketing sales          64.0       1.0      0.252964   6.0\n4               other          28.0       3.0      0.110672  10.0\n5           Economics          25.0       NaN           NaN   NaN\n\n\n\n\n\n# Update values in the last row\ndf[nrow(df), 'area'] &lt;- 'Economics'\ndf[nrow(df), 'absFrequency'] &lt;- 25\n\n# Print the updated DataFrame\nprint(df)\n\n                area absFrequency position relFrequency team\n1         Accounting           73        0    0.2885375    2\n2            Finance           52        1    0.2055336    4\n3 General management           36        0    0.1422925    0\n4    Marketing sales           64        1    0.2529644    6\n5              other           28        3    0.1106719   10\n6          Economics           25       NA           NA   NA\n\n\n\n\n\nIf you want to drop this row you can index it directly with index value 5 (i.e., row 6):\n\n\nPython Code\nR Code\n\n\n\n\nprint(df.drop(5), 0)\n\n                 area  absFrequency  position  relFrequency  team\n0          Accounting          73.0       0.0      0.288538   2.0\n1             Finance          52.0       1.0      0.205534   4.0\n2  General management          36.0       0.0      0.142292   0.0\n3     Marketing sales          64.0       1.0      0.252964   6.0\n4               other          28.0       3.0      0.110672  10.0 0\n\n\n\n\n\n# Assuming you want to drop the 6th row\ndf_temp &lt;- df[-6, ]\n\n# Print the updated DataFrame\nprint(df_temp)\n\n                area absFrequency position relFrequency team\n1         Accounting           73        0    0.2885375    2\n2            Finance           52        1    0.2055336    4\n3 General management           36        0    0.1422925    0\n4    Marketing sales           64        1    0.2529644    6\n5              other           28        3    0.1106719   10\n\n\n\n\n\nIf you want the change to be permanent you need to either use the df.drop(5, inplace=True) option or you reassign the DataFrame to itself df = df.drop(5). The default dimension for dropping data is the row in the DataFrame, so you do not need to specify the , 0 part in the drop command.\nHowever, if you drop a column, then you need the dimension specifier , 1.\n\n\n\n\n\n\nNote\n\n\n\nYou can use the pd.concat() function to append one or more than one Pandas DataFrames together. There is also a pd.append() function but it is deprecated and will be removed in future releases. So do not use it.\n\n\nPython Code\nR Code\n\n\n\n\nimport pandas as pd\n\n#create three DataFrames\ndf1 = pd.DataFrame({'x': [10, 11, 12],\n                    'y': [20, 21, 22]})\n\ndf2 = pd.DataFrame({'x': [30, 31, 32],\n                    'y': [40, 41, 42]})\n\ndf3 = pd.DataFrame({'x': [50, 51, 52],\n                    'y': [60, 61, 62]})\n\n# Append all three DataFrames together\ncombined = pd.concat([df1, df2, df3], ignore_index=True)\n\n# View final DataFrame\nprint(combined)\n\n    x   y\n0  10  20\n1  11  21\n2  12  22\n3  30  40\n4  31  41\n5  32  42\n6  50  60\n7  51  61\n8  52  62\n\n\n\n\n\n# Create three data frames\ndf1 &lt;- data.frame(x = c(10, 11, 12), y = c(20, 21, 22))\ndf2 &lt;- data.frame(x = c(30, 31, 32), y = c(40, 41, 42))\ndf3 &lt;- data.frame(x = c(50, 51, 52), y = c(60, 61, 62))\n\n# Combine all three data frames\ncombined &lt;- rbind(df1, df2, df3)\n\n# View the final data frame\nprint(combined)\n\n   x  y\n1 10 20\n2 11 21\n3 12 22\n4 30 40\n5 31 41\n6 32 42\n7 50 60\n8 51 61\n9 52 62\n\n\n\n\n\nIf we didn’t use the ignore_index argument, the index of the resulting DataFrame would retain the original index values for each individual DataFrame:\n\n\nPython Code\nR Code\n\n\n\n\n# Append all three DataFrames together\ncombined = pd.concat([df1, df2, df3])\n\n# View final DataFrame\nprint(combined)\n\n    x   y\n0  10  20\n1  11  21\n2  12  22\n0  30  40\n1  31  41\n2  32  42\n0  50  60\n1  51  61\n2  52  62\n\n\n\n\n\n# Create three data frames\ndf1 &lt;- data.frame(x = c(10, 11, 12), y = c(20, 21, 22))\ndf2 &lt;- data.frame(x = c(30, 31, 32), y = c(40, 41, 42))\ndf3 &lt;- data.frame(x = c(50, 51, 52), y = c(60, 61, 62))\n\n# Append all three data frames together\ncombined &lt;- rbind(df1, df2, df3)\n\n# View the final data frame\nprint(combined)\n\n   x  y\n1 10 20\n2 11 21\n3 12 22\n4 30 40\n5 31 41\n6 32 42\n7 50 60\n8 51 61\n9 52 62\n\n\n\n\n\n\n\n\n11.3.5 Dropping Rows Based on Conditions\nBefore running a regression, a researcher might like to drop certain observations that are clearly not correct such as negative age observations for instance.\nLet us assume that in our current DataFrame we have information that tells us that a position variable must be strictly positive and cannot be zero. This would mean that row 0 and row 2 would need to be dropped from our DataFrame.\nBefore we mess up our DataFrame, let's make a new one and then drop row 0 and 2 based on the value condition of variable position.\n\n\nPython Code\nR Code\n\n\n\n\ndf_temp = df\n\nprint(df_temp)\n\n                 area  absFrequency  position  relFrequency  team\n0          Accounting          73.0       0.0      0.288538   2.0\n1             Finance          52.0       1.0      0.205534   4.0\n2  General management          36.0       0.0      0.142292   0.0\n3     Marketing sales          64.0       1.0      0.252964   6.0\n4               other          28.0       3.0      0.110672  10.0\n5           Economics          25.0       NaN           NaN   NaN\n\n\n\n\n\ndf_temp &lt;- df\n\n# View the copied data frame\nprint(df_temp)\n\n                area absFrequency position relFrequency team\n1         Accounting           73        0    0.2885375    2\n2            Finance           52        1    0.2055336    4\n3 General management           36        0    0.1422925    0\n4    Marketing sales           64        1    0.2529644    6\n5              other           28        3    0.1106719   10\n6          Economics           25       NA           NA   NA\n\n\n\n\n\nNow drop the rows with a position variable value of zero or less.\n\n\nPython Code\nR Code\n\n\n\n\ndf_temp = df_temp[df_temp['position']&gt;0]\nprint(df_temp)\n\n              area  absFrequency  position  relFrequency  team\n1          Finance          52.0       1.0      0.205534   4.0\n3  Marketing sales          64.0       1.0      0.252964   6.0\n4            other          28.0       3.0      0.110672  10.0\n\n\n\n\n\ndf_temp &lt;- subset(df_temp, position &gt; 0)\n\n# View the filtered data frame\nprint(df_temp)\n\n             area absFrequency position relFrequency team\n2         Finance           52        1    0.2055336    4\n4 Marketing sales           64        1    0.2529644    6\n5           other           28        3    0.1106719   10\n\n\n\n\n\nAs you can see we accomplished this by \"keeping\" the observations for which the position value is strictly positive as opposed to \"dropping\" the negative ones.\nAnd also let's make sure that the original DataFrame is still what it was.\n\n\nPython Code\nR Code\n\n\n\n\nprint(df)\n\n                 area  absFrequency  position  relFrequency  team\n0          Accounting          73.0       0.0      0.288538   2.0\n1             Finance          52.0       1.0      0.205534   4.0\n2  General management          36.0       0.0      0.142292   0.0\n3     Marketing sales          64.0       1.0      0.252964   6.0\n4               other          28.0       3.0      0.110672  10.0\n5           Economics          25.0       NaN           NaN   NaN\n\n\n\n\n\nprint(df)\n\n                area absFrequency position relFrequency team\n1         Accounting           73        0    0.2885375    2\n2            Finance           52        1    0.2055336    4\n3 General management           36        0    0.1422925    0\n4    Marketing sales           64        1    0.2529644    6\n5              other           28        3    0.1106719   10\n6          Economics           25       NA           NA   NA\n\n\n\n\n\n\n11.3.6 Sorting and Reindexing DataFrames\nWe next sort the DataFrame by a certain column (from highest to lowest) using the sort_values() DataFrame method.\n\n\n\n\n\n\nWarning\n\n\n\nThe old pandas method/function .sort() was replaced with .sort_values() and does not work anymore in newer versions of pandas.\n\n\n\n\nPython Code\nR Code\n\n\n\n\ndf.sort_values('absFrequency', ascending=False, inplace=True)\nprint(df)\n\n                 area  absFrequency  position  relFrequency  team\n0          Accounting          73.0       0.0      0.288538   2.0\n3     Marketing sales          64.0       1.0      0.252964   6.0\n1             Finance          52.0       1.0      0.205534   4.0\n2  General management          36.0       0.0      0.142292   0.0\n4               other          28.0       3.0      0.110672  10.0\n5           Economics          25.0       NaN           NaN   NaN\n\n\n\n\n\n# Sort the data frame by 'absFrequency' in descending order\ndf &lt;- df[order(-df$absFrequency), ]\n\n# View the sorted data frame\nprint(df)\n\n                area absFrequency position relFrequency team\n1         Accounting           73        0    0.2885375    2\n4    Marketing sales           64        1    0.2529644    6\n2            Finance           52        1    0.2055336    4\n3 General management           36        0    0.1422925    0\n5              other           28        3    0.1106719   10\n6          Economics           25       NA           NA   NA\n\n\n\n\n\nThe inplace=True option will immediately overwrite the DataFrame df with the new, sorted, one. If you set inplace=False you would have to assign a new DataFrame in order to see the changes:\n\n\nPython Code\nR Code\n\n\n\ndf1 = df.sort_values('absFrequency', ascending=False, inplace=False)\n\n\n\n# Sort the data frame by 'absFrequency' in descending order\ndf1 &lt;- df[order(-df$absFrequency), ]\n\n\n\n\nWhere df1 would now be the sorted DataFrame and the original df DataFrame would still be unsorted.\n\n\n\n\n\n\nNote\n\n\n\nHowever, we now have two objects with identical data in it. This is often redundant and can eventually become a memory problem if the DataFrames are very large. Setting inplace=True is probably a good default setting.\n\n\nIf we want we could then reindex the DataFrame according to the new sort order.\n\n\nPython Code\nR Code\n\n\n\n\ndf.index = range(len(df.index))\nprint(df)\n\n                 area  absFrequency  position  relFrequency  team\n0          Accounting          73.0       0.0      0.288538   2.0\n1     Marketing sales          64.0       1.0      0.252964   6.0\n2             Finance          52.0       1.0      0.205534   4.0\n3  General management          36.0       0.0      0.142292   0.0\n4               other          28.0       3.0      0.110672  10.0\n5           Economics          25.0       NaN           NaN   NaN\n\n\n\n\n\n# Reset the row names or row indices\nrownames(df) &lt;- NULL\nprint(df)\n\n                area absFrequency position relFrequency team\n1         Accounting           73        0    0.2885375    2\n2    Marketing sales           64        1    0.2529644    6\n3            Finance           52        1    0.2055336    4\n4 General management           36        0    0.1422925    0\n5              other           28        3    0.1106719   10\n6          Economics           25       NA           NA   NA",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Working with Data I: Data Cleaning</span>"
    ]
  },
  {
    "objectID": "Data-1.html#merging-dataframes-or-adding-columns",
    "href": "Data-1.html#merging-dataframes-or-adding-columns",
    "title": "\n11  Working with Data I: Data Cleaning\n",
    "section": "\n11.4 Merging DataFrames or Adding Columns",
    "text": "11.4 Merging DataFrames or Adding Columns\nLet us create a new DataFrame that has the variable team in common with the previous DataFrame. This new DataFrame contains additional team information that we would like to merge into the original DataFrame.\nFirst redefine the original DataFrame:\n\n\nPython Code\nR Code\n\n\n\n\ndf= pd.DataFrame({'area': ['Accounting','Marketing','Finance','Management', 'other'],\\\n                  'absFrequency': [73,64,52,36,28], \\\n                  'position': [0,1,1,0,3], \\\n                  'relFrequency': [0.28,0.25,0.20,0.14,0.11], \\\n                  'team': [2,6,4,0,10]})\n\nprint(df)\n\n         area  absFrequency  position  relFrequency  team\n0  Accounting            73         0          0.28     2\n1   Marketing            64         1          0.25     6\n2     Finance            52         1          0.20     4\n3  Management            36         0          0.14     0\n4       other            28         3          0.11    10\n\n\n\n\n\n# Create the data frame\ndf &lt;- data.frame(\n  area = c('Accounting', 'Marketing', 'Finance', 'Management', 'other'),\n  absFrequency = c(73, 64, 52, 36, 28),\n  position = c(0, 1, 1, 0, 3),\n  relFrequency = c(0.28, 0.25, 0.20, 0.14, 0.11),\n  team = c(2, 6, 4, 0, 10)\n)\n\nprint(df)\n\n        area absFrequency position relFrequency team\n1 Accounting           73        0         0.28    2\n2  Marketing           64        1         0.25    6\n3    Finance           52        1         0.20    4\n4 Management           36        0         0.14    0\n5      other           28        3         0.11   10\n\n\n\n\n\nSecond, we define the new DataFrame and add some values to it:\n\n\nPython Code\nR Code\n\n\n\n\ndf_team = pd.DataFrame({'team': [3,4,5,6,7,8,9,10], \\\n                        'sales': [500,300,250,450,345,123,432,890]})\n\nprint(df_team)\n\n   team  sales\n0     3    500\n1     4    300\n2     5    250\n3     6    450\n4     7    345\n5     8    123\n6     9    432\n7    10    890\n\n\n\n\n\n# Create the data frame\ndf_team &lt;- data.frame(\n  team = c(3, 4, 5, 6, 7, 8, 9, 10),\n  sales = c(500, 300, 250, 450, 345, 123, 432, 890)\n)\n\nprint(df_team)\n\n  team sales\n1    3   500\n2    4   300\n3    5   250\n4    6   450\n5    7   345\n6    8   123\n7    9   432\n8   10   890\n\n\n\n\n\nThis new DataFrame contains some sales information for each team.\nBefore we merge in the new info we drop the area column so that the DataFrame fits on the screen. We now work with the following two DataFrames.\n\n\nPython Code\nR Code\n\n\n\n\ndf = df.drop('area', axis=1)\nprint('-----------------------------')\nprint('First, main,  DataFrame: LEFT')\nprint('-----------------------------')\nprint(df)\nprint('')\nprint('-----------------------------')\nprint('Second new DataFrame: RIGHT')\nprint('-----------------------------')\nprint(df_team)\n\n-----------------------------\nFirst, main,  DataFrame: LEFT\n-----------------------------\n   absFrequency  position  relFrequency  team\n0            73         0          0.28     2\n1            64         1          0.25     6\n2            52         1          0.20     4\n3            36         0          0.14     0\n4            28         3          0.11    10\n\n-----------------------------\nSecond new DataFrame: RIGHT\n-----------------------------\n   team  sales\n0     3    500\n1     4    300\n2     5    250\n3     6    450\n4     7    345\n5     8    123\n6     9    432\n7    10    890\n\n\n\n\n\n# Remove the 'area' column from the df data frame\ndf &lt;- df[, -which(names(df) == 'area')]\n\n# Display the 'df' data frame\ncat('-----------------------------\\n')\ncat('First, main,  DataFrame: LEFT\\n')\ncat('-----------------------------\\n')\nprint(df)\ncat('\\n')\n\n# Display the 'df_team' data frame\ncat('-----------------------------\\n')\ncat('Second new DataFrame: RIGHT\\n')\ncat('-----------------------------\\n')\nprint(df_team)\n\n-----------------------------\nFirst, main,  DataFrame: LEFT\n-----------------------------\n  absFrequency position relFrequency team\n1           73        0         0.28    2\n2           64        1         0.25    6\n3           52        1         0.20    4\n4           36        0         0.14    0\n5           28        3         0.11   10\n\n-----------------------------\nSecond new DataFrame: RIGHT\n-----------------------------\n  team sales\n1    3   500\n2    4   300\n3    5   250\n4    6   450\n5    7   345\n6    8   123\n7    9   432\n8   10   890\n\n\n\n\n\nWhen merging two DataFrames we need to find a common variable that appears in both DataFrames along which we can connect them. In our example we use the team column as merge-key or key-variable because it appears in both DataFrames. We have now four different options for merging the two DataFrames.\n\n\n\n\n\nMerge Options\nMerge OptionsInner Merge\nInner MergeMerge Options-&gt;Inner Merge\nLeft Merge\nLeft MergeMerge Options-&gt;Left Merge\nRight Merge\nRight MergeMerge Options-&gt;Right Merge\nOuter Merge\nOuter MergeMerge Options-&gt;Outer Merge\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nMerge Summary\n\nThe inner merge only keeps observations that are present in both DataFrames.\nThe left merge keeps all of the observations of the original (or main DataFrame) and adds the new information on the left if available.\nThe right merge only keeps info from the new DataFrame and adds the info of the original main DataFrame.\nThe outer merge method merges by team whenever possible but keeps the info from both DataFrames, even for observations where no merge/overlap occurred.\n\n\n\nNow we do it step my step. Inner merge first. As you will see now, the inner merge only keeps observations that are present in both DataFrames. This is often too restrictive as many observations will be dropped.\n\n\nPython Code\nR Code\n\n\n\n\nprint('Inner Merge')\nprint('-----------')\nprint(pd.merge(df, df_team, on='team', how='inner'))\n\nInner Merge\n-----------\n   absFrequency  position  relFrequency  team  sales\n0            64         1          0.25     6    450\n1            52         1          0.20     4    300\n2            28         3          0.11    10    890\n\n\n\n\n\n# Inner Merge\ncat('Inner Merge\\n')\ncat('-----------\\n')\ninner_merged &lt;- merge(df, df_team, by='team', all=FALSE)\nprint(inner_merged)\n\nInner Merge\n-----------\n  team absFrequency position relFrequency sales\n1    4           52        1         0.20   300\n2    6           64        1         0.25   450\n3   10           28        3         0.11   890\n\n\n\n\n\nThe left merge keeps the original (or main DataFrame) and adds the new information on the left. When it cannot find a team number in the main DataFrame it simply drops the info from the new DataFrame.\n\n\nPython Code\nR Code\n\n\n\n\nprint('Left Merge')\nprint('----------')\nprint(pd.merge(df, df_team, on='team', how='left'))\n\nLeft Merge\n----------\n   absFrequency  position  relFrequency  team  sales\n0            73         0          0.28     2    NaN\n1            64         1          0.25     6  450.0\n2            52         1          0.20     4  300.0\n3            36         0          0.14     0    NaN\n4            28         3          0.11    10  890.0\n\n\n\n\n\n# Left Merge\ncat('Left Merge\\n')\ncat('----------\\n')\nleft_merged &lt;- merge(df, df_team, by='team', all.x=TRUE)\nprint(left_merged)\n\nLeft Merge\n----------\n  team absFrequency position relFrequency sales\n1    0           36        0         0.14    NA\n2    2           73        0         0.28    NA\n3    4           52        1         0.20   300\n4    6           64        1         0.25   450\n5   10           28        3         0.11   890\n\n\n\n\n\nThe right merge only keeps info from the new DataFrame and adds the info of the original main DataFrame.\n\n\nPython Code\nR Code\n\n\n\n\nprint('Right Merge')\nprint('-----------')\nprint(pd.merge(df, df_team, on='team', how='right'))\n\nRight Merge\n-----------\n   absFrequency  position  relFrequency  team  sales\n0           NaN       NaN           NaN     3    500\n1          52.0       1.0          0.20     4    300\n2           NaN       NaN           NaN     5    250\n3          64.0       1.0          0.25     6    450\n4           NaN       NaN           NaN     7    345\n5           NaN       NaN           NaN     8    123\n6           NaN       NaN           NaN     9    432\n7          28.0       3.0          0.11    10    890\n\n\n\n\n\n# Right Merge\ncat('Right Merge\\n')\ncat('-----------\\n')\nright_merged &lt;- merge(df, df_team, by='team', all.y=TRUE)\nprint(right_merged)\n\nRight Merge\n-----------\n  team absFrequency position relFrequency sales\n1    3           NA       NA           NA   500\n2    4           52        1         0.20   300\n3    5           NA       NA           NA   250\n4    6           64        1         0.25   450\n5    7           NA       NA           NA   345\n6    8           NA       NA           NA   123\n7    9           NA       NA           NA   432\n8   10           28        3         0.11   890\n\n\n\n\n\nThe outer merge method merges by team whenever possible but keeps the info from both DataFrames, even for observations where no merge/overlap occurred.\n\n\nPython Code\nR Code\n\n\n\n\nprint('Outer Merge')\nprint('-----------')\nprint(pd.merge(df, df_team, on='team', how='outer'))\n\nOuter Merge\n-----------\n   absFrequency  position  relFrequency  team  sales\n0          73.0       0.0          0.28     2    NaN\n1          64.0       1.0          0.25     6  450.0\n2          52.0       1.0          0.20     4  300.0\n3          36.0       0.0          0.14     0    NaN\n4          28.0       3.0          0.11    10  890.0\n5           NaN       NaN           NaN     3  500.0\n6           NaN       NaN           NaN     5  250.0\n7           NaN       NaN           NaN     7  345.0\n8           NaN       NaN           NaN     8  123.0\n9           NaN       NaN           NaN     9  432.0\n\n\n\n\n\n# Outer Merge\ncat('Outer Merge\\n')\ncat('-----------\\n')\nouter_merged &lt;- merge(df, df_team, by='team', all=TRUE)\nprint(outer_merged)\n\nOuter Merge\n-----------\n   team absFrequency position relFrequency sales\n1     0           36        0         0.14    NA\n2     2           73        0         0.28    NA\n3     3           NA       NA           NA   500\n4     4           52        1         0.20   300\n5     5           NA       NA           NA   250\n6     6           64        1         0.25   450\n7     7           NA       NA           NA   345\n8     8           NA       NA           NA   123\n9     9           NA       NA           NA   432\n10   10           28        3         0.11   890",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Working with Data I: Data Cleaning</span>"
    ]
  },
  {
    "objectID": "Data-1.html#converting-types-and-replacing-values-in-dataframes",
    "href": "Data-1.html#converting-types-and-replacing-values-in-dataframes",
    "title": "\n11  Working with Data I: Data Cleaning\n",
    "section": "\n11.5 Converting Types and Replacing Values in DataFrames",
    "text": "11.5 Converting Types and Replacing Values in DataFrames\n\n11.5.1 Converting Column Types\nWhen converting text into a DataFrame to conduct statistical analysis it is sometimes necessary to convert a numbers column that is still a string, into floats, so that we can do math. Let's drop some more columns first so the DataFrame fits nicely in the output window.\n\n\nPython Code\nR Code\n\n\n\n\ndf = df.drop('absFrequency', axis=1)\n# Let's have a look at it, it's a nested list\nprint(df)\n\n   position  relFrequency  team\n0         0          0.28     2\n1         1          0.25     6\n2         1          0.20     4\n3         0          0.14     0\n4         3          0.11    10\n\n\n\n\n\n# Drop 'absFrequency' column\ndf$absFrequency &lt;- NULL\n\n# Print the data frame\nprint(df)\n\n  position relFrequency team\n1        0         0.28    2\n2        1         0.25    6\n3        1         0.20    4\n4        0         0.14    0\n5        3         0.11   10\n\n\n\n\n\nWe now generate a column of \"words\" or \"strings\" that happen do be numbers. Since they are defined as words, we cannot run statistical analysis on these numbers yet.\n\n\nPython Code\nR Code\n\n\n\n\ndf['string'] = pd.Series(['2','40','34','6','10'], index=df.index)\n\n# Print DataFrame\nprint(df)\n\n# Print summary statistics\nprint(df.describe())\n\n   position  relFrequency  team string\n0         0          0.28     2      2\n1         1          0.25     6     40\n2         1          0.20     4     34\n3         0          0.14     0      6\n4         3          0.11    10     10\n       position  relFrequency       team\ncount  5.000000      5.000000   5.000000\nmean   1.000000      0.196000   4.400000\nstd    1.224745      0.071624   3.847077\nmin    0.000000      0.110000   0.000000\n25%    0.000000      0.140000   2.000000\n50%    1.000000      0.200000   4.000000\n75%    1.000000      0.250000   6.000000\nmax    3.000000      0.280000  10.000000\n\n\n\n\n\n# Add a new column named 'string' to your data frame\ndf$string &lt;- c('2', '40', '34', '6', '10')\n\n# Print the updated data frame\nprint(df)\n\n# Print summary statistics for the numeric columns\nsummary(df)\n\n  position relFrequency team string\n1        0         0.28    2      2\n2        1         0.25    6     40\n3        1         0.20    4     34\n4        0         0.14    0      6\n5        3         0.11   10     10\n    position  relFrequency        team         string         \n Min.   :0   Min.   :0.110   Min.   : 0.0   Length:5          \n 1st Qu.:0   1st Qu.:0.140   1st Qu.: 2.0   Class :character  \n Median :1   Median :0.200   Median : 4.0   Mode  :character  \n Mean   :1   Mean   :0.196   Mean   : 4.4                     \n 3rd Qu.:1   3rd Qu.:0.250   3rd Qu.: 6.0                     \n Max.   :3   Max.   :0.280   Max.   :10.0                     \n\n\n\n\n\nWe first need to reassign the data type of the string column. We then rename the column and print summary statistics.\n\n\nPython Code\nR Code\n\n\n\n\n# Transform strings into floats, i.e., words into numbers\ndf['string'] = df['string'].astype(float)\n\n# Rename the column\ndf = df.rename(columns={'string': 'salary'})\n\n# Print summary statistics\nprint(df.describe())\n\n       position  relFrequency       team     salary\ncount  5.000000      5.000000   5.000000   5.000000\nmean   1.000000      0.196000   4.400000  18.400000\nstd    1.224745      0.071624   3.847077  17.343587\nmin    0.000000      0.110000   0.000000   2.000000\n25%    0.000000      0.140000   2.000000   6.000000\n50%    1.000000      0.200000   4.000000  10.000000\n75%    1.000000      0.250000   6.000000  34.000000\nmax    3.000000      0.280000  10.000000  40.000000\n\n\n\n\n\n# Transform strings into numbers\ndf$salary &lt;- as.numeric(as.character(df$string))\n\n# Rename the column\ncolnames(df)[colnames(df) == 'string'] &lt;- 'salary'\n\n# Print summary statistics for the numeric columns\nsummary(df)\n\n    position  relFrequency        team         salary              salary    \n Min.   :0   Min.   :0.110   Min.   : 0.0   Length:5           Min.   : 2.0  \n 1st Qu.:0   1st Qu.:0.140   1st Qu.: 2.0   Class :character   1st Qu.: 6.0  \n Median :1   Median :0.200   Median : 4.0   Mode  :character   Median :10.0  \n Mean   :1   Mean   :0.196   Mean   : 4.4                      Mean   :18.4  \n 3rd Qu.:1   3rd Qu.:0.250   3rd Qu.: 6.0                      3rd Qu.:34.0  \n Max.   :3   Max.   :0.280   Max.   :10.0                      Max.   :40.0  \n\n\n\n\n\n\n11.5.2 Replacing Values in a DataFrame Conditional on Criteria\nIf we need to replace values in a DataFrame based on certain criteria it is often more efficient to use indexing as opposed to loops. Let us first create a DataFrame with some random values:\n\n\nPython Code\nR Code\n\n\n\n\ndf1 = pd.DataFrame(np.random.rand(10,5)*100)\nprint(df1)\n\n           0          1          2          3          4\n0  21.651551  20.045638  33.662727  93.198514  86.568045\n1  90.834640  10.420275  14.093457  14.044287  14.252533\n2   3.306218  46.425814  87.380927  11.623223  31.251596\n3   3.830065  41.256834  23.384440  24.823248   5.872269\n4   9.606805  58.170679  91.473171   2.374509  61.006675\n5  16.074765  33.722850  16.766003  49.042524  28.847451\n6  32.572317  54.522931  91.582778   9.422688  88.284203\n7  37.438779  78.856242   5.942955  34.583682  94.225941\n8  94.182952  87.189188  38.605325  84.628497  30.175344\n9  78.336114  16.287495  19.028794  87.068721  58.704766\n\n\n\n\n\n# Set a seed for reproducibility\nset.seed(123)\n\n# Create a data frame with random numbers\ndf1 &lt;- as.data.frame(matrix(runif(50, min = 0, max = 100), nrow = 10))\n\n# Print the data frame\nprint(df1)\n\n         V1        V2       V3        V4       V5\n1  28.75775 95.683335 88.95393 96.302423 14.28000\n2  78.83051 45.333416 69.28034 90.229905 41.45463\n3  40.89769 67.757064 64.05068 69.070528 41.37243\n4  88.30174 57.263340 99.42698 79.546742 36.88455\n5  94.04673 10.292468 65.57058  2.461368 15.24447\n6   4.55565 89.982497 70.85305 47.779597 13.88061\n7  52.81055 24.608773 54.40660 75.845954 23.30341\n8  89.24190  4.205953 59.41420 21.640794 46.59625\n9  55.14350 32.792072 28.91597 31.818101 26.59726\n10 45.66147 95.450365 14.71136 23.162579 85.78277\n\n\n\n\n\nWe next replace all the values in column 2 that are smaller than 30 with the string Low.\n\n\nPython Code\nR Code\n\n\n\n\ndf1[1][(df1[1]&lt;30)] = 'Low'\nprint(df1)\n\n           0          1          2          3          4\n0  21.651551        Low  33.662727  93.198514  86.568045\n1  90.834640        Low  14.093457  14.044287  14.252533\n2   3.306218  46.425814  87.380927  11.623223  31.251596\n3   3.830065  41.256834  23.384440  24.823248   5.872269\n4   9.606805  58.170679  91.473171   2.374509  61.006675\n5  16.074765   33.72285  16.766003  49.042524  28.847451\n6  32.572317  54.522931  91.582778   9.422688  88.284203\n7  37.438779  78.856242   5.942955  34.583682  94.225941\n8  94.182952  87.189188  38.605325  84.628497  30.175344\n9  78.336114        Low  19.028794  87.068721  58.704766\n\n\n\n\n\n# Create a data frame with random numbers\ndf1 &lt;- as.data.frame(matrix(runif(50, min = 0, max = 100), nrow = 10))\n\n# Set values less than 30 in the first column to 'Low'\ndf1[df1[,2] &lt; 30, 2] &lt;- 'Low'\n\n# Print the data frame\nprint(df1)\n\n          V1               V2          V3       V4        V5\n1   4.583117 66.5115194628015 75.44751586 24.36195 13.069569\n2  44.220007              Low 62.92211316 66.80556 65.310193\n3  79.892485 38.3969637798145 71.01824014 41.76468 34.351647\n4  12.189926              Low  0.06247733 78.81958 65.675813\n5  56.094798 81.4640038879588 47.53165741 10.28646 32.037324\n6  20.653139 44.8516341391951 22.01188852 43.48927 18.769112\n7  12.753165 81.0064353048801 37.98165377 98.49570 78.229430\n8  75.330786 81.2389509519562 61.27710033 89.30511  9.359499\n9  89.504536 79.4342321110889 35.17979092 88.64691 46.677904\n10 37.446278 43.9831687603146 11.11354243 17.50527 51.150546\n\n\n\n\n\nWe next replace all the values of column 4 that are larger than 70 with the value 1000.\n\n\nPython Code\nR Code\n\n\n\n\ndf1.loc[(df1[3]&gt;70), 3] = 1000\nprint(df1)\n\n           0          1          2            3          4\n0  21.651551        Low  33.662727  1000.000000  86.568045\n1  90.834640        Low  14.093457    14.044287  14.252533\n2   3.306218  46.425814  87.380927    11.623223  31.251596\n3   3.830065  41.256834  23.384440    24.823248   5.872269\n4   9.606805  58.170679  91.473171     2.374509  61.006675\n5  16.074765   33.72285  16.766003    49.042524  28.847451\n6  32.572317  54.522931  91.582778     9.422688  88.284203\n7  37.438779  78.856242   5.942955    34.583682  94.225941\n8  94.182952  87.189188  38.605325  1000.000000  30.175344\n9  78.336114        Low  19.028794  1000.000000  58.704766\n\n\n\n\n\n# Create a data frame with random numbers\ndf1 &lt;- as.data.frame(matrix(runif(50, min = 0, max = 100), nrow = 10))\n\n# Set values greater than 70 in the fourth column to 1000\ndf1[df1[,4] &gt; 70, 4] &lt;- 1000\n\n# Print the data frame\nprint(df1)\n\n         V1        V2       V3         V4        V5\n1  59.99890 93.529980 64.78935   61.92565 31.170220\n2  33.28235 30.122890 31.98206 1000.00000 40.947495\n3  48.86130  6.072057 30.77200   67.29991  1.046711\n4  95.44738 94.772694 21.97676 1000.00000 18.384952\n5  48.29024 72.059627 36.94889   52.11357 84.272932\n6  89.03502 14.229430 98.42192   65.98384 23.116178\n7  91.44382 54.928466 15.42023 1000.00000 23.909996\n8  60.87350 95.409124  9.10440 1000.00000  7.669117\n9  41.06898 58.548335 14.19069 1000.00000 24.572368\n10 14.70947 40.451028 69.00071   43.94315 73.213521\n\n\n\n\n\nAnd finally we can combine logical statements and replace values on a combination of conditions. So let's replace all the values in column 5 that are between 20 and 80 with the string middle.\n\n\nPython Code\nR Code\n\n\n\n\ndf1.loc[((df1[4]&gt;20) & (df1[4]&lt;80)), 4] = 'Middle'\nprint(df1)\n\n           0          1          2            3          4\n0  21.651551        Low  33.662727  1000.000000  86.568045\n1  90.834640        Low  14.093457    14.044287  14.252533\n2   3.306218  46.425814  87.380927    11.623223     Middle\n3   3.830065  41.256834  23.384440    24.823248   5.872269\n4   9.606805  58.170679  91.473171     2.374509     Middle\n5  16.074765   33.72285  16.766003    49.042524     Middle\n6  32.572317  54.522931  91.582778     9.422688  88.284203\n7  37.438779  78.856242   5.942955    34.583682  94.225941\n8  94.182952  87.189188  38.605325  1000.000000     Middle\n9  78.336114        Low  19.028794  1000.000000     Middle\n\n\n\n\n\n# Create a data frame with random numbers\ndf1 &lt;- as.data.frame(matrix(runif(50, min = 0, max = 100), nrow = 10))\n\n# Set values in the fourth column between 20 and 80 to 'Middle'\ndf1[df1[,5] &gt; 20 & df1[,5] &lt; 80, 5] &lt;- 'Middle'\n\n# Print the data frame\nprint(df1)\n\n         V1       V2       V3       V4               V5\n1  84.74532 50.22996 62.99731 83.97678           Middle\n2  49.75273 35.39046 18.38285 31.24482           Middle\n3  38.79090 64.99852 86.36441 70.82903 98.5640884377062\n4  24.64490 37.47140 74.65680 26.50178           Middle\n5  11.10965 35.54454 66.82846 59.43432 93.7314089154825\n6  38.99944 53.36879 61.80179 48.12898           Middle\n7  57.19353 74.03344 37.22381 26.50327           Middle\n8  21.68928 22.11029 52.98357 56.45904           Middle\n9  44.47680 41.27461 87.46823 91.31882 15.2346616843715\n10 21.79907 26.56867 58.17501 90.18744           Middle\n\n\n\n\n\n\n\n\n\n\n\nKey Concepts and Summary\n\n\n\n\nDataFrames\nCleaning data\n\n\n\n\n\n\n\n\n\nSelf-check questions\n\n\n\n\n\n\nDownload data\nMake a new column with a new variable\nSort the DataFrame with respect to value in the third column",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Working with Data I: Data Cleaning</span>"
    ]
  },
  {
    "objectID": "Data-2.html",
    "href": "Data-2.html",
    "title": "\n12  Working with Data II: Statistics\n",
    "section": "",
    "text": "12.1 Importing Data\nWe will be working with three data sets. Lecture_Data_Excel_a.csv &lt;Lecture_Data/Lecture_Data_Excel_a.csv&gt;. Lecture_Data_Excel_b.csv &lt;Lecture_Data/Lecture_Data_Excel_b.csv&gt;. Lecture_Data_Excel_c.xlsx &lt;Lecture_Data/Lecture_Data_Excel_c.xlsx&gt;.\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport statsmodels.api as sm\n#from ggplot import *\nfrom scipy import stats as st\nimport math as m\nimport seaborn as sns\nimport time  # Imports system time module to time your script\n\nplt.close('all')  # close all open figures\nLet us now have a look at the dataframe to see what we have got.\nWe have data on field of study in the column Area and we have absolute frequences that tell us how many students study in those areas. We next form relative frequencies by dividing the absolute frequencies by the total number of students. We put the results in a new column called relFrequency.\nWe can now interact with the DataFrame. Let us first simply \"grab\" the relative frequencies out of the DataFrame into a numpy array. This is now simply a numerical vector that you have already worked with in previous chapters.",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Working with Data II: Statistics</span>"
    ]
  },
  {
    "objectID": "Data-2.html#importing-data",
    "href": "Data-2.html#importing-data",
    "title": "\n12  Working with Data II: Statistics\n",
    "section": "",
    "text": "Python Code\nR Code\n\n\n\n\n# Read in small data from .csv file\n# Filepath\nfilepath = 'Lecture_Data/'\n# In windows you can also specify the absolute path to your data file\n# filepath = 'C:/Dropbox/Towson/Teaching/3_ComputationalEconomics/Lectures/Lecture_Data/'\n\n# ------------- Load data --------------------\ndf = pd.read_csv(filepath + 'Lecture_Data_Excel_a.csv', dtype={'Frequency': float})\n\ndf = df.drop('Unnamed: 2', axis=1)\ndf = df.drop('Unnamed: 3', axis=1)\n\n\n\n\n# Filepath\nfilepath &lt;- 'Lecture_Data/'\n# In Windows, you can also specify the absolute path to your data file\n# filepath &lt;- 'C:/Dropbox/Towson/Teaching/3_ComputationalEconomics/Lectures/Lecture_Data/'\n\n# Load data\n\ndf &lt;- read.csv(paste0(filepath, 'Lecture_Data_Excel_a.csv'))\n\nprint(df)\n\n                Area Frequency  X X.1\n1         Accounting        73 NA  NA\n2            Finance        52 NA  NA\n3 General management        36 NA  NA\n4    Marketing sales        64 NA  NA\n5              other        28 NA  NA\n\n# Remove columns 'Unnamed: 2' and 'Unnamed: 3'\ndf &lt;- df[, !(names(df) %in% c('X', 'X.1'))]\n\nprint(df)\n\n                Area Frequency\n1         Accounting        73\n2            Finance        52\n3 General management        36\n4    Marketing sales        64\n5              other        28\n\n\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nprint(df)\n\n                 Area  Frequency\n0          Accounting       73.0\n1             Finance       52.0\n2  General management       36.0\n3     Marketing sales       64.0\n4               other       28.0\n\n\n\n\n\nprint(df)\n\n                Area Frequency\n1         Accounting        73\n2            Finance        52\n3 General management        36\n4    Marketing sales        64\n5              other        28\n\n\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\n# Make new column with relative frequency\ndf['relFrequency'] = df['Frequency']/df['Frequency'].sum()\n# Let's have a look at it, it's a nested list\nprint(df)\n\n                 Area  Frequency  relFrequency\n0          Accounting       73.0      0.288538\n1             Finance       52.0      0.205534\n2  General management       36.0      0.142292\n3     Marketing sales       64.0      0.252964\n4               other       28.0      0.110672\n\n\n\n\n\n# Make a new column with relative frequency\ndf$relFrequency &lt;- df$Frequency / sum(df$Frequency)\n\n# Let's have a look at the data frame\nprint(df)\n\n                Area Frequency relFrequency\n1         Accounting        73    0.2885375\n2            Finance        52    0.2055336\n3 General management        36    0.1422925\n4    Marketing sales        64    0.2529644\n5              other        28    0.1106719\n\n\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nxv = df['relFrequency'].values\nprint('Array xv is:', xv)\n\nArray xv is: [0.28853755 0.2055336  0.14229249 0.25296443 0.11067194]\n\n\n\n\n\nxv &lt;- df$relFrequency\nprint('Array xv is:', xv)\n\nError in print.default(\"Array xv is:\", xv): invalid printing digits 0",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Working with Data II: Statistics</span>"
    ]
  },
  {
    "objectID": "Data-2.html#making-simple-graphs-from-our-data",
    "href": "Data-2.html#making-simple-graphs-from-our-data",
    "title": "\n12  Working with Data II: Statistics\n",
    "section": "\n12.2 Making Simple Graphs from our Data",
    "text": "12.2 Making Simple Graphs from our Data\n\n12.2.1 Bar Charts\nWe first make a bar chart of the absolute frequencies.\n\n\nPython Code\nR Code\n\n\n\n\nfig, ax = plt.subplots()\n\nax.plot(1. + np.arange(len(xv)), xv, '-o')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nxv &lt;- df$relFrequency\n\n# Create a sequence from 1 to the length of xv\nx_seq &lt;- seq(1, length(xv))\n\n# Create a plot with points represented as circles ('o')\nplot(x_seq, xv, type = \"o\", xlab = \"Index\", ylab = \"relFrequency\")\n\n\n\n\n\n\n\n\n\n\nHey, that's not a bar chart. Let's try again.\n\n\nPython Code\nR Code\n\n\n\n\nfig, ax = plt.subplots()\n\nax.bar(1. + np.arange(len(xv)), xv, align='center')\n\n# Annotate with text\nax.set_xticks(1. + np.arange(len(xv)))\nfor i, val in enumerate(xv):\n    ax.text(i+1, val/2, str(round(val*100, 2))+'%', va='center', ha='center', color='black')\nax.set_ylabel('%')\nax.set_title('Relative Frequency Barchart')\nplt.show()\n\n# We can also save this graph as a pdf in a subfolder called 'Graphs'\n# You will have to make this subfolder first though.\n\n#savefig('./Graphs/fig1.pdf')\n\n&lt;BarContainer object of 5 artists&gt;\n\n\n\n\n\n\n\n\n\n\n\n# Create a sequence from 1 to the length of xv\nx_seq &lt;- seq(1, length(xv))\n\n# Create a bar plot\nbarplot(xv, beside = TRUE, names.arg = x_seq, xlab = \"Index\", ylab = \"Relative Frequency\",\n        main = \"Relative Frequency Barchart\")\n\n# Annotate with text\nfor (i in 1:length(xv)) {\n  text(x_seq[i], xv[i] / 2, paste0(round(xv[i] * 100, 2), \"%\"), col = \"black\")\n}\n\n\n\n\n\n\n\n\n\n\nThis simple command plots the barchart into a window and saves it as fig1.pdf into a subfolder called Graphs. Don't forget to first make this subfolder, otherwise Python will throw an error when it can't find the folder.\nYou also see that the height of the bars is symply the y-coordinate of the points in the previous scatter plot.\n\n12.2.2 Pie Charts\nWe next make a pie chart using the relative frequencies stored in vector xv.\n\n\nPython Code\nR Code\n\n\n\n\nfig, ax = plt.subplots()\nax.pie(xv, labels = np.round(xv*100, 2), shadow=True)\n# Annotate with text\n\n([&lt;matplotlib.patches.Wedge object at 0x7f84f3f62b10&gt;, &lt;matplotlib.patches.Wedge object at 0x7f84edd54910&gt;, &lt;matplotlib.patches.Wedge object at 0x7f84ede11450&gt;, &lt;matplotlib.patches.Wedge object at 0x7f84ede13410&gt;, &lt;matplotlib.patches.Wedge object at 0x7f84ec3d9550&gt;], [Text(0.6781839331802654, 0.8660638271952856, '28.85'), Text(-0.85328246781493, 0.6941966797094776, '20.55'), Text(-1.0089324129244073, -0.43824124195531106, '14.23'), Text(0.08868783615494694, -1.0964189289309783, '25.3'), Text(1.0341800094376912, -0.3747955550422889, '11.07')])\n\nax.set_title('Relative Frequency Pie Chart')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# Create a pie chart\npie(xv, labels = paste0(round(xv * 100, 2), \"%\"), main = \"Relative Frequency Pie Chart\")\n\n# Add text annotations\ntext(0, 0, \"Category 1\", col = \"black\")\ntext(0, 0.1, \"Category 2\", col = \"black\")\ntext(0.1, 0, \"Category 3\", col = \"black\")\ntext(0.1, 0.1, \"Category 4\", col = \"black\")\n\n\n\n\n\n\n\n\n\n\n\n12.2.3 Histograms\nNext we use a new data file called Lecture_Data_Excel_b.csv &lt;Lecture_Data/Lecture_Data_Excel_b.csv&gt;. Let us first import the data and have a quick look.\n\n\nPython Code\nR Code\n\n\n\n\ndf = pd.read_csv(filepath + 'Lecture_Data_Excel_b.csv')\nprint(df.head())\n\n   Height  Response  AverageMathSAT  Age  Female  Education  Race\n0     1.1         3             370   20       0          2  Hisp\n1     1.2         4             393   20       0          4   Wht\n2     1.3         4             413   20       0          4   Blk\n3     1.4         5             430   20       0          4   Wht\n4     1.5         3             440   20       0          2   Mex\n\n\n\n\n\ndf &lt;- read.csv(paste0(filepath, 'Lecture_Data_Excel_b.csv'))\nprint(head(df))\n\n  Height Response AverageMathSAT Age Female Education Race\n1    1.1        3            370  20      0         2 Hisp\n2    1.2        4            393  20      0         4  Wht\n3    1.3        4            413  20      0         4  Blk\n4    1.4        5            430  20      0         4  Wht\n5    1.5        3            440  20      0         2  Mex\n6    1.6        5            448  20      0         4  Blk\n\n\n\n\n\nLet us clean this somewhat and drop a column that we do not plan on using, the Response column.\n\n\nPython Code\nR Code\n\n\n\n\ndf = pd.read_csv(filepath + 'Lecture_Data_Excel_b.csv')\ndf = df.drop('Response' , axis=1)\nprint(df.head())\n\n   Height  AverageMathSAT  Age  Female  Education  Race\n0     1.1             370   20       0          2  Hisp\n1     1.2             393   20       0          4   Wht\n2     1.3             413   20       0          4   Blk\n3     1.4             430   20       0          4   Wht\n4     1.5             440   20       0          2   Mex\n\n\n\n\n\n# Remove columns 'Unnamed: 2' and 'Unnamed: 3'\ndf &lt;- df[, !(names(df) %in% c('Response'))]\n\nprint(head(df))\n\n  Height AverageMathSAT Age Female Education Race\n1    1.1            370  20      0         2 Hisp\n2    1.2            393  20      0         4  Wht\n3    1.3            413  20      0         4  Blk\n4    1.4            430  20      0         4  Wht\n5    1.5            440  20      0         2  Mex\n6    1.6            448  20      0         4  Blk\n\n\n\n\n\nThe remaining data in the DataFrame has observations on on height, age and other variables. We first make a histogram of the continuous variable Height. The actual command for the histogram is hist. It returns three variables prob, bins, and patches. We use them in the following to add information to the histogram.\n\n\nPython Code\nR Code\n\n\n\n\nheightv = df['Height'].values\n\n# Initialize\nN = len(heightv) # number of obs.\nB = 8           # number of bins in histogram\n\nfig, ax = plt.subplots()\nplt.subplots_adjust(wspace = 0.8, hspace = 0.8)\n\nprob, bins, patches = ax.hist(heightv, bins=B, align='mid' )\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# Initialize\nheightv  &lt;- df$Height # number of observations\nB &lt;- 8              # number of bins in histogram\n\n# Create a histogram\nhist_data &lt;- hist(df$Height, breaks = B, plot = FALSE)\n\n# Plot the histogram\nplot(hist_data, main = \"Height Histogram\", xlab = \"Height\", ylab = \"Frequency\", col = \"lightblue\", border = \"black\")\n\n\n\n\n\n\n\n\n\n\nWe next add some text to the histogram so that we can convey even more information to the reader/user of our research.\n\n\nPython Code\nR Code\n\n\n\n\nheightv = df['Height'].values\n\n# Initialize\nN = len(heightv) # number of obs.\nB = 8           # number of bins in histogram\n\nfig, ax = plt.subplots()\nplt.subplots_adjust(wspace = 0.8, hspace = 0.8)\n\nprob, bins, patches = ax.hist(heightv, bins=B, align='mid' )\n# Annotate with text\nfor i, p in enumerate(prob):\n    percent = int(float(p)/N*100)\n    # only annotate non-zero values\n    if percent:\n        ax.text(bins[i]+0.3, p/2.0, str(percent)+'%', rotation=75, va='bottom', ha='center')\n\nax.set_xlabel('Height groups')\nax.set_ylabel('Number of obs')\nax.set_title('Histogram of Height')\nax.set_xlim(min(heightv),max(heightv))\n\n(1.1, 12.7)\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# Initialize\nN &lt;- length(heightv)  # number of observations\nB &lt;- 8               # number of bins in histogram\n\n# Create a histogram\nhist_data &lt;- hist(df$Height, breaks = B, plot = FALSE)\n\n# Create the histogram plot\nbarplot(hist_data$counts, names.arg = hist_data$mids, col = \"lightblue\", border = \"black\",\n        main = \"Histogram of Height\", xlab = \"Height groups\", ylab = \"Number of observations\")\n\n# Annotate with text\nfor (i in seq_along(hist_data$counts)) {\n  percent &lt;- round(hist_data$counts[i] / N * 100, 2)\n  if (percent &gt; 0) {\n    text(hist_data$mids[i], hist_data$counts[i] / 2, paste0(percent, \"%\"), srt = 75, adj = c(0.5, 0.5))\n  }\n}\n\n\n\n\n\n\n\n\n\n\nWe can also make histograms with pandas built in commands. However, with this method you have less information about where the bars appear and what height they are, so you won't be able to add text at the appropriate positions as conveniently as before.\n\n\nPython Code\nR Code\n\n\n\n\nheightv = df['Height'].values\n\n# Initialize\nN = len(heightv) # number of obs.\nB = 8           # number of bins in histogram\n\nfig, ax = plt.subplots()\nplt.subplots_adjust(wspace = 0.8, hspace = 0.8)\n\ndf['Height'].hist(bins = B, ax = ax, color = 'k', alpha = 0.3)\n#\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# Initialize\nB &lt;- 8               # number of bins in the histogram\n\n# Create a histogram\nhist(df$Height, breaks = B, main = \"Histogram of Height\", xlab = \"Height groups\",\n     col = \"gray\", border = \"black\")\n\n\n\n\n\n\n\n\n\n\nNow we add a couple more variables and make a series of histograms all in the same figure.\n\n\nPython Code\nR Code\n\n\n\n\nheightv = df['Height'].values\n\n# Initialize\nN = len(heightv) # number of obs.\nB = 8           # number of bins in histogram\n\nfig, ax = plt.subplots(2,2)\nplt.subplots_adjust(wspace = 0.8, hspace = 0.8)\n\nprob, bins, patches = ax[0,0].hist(heightv, bins=B, align='mid' )\n# Annotate with text\nfor i, p in enumerate(prob):\n    percent = int(float(p)/N*100)\n    # only annotate non-zero values\n    if percent:\n        ax[0,0].text(bins[i]+0.3, p/2.0, str(percent)+'%', rotation=75, va='bottom', ha='center')\n\nax[0,0].set_xlabel('Height groups')\nax[0,0].set_ylabel('Number of obs')\nax[0,0].set_title('Histogram of Height')\nax[0,0].set_xlim(min(heightv),max(heightv))\n\n# Using Panda's built in histogram method\n\n(1.1, 12.7)\n\ndf['Height'].hist(bins = B, ax = ax[0,1], color = 'k', alpha = 0.3)\nax[0,1].set_title('Histogram of Height')\nax[0,1].set_xlabel('Height groups')\nax[0,1].set_ylabel('Number of obs')\n#\ndf['AverageMathSAT'].hist(bins = B, ax = ax[1,0], color = 'g', alpha = 0.3)\nax[1,0].set_title('Histogram of Math SAT Scores')\n#\n#\ndf['Age'].hist(bins = B, ax = ax[1,1], color = 'r', alpha = 0.3)\nax[1,1].set_title('Histogram of Age')\n#\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# Initialize\n\nheightv  &lt;- df$Height # number of observations\nN &lt;- length(heightv)  # number of observations\nB &lt;- 8               # number of bins in the histogram\n\n# Create a 2x2 grid of subplots\npar(mfrow = c(2, 2))\n# Histogram for Height\nhist(df$Height, breaks = B, main = \"Histogram of Height\", xlab = \"Height groups\", col = \"gray\", border = \"black\")\n# Histogram for AverageMathSAT\nhist(df$AverageMathSAT, breaks = B, main = \"Histogram of Math SAT Scores\", col = \"green\", border = \"black\")\n# Histogram for Age\nhist(df$Age, breaks = B, main = \"Histogram of Age\", col = \"red\", border = \"black\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAnother way to graph a histogram is by using the powerful ggplot package which is a translation of R's ggplot2 package into Python. It follows a completely different graphing philosophy based on the grammar of grapics by:\nHadley Wickham. A layered grammar of graphics. Journal of Computational and Graphical Statistics, vol. 19, no. 1, pp. 3–28, 2010.\n\n\nAfter installing the ggplot library, you would plot the data as follows:\n\n\nPython Code\nR Code\n\n\n\n    print( ggplot(aes(x='Height'), data = df) + geom_histogram() +\n    ggtitle(\"Histogram of Height using ggplot\") + labs(\"Height\", \"Freq\"))\n\n\n\nlibrary(ggplot2)\n\n# Create a histogram of 'Height' using ggplot2\nggplot(data = df, aes(x = Height)) +\n  geom_histogram() +\n  ggtitle(\"Histogram of Height using ggplot2\") +\n  labs(x = \"Height\", y = \"Freq\")\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThe ggplot Python version seems to not be compatible with the latest version of Python 3.11. You would need to install an older version of Python if you wanted to use this library as of writing this.\n\n\nWe can also use the seaborn library to make fancy looking histograms quickly as in Histogram2.\n\nimport seaborn as sns\nsns.histplot(df['AverageMathSAT'].dropna(),bins=10, color='g')\nplt.show()\n\n\n\n\n\n\n\n\n12.2.4 Boxplots\nA boxplot of height is made as follows:\n\n\nPython Code\nR Code\n\n\n\n\nfig, ax = plt.subplots()\nax.boxplot(heightv)\n# Annotate with text\n\n{'whiskers': [&lt;matplotlib.lines.Line2D object at 0x7f84ec156510&gt;, &lt;matplotlib.lines.Line2D object at 0x7f84ec17da10&gt;], 'caps': [&lt;matplotlib.lines.Line2D object at 0x7f84ec17e210&gt;, &lt;matplotlib.lines.Line2D object at 0x7f84ec17ead0&gt;], 'boxes': [&lt;matplotlib.lines.Line2D object at 0x7f84ec11b790&gt;], 'medians': [&lt;matplotlib.lines.Line2D object at 0x7f84ec17f350&gt;], 'fliers': [&lt;matplotlib.lines.Line2D object at 0x7f84ec124f50&gt;], 'means': []}\n\nax.set_title('Boxplot of Height')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nboxplot(df$Height, main = \"Boxplot of Height\")\n\n\n\n\n\n\n\n\n\n\n\n12.2.5 Scatterplots\nWe finally make a scatterplot of two variables. A scattersplot shows the relationship of two quantitative (or numeric) variables. We typically distinguish between positive relationship, negative relationship or no relationship (often referred to as independence). The scatterplot will give you a rough idea about “how” your variables are related to each other.\nYou can either use the matplotlib.pyplot library or pandas itself to produce a scatterplot.\n\n\nPython Code\nR Code\n\n\n\n\nfig, ax = plt.subplots()\nax.plot(df['Height'], df['AverageMathSAT'], '.')\n# Annotate with text\nax.set_title('Scatterplot')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# Create a scatterplot\nplot(df$Height, df$AverageMathSAT, xlab = \"Height\", ylab = \"AverageMathSAT\", main = \"Scatterplot\", pch = 19)\n\n\n\n\n\n\n\n\n\n\nAn alternative method uses the built-in plot routines in pandas.\n\n\nPython Code\nR Code\n\n\n\n\ndf.plot.scatter(x= 'Height', y='AverageMathSAT')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# Create a scatterplot\nplot(df$Height, df$AverageMathSAT, xlab = \"Height\", ylab = \"AverageMathSAT\", main = \"Scatterplot\", pch = 19)",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Working with Data II: Statistics</span>"
    ]
  },
  {
    "objectID": "Data-2.html#summary-statistics",
    "href": "Data-2.html#summary-statistics",
    "title": "\n12  Working with Data II: Statistics\n",
    "section": "\n12.3 Summary Statistics",
    "text": "12.3 Summary Statistics\nWe next go through some basic summary statistics measures.\n\n12.3.1 Measures of Central Tendency\nA quick way to produce summary statistics of our data set is to use panda's command describe.\n\n\nPython Code\nR Code\n\n\n\n\nprint(df.describe())\n\n          Height  AverageMathSAT        Age     Female  Education\ncount  60.000000       60.000000  60.000000  60.000000  60.000000\nmean    6.816667      493.666667  20.933333   0.333333   3.016667\nstd     3.571743       34.018274   1.176992   0.475383   1.096863\nmin     1.100000      370.000000  20.000000   0.000000   1.000000\n25%     3.950000      478.500000  20.000000   0.000000   2.000000\n50%     6.850000      507.000000  20.000000   0.000000   3.000000\n75%     9.650000      509.250000  22.000000   1.000000   4.000000\nmax    12.700000      542.000000  23.000000   1.000000   5.000000\n\n\n\n\n\nsummary(df)\n\n     Height       AverageMathSAT       Age            Female      \n Min.   : 1.100   Min.   :370.0   Min.   :20.00   Min.   :0.0000  \n 1st Qu.: 3.950   1st Qu.:478.5   1st Qu.:20.00   1st Qu.:0.0000  \n Median : 6.850   Median :507.0   Median :20.00   Median :0.0000  \n Mean   : 6.817   Mean   :493.7   Mean   :20.93   Mean   :0.3333  \n 3rd Qu.: 9.650   3rd Qu.:509.2   3rd Qu.:22.00   3rd Qu.:1.0000  \n Max.   :12.700   Max.   :542.0   Max.   :23.00   Max.   :1.0000  \n   Education         Race          \n Min.   :1.000   Length:60         \n 1st Qu.:2.000   Class :character  \n Median :3.000   Mode  :character  \n Mean   :3.017                     \n 3rd Qu.:4.000                     \n Max.   :5.000                     \n\n\n\n\n\nOr we can produce the same statistics by hand. We first calculate the mean, median and mode. Note that mode is part of the stats package which was imported as st using: from scipy import stats as st. Now we have to add st to the mode command: st.mode(heightv) in order to call it. The other commands are part of the numpy package so they have the prefix np.\n\n\nPython Code\nR Code\n\n\n\n\n# Number of observations (sample size)\nN = len(heightv)\n\n# Mean - Median - Mode\nprint(\"Mean(height)=  {:.3f}\".format(np.mean(heightv)))\nprint(\"Median(height)=  {:.3f}\".format(np.median(heightv)))\n\n# Mode (value with highest frequency)\nprint(\"Mode(height)=  {}\".format(st.mode(heightv)))\n\nMean(height)=  6.817\nMedian(height)=  6.850\nMode(height)=  ModeResult(mode=array([1.1]), count=array([1]))\n\n&lt;string&gt;:1: FutureWarning: Unlike other reduction functions (e.g. `skew`, `kurtosis`), the default behavior of `mode` typically preserves the axis it acts along. In SciPy 1.11.0, this behavior will change: the default value of `keepdims` will become False, the `axis` over which the statistic is taken will be eliminated, and the value None will no longer be accepted. Set `keepdims` to True or False to avoid this warning.\n\n\n\n\n\n# Assuming 'df' is your dataframe\nnum_observations &lt;- nrow(df)\n\n# Print the number of observations\ncat(\"Number of Observations:\", num_observations, \"\\n\")\n\n# Calculate Mean\nmean_height &lt;- mean(df$Height)\ncat(\"Mean(height) =\", mean_height, \"\\n\")\n\n# Calculate Median\nmedian_height &lt;- median(df$Height)\ncat(\"Median(height) =\", median_height, \"\\n\")\n\n# Calculate Mode\nmode_height &lt;- names(sort(table(df$Height), decreasing = TRUE)[1])\ncat(\"Mode(height) =\", mode_height, \"\\n\")\n\nNumber of Observations: 60 \nMean(height) = 6.816667 \nMedian(height) = 6.85 \nMode(height) = 1.1 \n\n\n\n\n\nWe can also just summarize a variable using the st.describe command from the stats package.\n\n\nPython Code\nR Code\n\n\n\n\n# Summary stats\nprint(\"Summary Stats\")\nprint(\"-------------\")\nprint(st.describe(heightv))\n\nSummary Stats\n-------------\nDescribeResult(nobs=60, minmax=(1.1, 12.7), mean=6.8166666666666655, variance=12.757344632768362, skewness=0.019099619781273072, kurtosis=-1.1611486008105545)\n\n\n\n\n\n# Assuming 'heightv' is your vector\nsummary_stats &lt;- summary(df$Height)\n\n# Print the summary statistics\ncat(\"Summary Stats\\n\")\ncat(\"-------------\\n\")\nprint(summary_stats)\n\nSummary Stats\n-------------\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  1.100   3.950   6.850   6.817   9.650  12.700 \n\n\n\n\n\n\n12.3.2 Measures of Dispersion\nWe now calculate the range, variance and standard deviations. Remember that for variance and standard deviation there is a distinction between population and sample.\n\n\nPython Code\nR Code\n\n\n\n\n# returns smallest a largest element\nprint(\"Range = {:.3f}\".format(max(heightv)-min(heightv)))\nprint(\"Population variance = {:.3f}\".\\\n\n# population variance\n  format(np.sum((heightv-np.mean(heightv))**2)/N))\n\n# sample variance\nprint(\"Sample variance     = {:.3f}\".\\\n  format(np.sum((heightv-np.mean(heightv))**2)/(N-1)))\n\nprint(\"Pop.   standard dev = {:.3f}\".\\\n  format(np.sqrt(np.sum((heightv-np.mean(heightv))**2)/N)))\n\nprint(\"Sample standard dev = {:.3f}\". \\\n  format(np.sqrt(np.sum((heightv-np.mean(heightv))**2)/(N-1))))\n\n#Or simply\nprint(\"Pop.   standard dev = {:.3f}\".format(np.std(heightv)))\n\nRange = 11.600\nPopulation variance = 12.545\nSample variance     = 12.757\nPop.   standard dev = 3.542\nSample standard dev = 3.572\nPop.   standard dev = 3.542\n\n\n\n\n\nheightv = df$Height\n\n# Range\nrange_value &lt;- range(heightv)\ncat(\"Range = \", range_value[2] - range_value[1], \"\\n\")\n\n# Population variance\npop_variance &lt;- sum((heightv - mean(heightv))^2) / length(heightv)\ncat(\"Population variance = \", pop_variance, \"\\n\")\n\n# Sample variance\nsample_variance &lt;- sum((heightv - mean(heightv))^2) / (length(heightv) - 1)\ncat(\"Sample variance = \", sample_variance, \"\\n\")\n\n# Population standard deviation\npop_std_dev &lt;- sqrt(pop_variance)\ncat(\"Population standard dev = \", pop_std_dev, \"\\n\")\n\n# Sample standard deviation\nsample_std_dev &lt;- sqrt(sample_variance)\ncat(\"Sample standard dev = \", sample_std_dev, \"\\n\")\n\nRange =  11.6 \nPopulation variance =  12.54472 \nSample variance =  12.75734 \nPopulation standard dev =  3.541853 \nSample standard dev =  3.571743 \n\n\n\n\n\n\n12.3.3 Measures of Relative Standing\nPercentiles are calculated as follows:\n\n\nPython Code\nR Code\n\n\n\n\nprint(\"1 quartile (25th percentile) = {:.3f}\".\\\n  format(st.scoreatpercentile(heightv, 25)))\nprint(\"2 quartile (50th percentile) = {:.3f}\".\\\n  format(st.scoreatpercentile(heightv, 50)))\nprint(\"3 quartile (75th percentile) = {:.3f}\".\\\n  format(st.scoreatpercentile(heightv, 75)))\n\n# Inter quartile rante: Q3-Q1 or P_75-P_25\nprint(\"IQR = P75 - P25              = {:.3f}\".\\\n  format(st.scoreatpercentile(heightv, 75)\\\n  -st.scoreatpercentile(heightv, 25)))\n\n1 quartile (25th percentile) = 3.950\n2 quartile (50th percentile) = 6.850\n3 quartile (75th percentile) = 9.650\nIQR = P75 - P25              = 5.700\n\n\n\n\n\n# Calculate quartiles\nquartiles &lt;- quantile(df$Height, probs = c(0.25, 0.5, 0.75))\n\n# 1st quartile (25th percentile)\nq1 &lt;- quartiles[1]\ncat(\"1st quartile (25th percentile) = \", q1, \"\\n\")\n\n# 2nd quartile (50th percentile, median)\nq2 &lt;- quartiles[2]\ncat(\"2nd quartile (50th percentile) = \", q2, \"\\n\")\n\n# 3rd quartile (75th percentile)\nq3 &lt;- quartiles[3]\ncat(\"3rd quartile (75th percentile) = \", q3, \"\\n\")\n\n# Interquartile range (IQR)\niqr &lt;- q3 - q1\ncat(\"IQR = P75 - P25 = \", iqr, \"\\n\")\n\n1st quartile (25th percentile) =  3.95 \n2nd quartile (50th percentile) =  6.85 \n3rd quartile (75th percentile) =  9.65 \nIQR = P75 - P25 =  5.7 \n\n\n\n\n\n\n12.3.4 Data Aggregation or Summary Statistics by Subgroup\nWe next want to summarize the data by subgroup. Let's assume that we would like to compare the average Height by Race. We can use the groupby() to accomplish this.\n\n\nPython Code\nR Code\n\n\n\n\ngroupRace = df.groupby('Race')\nprint('Summary by Race', groupRace.mean(numeric_only=True))\n\nSummary by Race         Height  AverageMathSAT        Age    Female  Education\nRace                                                          \nBlk   6.278261      491.652174  20.826087  0.304348   3.565217\nHisp  6.525000      472.750000  21.500000  0.250000   1.750000\nMex   6.171429      491.571429  20.928571  0.285714   2.428571\nOth   8.750000      516.000000  21.000000  0.500000   2.500000\nWht   7.917647      500.411765  20.941176  0.411765   3.117647\n\n\n\n\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n# Group the dataframe 'df' by the 'Race' variable and calculate the mean for numeric columns\nsummary_by_race &lt;- df %&gt;%\n  group_by(Race) %&gt;%\n  summarise(across(where(is.numeric), mean, na.rm = TRUE))\n\nWarning: There was 1 warning in `summarise()`.\nℹ In argument: `across(where(is.numeric), mean, na.rm = TRUE)`.\nℹ In group 1: `Race = \"Blk\"`.\nCaused by warning:\n! The `...` argument of `across()` is deprecated as of dplyr 1.1.0.\nSupply arguments directly to `.fns` through an anonymous function instead.\n\n  # Previously\n  across(a:b, mean, na.rm = TRUE)\n\n  # Now\n  across(a:b, \\(x) mean(x, na.rm = TRUE))\n\nprint(summary_by_race)\n\n# A tibble: 5 × 6\n  Race  Height AverageMathSAT   Age Female Education\n  &lt;chr&gt;  &lt;dbl&gt;          &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;\n1 Blk     6.28           492.  20.8  0.304      3.57\n2 Hisp    6.52           473.  21.5  0.25       1.75\n3 Mex     6.17           492.  20.9  0.286      2.43\n4 Oth     8.75           516   21    0.5        2.5 \n5 Wht     7.92           500.  20.9  0.412      3.12\n\n\n\n\n\nWe could also use a different category like gender.\n\n\nPython Code\nR Code\n\n\n\n\ngroupGender = df.groupby('Female')\nprint('Summary by Gender', groupGender.mean(numeric_only=True))\n\nSummary by Gender         Height  AverageMathSAT   Age  Education\nFemale                                         \n0        4.765           479.7  21.4       2.95\n1       10.920           521.6  20.0       3.15\n\n\n\n\n\nlibrary(dplyr)\n\n# Group the dataframe 'df' by the 'Race' variable and calculate the mean for numeric columns\nsummary_by_gender &lt;- df %&gt;%\n  group_by(Female) %&gt;%\n  summarise(across(where(is.numeric), mean, na.rm = TRUE))\n\nprint(summary_by_gender)\n\n# A tibble: 2 × 5\n  Female Height AverageMathSAT   Age Education\n   &lt;int&gt;  &lt;dbl&gt;          &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;\n1      0   4.76           480.  21.4      2.95\n2      1  10.9            522.  20        3.15\n\n\n\n\n\nOr we can also combine the two or more categories and summarize the data as follows.\n\n\nPython Code\nR Code\n\n\n\n\ngroupRaceGender = df.groupby(['Race', 'Female'])\nprint('Summary by Race and Gender', groupRaceGender.mean(numeric_only=True))\n\nSummary by Race and Gender                 Height  AverageMathSAT      Age  Education\nRace Female                                               \nBlk  0        4.350000      479.562500  21.1875   3.562500\n     1       10.685714      519.285714  20.0000   3.571429\nHisp 0        5.600000      461.333333  22.0000   1.666667\n     1        9.300000      507.000000  20.0000   2.000000\nMex  0        4.480000      481.900000  21.3000   2.100000\n     1       10.400000      515.750000  20.0000   3.250000\nOth  0        6.300000      506.000000  22.0000   1.000000\n     1       11.200000      526.000000  20.0000   4.000000\nWht  0        5.310000      480.600000  21.6000   3.400000\n     1       11.642857      528.714286  20.0000   2.714286\n\n\n\n\n\nlibrary(dplyr)\n\n# Group the dataframe 'df' by 'Race' and 'Female' variables and calculate the mean for numeric columns\nsummary_by_race_gender &lt;- df %&gt;%\n  group_by(Race, Female) %&gt;%\n  summarise(across(where(is.numeric), mean, na.rm = TRUE))\n\n`summarise()` has grouped output by 'Race'. You can override using the\n`.groups` argument.\n\nprint(summary_by_race_gender)\n\n# A tibble: 10 × 6\n# Groups:   Race [5]\n   Race  Female Height AverageMathSAT   Age Education\n   &lt;chr&gt;  &lt;int&gt;  &lt;dbl&gt;          &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;\n 1 Blk        0   4.35           480.  21.2      3.56\n 2 Blk        1  10.7            519.  20        3.57\n 3 Hisp       0   5.6            461.  22        1.67\n 4 Hisp       1   9.3            507   20        2   \n 5 Mex        0   4.48           482.  21.3      2.1 \n 6 Mex        1  10.4            516.  20        3.25\n 7 Oth        0   6.3            506   22        1   \n 8 Oth        1  11.2            526   20        4   \n 9 Wht        0   5.31           481.  21.6      3.4 \n10 Wht        1  11.6            529.  20        2.71\n\n\n\n\n\nBe careful and don't forget to add the various categories in a list using the brackets [...]].",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Working with Data II: Statistics</span>"
    ]
  },
  {
    "objectID": "Data-2.html#measures-of-linear-relationship",
    "href": "Data-2.html#measures-of-linear-relationship",
    "title": "\n12  Working with Data II: Statistics\n",
    "section": "\n12.4 Measures of Linear Relationship",
    "text": "12.4 Measures of Linear Relationship\n\n12.4.1 Covariance\nWe first grab two variables heightv and agev from the dataframe and define them as numpy arrays.\n\nxv = df['Age'].values\nyv = df['Height'].values\nn = len(xv)\n\nWe then go ahead and calculate the covariance.\n\n\nPython Code\nR Code\n\n\n\n\n# Population covariance\nprint(\"Population covariance = {:.3f}\".\\\n  format(np.sum((xv-np.mean(xv))*(yv-np.mean(yv)))/n))\n\n# Sample covariance\nprint(\"Sample covariance     = {:.3f}\".\\\n  format(np.sum((xv-np.mean(xv))*(yv-np.mean(yv)))/(n-1)))\n\n# or simply\nprint(\"Sample covariance     = {:.3f}\".format(df.Age.cov(df.Height)))\n\nPopulation covariance = -0.159\nSample covariance     = -0.162\nSample covariance     = -0.162\n\n\n\n\n\n# Population covariance\npop_covariance &lt;- cov(df$Age, df$Height)\n\n# Sample covariance\nsample_covariance &lt;- cov(df$Age, df$Height, use = \"complete.obs\")\n\n# Print covariances\ncat(\"Population covariance = \", pop_covariance, \"\\n\")\ncat(\"Sample covariance = \", sample_covariance, \"\\n\")\n\nPopulation covariance =  -0.1615819 \nSample covariance =  -0.1615819 \n\n\n\n\n\n\n12.4.2 Correlation Coefficient\nWe can calculate the correlation coefficient by hand or using the pandas toolbox command.\n\n\nPython Code\nR Code\n\n\n\n\nprint(\"Correlation coefficient =  {:.3f}\".\\\n  format((np.sum((xv-np.mean(xv))*(yv-np.mean(yv)))/n)\\\n  /(np.std(xv)*np.std(yv))))\n\nprint(\"Correlation coefficient = {:.3f}\".format(df.Age.corr(df.Height)))\n\nCorrelation coefficient =  -0.038\nCorrelation coefficient = -0.038\n\n\n\n\n\n# Calculate correlation coefficient\ncorrelation_coefficient &lt;- cor(df$Age, df$Height)\n\n# Print correlation coefficient\ncat(\"Correlation coefficient = \", correlation_coefficient, \"\\n\")\n\nCorrelation coefficient =  -0.03843607 \n\n\n\n\n\n\n12.4.3 Regression: Example 1\nWe first generate some data. A variable x and a variable y.\n\n\nPython Code\nR Code\n\n\n\n\n# Define data. 2 vectors xv and yv\nxv = np.arange(1,9,1)\nyv = np.array([6,1,9,5,17,12,14,15])\n\n\n\n\n# Define the data\nxv &lt;- c(1, 2, 3, 4, 5, 6, 7, 8)\nyv &lt;- c(6, 1, 9, 5, 17, 12, 14, 15)\n\n\n\n\nWe then \"cast\" these into a pandas DataFrame.\n\n\nPython Code\nR Code\n\n\n\n\n# Define data frame\ndf = pd.DataFrame(np.array([xv, yv]).T, columns = ['x', 'y'])\n\n\n\n\n# Create a data frame\ndf &lt;- data.frame(x = xv, y = yv)\n\n\n\n\nWe fist make a scatterplot with least squares trend line: y = beta_0 + beta_1 * x + epsilon.\n\n\nPython Code\nR Code\n\n\n\n\np = np.polyfit(xv, yv, 1)\nprint(\"p = {}\".format(p))\n\n# Scatterplot\n\np = [1.77380952 1.89285714]\n\nfig, ax = plt.subplots()\nax.set_title('Linear regression with polyfit()')\nax.plot(xv, yv, 'o', label = 'data')\nax.plot(xv, np.polyval(p,xv),'-', label = 'Linear regression')\nax.legend(['Data', 'OLS'], loc='best')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# Linear regression\nmodel &lt;- lm(y ~ x, data = df)\n\n# Scatterplot\nplot(xv, yv, main = \"Linear regression with lm()\", xlab = \"x\", ylab = \"y\")\nabline(model, col = \"red\")\n\n\n\n\n\n\n\n\n\n\nExample 1 Again with Statsmodels library\nWe then run the same regression using a more general method called ols which is part of statsmodels. When calling the ols function you need to add the module name (statsmodels was imported as sm) in front of it: sm.OLS(). You then define the independent variable y and the dependent variables x's.\n\n\n\n\n\n\nWarning\n\n\n\nIf you google for OLS and Python you may come across code that uses Pandas directly to run an OLS regression as in pd.OLS(y=Ydata, x=Xdata). This will not work anymore as this API has been deprecated in newer versions of Pandas. You need to use the Statsmodel Library\n\n\n\n\nPython Code\nR Code\n\n\n\n\nimport statsmodels.api as sm\nfrom patsy import dmatrices\n\n# Run OLS regression\n# This line adds a constant number column to the X-matrix and extracts\n# the relevant columns from the dataframe\ny, X = dmatrices('y ~ x', data=df, return_type='dataframe')\nres = sm.OLS(y, X).fit()\n\n# Show coefficient estimates\nprint(res.summary())\n\n                            OLS Regression Results                            \n==============================================================================\nDep. Variable:                      y   R-squared:                       0.609\nModel:                            OLS   Adj. R-squared:                  0.544\nMethod:                 Least Squares   F-statistic:                     9.358\nDate:                Mon, 25 Mar 2024   Prob (F-statistic):             0.0222\nTime:                        15:48:18   Log-Likelihood:                -20.791\nNo. Observations:                   8   AIC:                             45.58\nDf Residuals:                       6   BIC:                             45.74\nDf Model:                           1                                         \nCovariance Type:            nonrobust                                         \n==============================================================================\n                 coef    std err          t      P&gt;|t|      [0.025      0.975]\n------------------------------------------------------------------------------\nIntercept      1.8929      2.928      0.646      0.542      -5.272       9.058\nx              1.7738      0.580      3.059      0.022       0.355       3.193\n==============================================================================\nOmnibus:                        0.555   Durbin-Watson:                   3.176\nProb(Omnibus):                  0.758   Jarque-Bera (JB):                0.309\nSkew:                           0.394   Prob(JB):                        0.857\nKurtosis:                       2.449   Cond. No.                         11.5\n==============================================================================\n\nNotes:\n[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.\n\n/home/jjung/anaconda3/envs/islp/lib/python3.11/site-packages/scipy/stats/_stats_py.py:1736: UserWarning: kurtosistest only valid for n&gt;=20 ... continuing anyway, n=8\n  warnings.warn(\"kurtosistest only valid for n&gt;=20 ... continuing \"\n\n\n\n\n\n# Define the data\nxv &lt;- c(1, 2, 3, 4, 5, 6, 7, 8)\nyv &lt;- c(6, 1, 9, 5, 17, 12, 14, 15)\n\n# Create a data frame\ndf &lt;- data.frame(x = xv, y = yv)\n\n# Linear regression using lm()\nmodel &lt;- lm(y ~ x, data = df)\n\n# Show coefficient estimates\nprint(summary(model))\n\n\nCall:\nlm(formula = y ~ x, data = df)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-4.4405 -1.8095 -0.4226  1.9226  6.2381 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)  \n(Intercept)   1.8929     2.9281   0.646   0.5419  \nx             1.7738     0.5798   3.059   0.0222 *\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 3.758 on 6 degrees of freedom\nMultiple R-squared:  0.6093,    Adjusted R-squared:  0.5442 \nF-statistic: 9.358 on 1 and 6 DF,  p-value: 0.02225\n\n\n\n\n\nOr if you simply want to have a look at the estimated coefficients you can access them via:\n\n\nPython Code\nR Code\n\n\n\n\nprint('Parameters:')\nprint(res.params)\n\nParameters:\nIntercept    1.892857\nx            1.773810\ndtype: float64\n\n\n\n\n\n# Print the coefficients\nprint(\"Parameters:\")\nprint(coefficients(model))\n\n[1] \"Parameters:\"\n(Intercept)           x \n   1.892857    1.773810 \n\n\n\n\n\nFinally, we use the model to make a prediction of y when x = 8.5.\n\n\nPython Code\nR Code\n\n\n\n\n# Make prediction for x = 8.5\nbetas = res.params.values\nprint(\"Prediction of y for x = 8.5 is: {:.3f}\".\\\n  format(np.sum(betas * np.array([1,8.5]))))\n\nPrediction of y for x = 8.5 is: 16.970\n\n\n\n\n\n# Make a prediction for x = 8.5\nnew_data &lt;- data.frame(x = 8.5)\npredicted_y &lt;- predict(model, newdata = new_data)\n\nprint(paste(\"Prediction of y for x = 8.5 is:\", round(predicted_y, 3)))\n\n[1] \"Prediction of y for x = 8.5 is: 16.97\"\n\n\n\n\n\nWe can also use the results from the OLS command to make a scatterplot with the trendline through it.\n\n\nPython Code\nR Code\n\n\n\n\nfig, ax = plt.subplots()\nax.set_title('Linear Regression with Fitted Values')\nax.plot(xv, yv, 'o', label = 'data')\nax.plot(xv, res.predict(X).values,'k-', label = 'Linear regression')\nax.legend(['Data', 'OLS'], loc='best')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nlibrary(ggplot2)\n\n# Get predicted values\ny_hat &lt;- predict(model, newdata = df)\n\n# Create a data frame with x, y, and predicted values\ndata &lt;- data.frame(x = xv, y = yv, predicted = y_hat)\n\n# Create a scatterplot with the fitted values\np &lt;- ggplot(data, aes(x = x, y = y)) +\n  geom_point() +\n  geom_line(aes(y = predicted), color = \"black\") +\n  labs(title = \"Linear Regression with Fitted Values\", x = \"x\", y = \"y\") +\n  theme_minimal()\n\n# Print the plot\nprint(p)\n\n\n\n\n\n\n\n\n\n\nAs you have seen above, you can use the estimates from this model to make predictions of Y (called Y-hat) for specific values of variable X. We next use all the X values from our original data and predict for each one of those what the corresponding predicted Y-value would be (\\(\\hat{y}\\)) and then calculate the difference between the actual Y value in the data and the predicted Y-value Y-hat. In the graph above, it is essentially the distance of the blue dots (the data) to the black line (the prediction from the model).\nThese differences, \\(y-\\hat{y}\\), are also called the residual errors of your model. The OLS procedure tries to find beta estimates to minimize these residual errors (OLS actually tried to minimize the sum of all the squared errors, or \\(\\sum_i{(y_i-\\hat{y}_i)^2}\\).\nHere is the code to accomplish this.\n\n\nPython Code\nR Code\n\n\n\n\ny_hatv = res.predict(X).values  # Predicts y-hat based on all X values in data\nresidualsv = yv - y_hatv\n\nfig, ax = plt.subplots()\nax.set_title('Residual Plot')\nax.plot(yv, residualsv, 'o', label = 'data')\nax.plot(yv, np.zeros(len(yv)),'k-')\nax.set_xlabel('Y - Dependent Variable')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# Predict using the model\ny_hat &lt;- predict(model, newdata = df)\nresiduals &lt;- yv - y_hat\n\n# Create a residual plot without connecting the dots\nplot(yv, residuals, pch = 19, col = 'blue', xlab = 'Y - Dependent Variable', ylab = 'Residuals', main = 'Residual Plot')\nabline(h = 0, col = 'black', lwd = 2)\n\n\n\n\n\n\n\n\n\n\nIf the errors are systematically different over the range of X-values we call this heteroskedasticity. If you detect heteroskedasticity you would have to adjust for that using a more \"robust\" estimator. These more robust procedures basically adjust the standard errors (make them larger) to account for the effect that heteroskedasticity has on your estimate.\nHere is how you estimate the \"robust\" version of your regression.\n\n\nPython Code\nR Code\n\n\n\n\nimport statsmodels.api as sm\nfrom patsy import dmatrices\n\n# Run OLS regression\n# This line adds a constant number column to the X-matrix and extracts\n# the relevant columns from the dataframe\ny, X = dmatrices('y ~ x', data=df, return_type='dataframe')\nres_rob = sm.OLS(y, X).fit(cov_type = 'HC3')\n\n# Show coefficient estimates\nprint(res_rob.summary())\n\n                            OLS Regression Results                            \n==============================================================================\nDep. Variable:                      y   R-squared:                       0.609\nModel:                            OLS   Adj. R-squared:                  0.544\nMethod:                 Least Squares   F-statistic:                     11.04\nDate:                Mon, 25 Mar 2024   Prob (F-statistic):             0.0160\nTime:                        15:48:23   Log-Likelihood:                -20.791\nNo. Observations:                   8   AIC:                             45.58\nDf Residuals:                       6   BIC:                             45.74\nDf Model:                           1                                         \nCovariance Type:                  HC3                                         \n==============================================================================\n                 coef    std err          z      P&gt;|z|      [0.025      0.975]\n------------------------------------------------------------------------------\nIntercept      1.8929      3.363      0.563      0.574      -4.699       8.484\nx              1.7738      0.534      3.322      0.001       0.727       2.820\n==============================================================================\nOmnibus:                        0.555   Durbin-Watson:                   3.176\nProb(Omnibus):                  0.758   Jarque-Bera (JB):                0.309\nSkew:                           0.394   Prob(JB):                        0.857\nKurtosis:                       2.449   Cond. No.                         11.5\n==============================================================================\n\nNotes:\n[1] Standard Errors are heteroscedasticity robust (HC3)\n\n/home/jjung/anaconda3/envs/islp/lib/python3.11/site-packages/scipy/stats/_stats_py.py:1736: UserWarning: kurtosistest only valid for n&gt;=20 ... continuing anyway, n=8\n  warnings.warn(\"kurtosistest only valid for n&gt;=20 ... continuing \"\n\n\n\n\nThis code in R loads the necessary libraries (sandwich and lmtest) to perform robust standard error calculations using HC3. It first runs a simple OLS regression using the lm function, and then it computes heteroscedasticity-robust standard errors with the coeftest function and displays both the OLS coefficient estimates and the robust standard errors.\n\n# Load required library\nlibrary(sandwich)\nlibrary(lmtest)\n\nLoading required package: zoo\n\n\n\nAttaching package: 'zoo'\n\n\nThe following objects are masked from 'package:base':\n\n    as.Date, as.Date.numeric\n\n# Run robust OLS regression\nmodel &lt;- lm(y ~ x, data = df)\n\n# Compute heteroscedasticity-robust standard errors (HC3)\nrobust_se &lt;- coeftest(model, vcov = vcovHC(model, type = \"HC3\"))\n\n# Display coefficient estimates with robust standard errors\nsummary(model)\n\n\nCall:\nlm(formula = y ~ x, data = df)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-4.4405 -1.8095 -0.4226  1.9226  6.2381 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)  \n(Intercept)   1.8929     2.9281   0.646   0.5419  \nx             1.7738     0.5798   3.059   0.0222 *\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 3.758 on 6 degrees of freedom\nMultiple R-squared:  0.6093,    Adjusted R-squared:  0.5442 \nF-statistic: 9.358 on 1 and 6 DF,  p-value: 0.02225\n\nrobust_se\n\n\nt test of coefficients:\n\n            Estimate Std. Error t value Pr(&gt;|t|)  \n(Intercept)  1.89286    3.36314  0.5628  0.59394  \nx            1.77381    0.53389  3.3224  0.01596 *\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nStata uses HC1 as it's default when you run reg y x, r, while most R methods default to HC3. Always be sure to check the documentation.\n\n\nIf you compare the previous results to the robust results you will find that the coefficient estimates are the same but the standard errors in the robust version are larger.\n\n12.4.4 Regression: Example 2\nIn this example we estimate an OLS model with categorical (dummy variables). This is a bit more involved as we increase the number of explanatory variables. In addition, some explanatory variables are categorical variables. In order to use them in our OLS regression we first have to make so called dummy variables (i.e. indicator variables that are either 0 or 1).\nI will next demonstrate how to make dummy variables. I first show you a more cumbersome way to do it which is more powerful as it gives you more control over how to exactly define your dummy variable. Then I show you a quick way to do it if your categorical variable is already in the form of distinct categories.\nWe first import our dataset and investigate the form of our categorical variable Race.\n\n\nPython Code\nR Code\n\n\n\n\ndf = pd.read_csv(filepath + 'Lecture_Data_Excel_b.csv')\nprint(df['Race'].describe())\n\n# Let's rename one variable name\n\ncount      60\nunique      5\ntop       Blk\nfreq       23\nName: Race, dtype: object\n\ndf = df.rename(columns={'AverageMathSAT': 'AvgMathSAT'})\n\n\n\n\ndf &lt;- read.csv(paste0(filepath, 'Lecture_Data_Excel_b.csv'))\nprint(head(df))\n\n  Height Response AverageMathSAT Age Female Education Race\n1    1.1        3            370  20      0         2 Hisp\n2    1.2        4            393  20      0         4  Wht\n3    1.3        4            413  20      0         4  Blk\n4    1.4        5            430  20      0         4  Wht\n5    1.5        3            440  20      0         2  Mex\n6    1.6        5            448  20      0         4  Blk\n\nprint(summary(df$Race))\n\n   Length     Class      Mode \n       60 character character \n\n# Rename the 'AverageMathSAT' variable to 'AvgMathSAT'\nnames(df)[names(df) == \"AverageMathSAT\"] &lt;- \"AvgMathSAT\"\n\n\n\n\nFrom this summary we see that our categorical variables has five unique race categories. We therefore start with making a new variable for each one of these race categories that we pre-fill with zeros.\n\n\n\n\n\n\nNote\n\n\n\nI use a prefix d_ for my dummy variables which is a convenient naming convention that allows for quick identification of dummy variables for users who want to work with these data in the future.\n\n\n\n\nPython Code\nR Code\n\n\n\n\ndf['d_Wht'] = 0\ndf['d_Blk'] = 0\ndf['d_Mex'] = 0\ndf['d_Hisp'] = 0\ndf['d_Oth'] = 0\n\n\n\n\n# Create dummy variables\ndf$d_Wht &lt;- 0\ndf$d_Blk &lt;- 0\ndf$d_Mex &lt;- 0\ndf$d_Hisp &lt;- 0\ndf$d_Oth &lt;- 0\n\n\n\n\nWe next need to set these dummy variables equal to one, whenever the person is of that race. Let us first have a look at what the following command produces.\n\nprint(df['Race']=='Wht')\n\n0     False\n1      True\n2     False\n3      True\n4     False\n5     False\n6     False\n7     False\n8     False\n9     False\n10    False\n11     True\n12    False\n13    False\n14    False\n15    False\n16    False\n17    False\n18     True\n19    False\n20    False\n21    False\n22     True\n23    False\n24    False\n25    False\n26    False\n27     True\n28    False\n29    False\n30    False\n31     True\n32    False\n33     True\n34    False\n35    False\n36    False\n37     True\n38    False\n39     True\n40     True\n41    False\n42    False\n43    False\n44    False\n45     True\n46    False\n47    False\n48    False\n49    False\n50    False\n51    False\n52    False\n53     True\n54    False\n55    False\n56     True\n57     True\n58     True\n59     True\nName: Race, dtype: bool\n\n\nThis is a vector with true/false statements. It results in a True statement if the race of the person is white and a false statement otherwise. We can use this vector \"inside\" a dataframe to make a conditional statement. We can combine this with the .loc() function of Pandas to replace values in the d_Wht column given conditions are met in the Race column. Here is the syntax that replaces zeros in the d_Wht column with the value one, whenever the race of the person is equal to Wht in the Race column.\n\n\nPython Code\nR Code\n\n\n\n\ndf.loc[(df['Race'] == 'Wht'), 'd_Wht'] = 1\nprint(df.head())\n\n   Height  Response  AvgMathSAT  Age  Female  Education  Race  d_Wht  d_Blk  d_Mex  d_Hisp  d_Oth\n0     1.1         3         370   20       0          2  Hisp      0      0      0       0      0\n1     1.2         4         393   20       0          4   Wht      1      0      0       0      0\n2     1.3         4         413   20       0          4   Blk      0      0      0       0      0\n3     1.4         5         430   20       0          4   Wht      1      0      0       0      0\n4     1.5         3         440   20       0          2   Mex      0      0      0       0      0\n\n\n\n\n\n# Set dummy variables based on race\ndf$d_Wht &lt;- ifelse(df$Race == 'Wht', 1, 0)\nprint(head(df))\n\n  Height Response AvgMathSAT Age Female Education Race d_Wht d_Blk d_Mex d_Hisp\n1    1.1        3        370  20      0         2 Hisp     0     0     0      0\n2    1.2        4        393  20      0         4  Wht     1     0     0      0\n3    1.3        4        413  20      0         4  Blk     0     0     0      0\n4    1.4        5        430  20      0         4  Wht     1     0     0      0\n5    1.5        3        440  20      0         2  Mex     0     0     0      0\n6    1.6        5        448  20      0         4  Blk     0     0     0      0\n  d_Oth\n1     0\n2     0\n3     0\n4     0\n5     0\n6     0\n\n\n\n\n\nYou can do this now for the other four race categories to get your complete set of dummy variables.\n\n\nPython Code\nR Code\n\n\n\n\ndf.loc[(df['Race'] == 'Blk'), 'd_Blk'] = 1\ndf.loc[(df['Race'] == 'Mex'), 'd_Mex'] = 1\ndf.loc[(df['Race'] == 'Hisp'), 'd_Hisp'] = 1\ndf.loc[(df['Race'] == 'Oth'), 'd_Oth'] = 1\nprint(df.head())\n\n   Height  Response  AvgMathSAT  Age  Female  Education  Race  d_Wht  d_Blk  d_Mex  d_Hisp  d_Oth\n0     1.1         3         370   20       0          2  Hisp      0      0      0       1      0\n1     1.2         4         393   20       0          4   Wht      1      0      0       0      0\n2     1.3         4         413   20       0          4   Blk      0      1      0       0      0\n3     1.4         5         430   20       0          4   Wht      1      0      0       0      0\n4     1.5         3         440   20       0          2   Mex      0      0      1       0      0\n\n\n\n\n\n# Set dummy variables based on race\ndf$d_Blk &lt;- ifelse(df$Race == 'Blk', 1, 0)\ndf$d_Mex &lt;- ifelse(df$Race == 'Mex', 1, 0)\ndf$d_Hisp &lt;- ifelse(df$Race == 'Hisp', 1, 0)\ndf$d_Oth &lt;- ifelse(df$Race == 'Oth', 1, 0)\nprint(head(df))\n\n  Height Response AvgMathSAT Age Female Education Race d_Wht d_Blk d_Mex d_Hisp\n1    1.1        3        370  20      0         2 Hisp     0     0     0      1\n2    1.2        4        393  20      0         4  Wht     1     0     0      0\n3    1.3        4        413  20      0         4  Blk     0     1     0      0\n4    1.4        5        430  20      0         4  Wht     1     0     0      0\n5    1.5        3        440  20      0         2  Mex     0     0     1      0\n6    1.6        5        448  20      0         4  Blk     0     1     0      0\n  d_Oth\n1     0\n2     0\n3     0\n4     0\n5     0\n6     0\n\n\n\n\n\nThis is a very powerful way to make your own dummy variables as it allows you complete control over what you code as 0 and what you code as 1. Inside the .loc() function you can use more complex conditional statments such as &gt;, &lt;, &gt;=, &lt;=, as well as logical commands such as | (which stands for the logical or) and & (which stands for the logical and).\n\n\n\n\n\n\nWarning\n\n\n\nThe or and and python statements require truth-values. For pandas these are considered ambiguous so you should use \"bitwise\" | (or) or & (and) operations.\n\n\nWe next create a categorical variable that indicates whether somebody is Mexican or Hispanic.\n\n\nPython Code\nR Code\n\n\n\n\ndf['d_Mex_Hisp'] = 0\ndf.loc[((df['Race'] == 'Mex') | (df['Race'] == 'Hisp')), 'd_Mex_Hisp'] = 1\n\n\n\nThis code creates a new dummy variable d_Mex_Hisp and sets it to 1 if the person’s race is either ‘Mex’ or ‘Hisp’, and 0 otherwise.\n\n# Create a new dummy variable\ndf$d_Mex_Hisp &lt;- 0\n\n# Set the new dummy variable based on conditions\ndf$d_Mex_Hisp[df$Race %in% c('Mex', 'Hisp')] &lt;- 1\nprint(head(df))\n\n  Height Response AvgMathSAT Age Female Education Race d_Wht d_Blk d_Mex d_Hisp\n1    1.1        3        370  20      0         2 Hisp     0     0     0      1\n2    1.2        4        393  20      0         4  Wht     1     0     0      0\n3    1.3        4        413  20      0         4  Blk     0     1     0      0\n4    1.4        5        430  20      0         4  Wht     1     0     0      0\n5    1.5        3        440  20      0         2  Mex     0     0     1      0\n6    1.6        5        448  20      0         4  Blk     0     1     0      0\n  d_Oth d_Mex_Hisp\n1     0          1\n2     0          0\n3     0          0\n4     0          0\n5     0          1\n6     0          0\n\n\n\n\n\nHere is the quick way to make dummy variables out of a categorical variables with distinct categories. I first import the data again, so we can work with the original (raw) data.\n\n\nPython Code\nR Code\n\n\n\n\ndf = pd.read_csv(filepath + 'Lecture_Data_Excel_b.csv')\n\ndummies = pd.get_dummies(df['Race'], prefix = 'd')\ndf = df.join(dummies)\nprint(df.head())\n\n   Height  Response  AverageMathSAT  Age  Female  ...  d_Blk d_Hisp  d_Mex  d_Oth  d_Wht\n0     1.1         3             370   20       0  ...      0      1      0      0      0\n1     1.2         4             393   20       0  ...      0      0      0      0      1\n2     1.3         4             413   20       0  ...      1      0      0      0      0\n3     1.4         5             430   20       0  ...      0      0      0      0      1\n4     1.5         3             440   20       0  ...      0      0      1      0      0\n\n[5 rows x 12 columns]\n\n\n\n\nThis code creates dummy variables for the ‘Race’ column, renames them with a prefix ‘d_’, and then joins them to the original dataframe. The model.matrix function is used to create the dummy variables.\n\n# Load the data\ndf &lt;- read.csv(paste0(filepath, 'Lecture_Data_Excel_b.csv'))\nprint(head(df))\n\n  Height Response AverageMathSAT Age Female Education Race\n1    1.1        3            370  20      0         2 Hisp\n2    1.2        4            393  20      0         4  Wht\n3    1.3        4            413  20      0         4  Blk\n4    1.4        5            430  20      0         4  Wht\n5    1.5        3            440  20      0         2  Mex\n6    1.6        5            448  20      0         4  Blk\n\n# Create dummy variables for the 'Race' column\ndummies &lt;- model.matrix(~ Race - 1, data = df)\n\n# Rename the dummy variables with a prefix 'd'\n\n# Rename the dummy variables for clarity\ncolnames(dummies) &lt;- gsub(\"Race\", \"d_\", colnames(dummies))\n\n# Combine the dummy variables with the original data frame\ndf &lt;- cbind(df, dummies)\n\n# Print the first few rows of the updated dataframe\nhead(df)\n\n  Height Response AverageMathSAT Age Female Education Race d_Blk d_Hisp d_Mex\n1    1.1        3            370  20      0         2 Hisp     0      1     0\n2    1.2        4            393  20      0         4  Wht     0      0     0\n3    1.3        4            413  20      0         4  Blk     1      0     0\n4    1.4        5            430  20      0         4  Wht     0      0     0\n5    1.5        3            440  20      0         2  Mex     0      0     1\n6    1.6        5            448  20      0         4  Blk     1      0     0\n  d_Oth d_Wht\n1     0     0\n2     0     1\n3     0     0\n4     0     1\n5     0     0\n6     0     0\n\n\n\n\n\nWe next use OLS again to run the regression. At the end we make a prediction based on some values for the independent variables x1, x2, etc.\nWhen you specify your regression with the race-dummy variable you need to make sure that you drop one of the dummy variables. Here I drop the d_wht category, which is referred to as base category because we dropped it. This is arbitrary but you need to drop one of the categories as you otherwise have the probelm of perfect multicollinearity.\n\n\nPython Code\nR Code\n\n\n\n\nimport statsmodels.api as sm\nfrom patsy import dmatrices\n\ny, X = dmatrices('Height ~ Age + Education + Female + d_Blk + d_Hisp + d_Mex + d_Oth', data=df, return_type='dataframe')\nres = sm.OLS(y, X).fit()\n\n# Show coefficient estimates\nprint(res.summary())\nprint()\nprint('Parameters:')\nprint(res.params)\n\n                            OLS Regression Results                            \n==============================================================================\nDep. Variable:                 Height   R-squared:                       0.944\nModel:                            OLS   Adj. R-squared:                  0.936\nMethod:                 Least Squares   F-statistic:                     124.4\nDate:                Mon, 25 Mar 2024   Prob (F-statistic):           3.52e-30\nTime:                        15:48:30   Log-Likelihood:                -74.722\nNo. Observations:                  60   AIC:                             165.4\nDf Residuals:                      52   BIC:                             182.2\nDf Model:                           7                                         \nCovariance Type:            nonrobust                                         \n==============================================================================\n                 coef    std err          t      P&gt;|t|      [0.025      0.975]\n------------------------------------------------------------------------------\nIntercept    -35.1898      2.662    -13.220      0.000     -40.531     -29.849\nAge            1.8944      0.124     15.269      0.000       1.645       2.143\nEducation     -0.0514      0.127     -0.406      0.686      -0.305       0.203\nFemale         8.7359      0.308     28.387      0.000       8.118       9.353\nd_Blk         -0.4600      0.299     -1.540      0.130      -1.059       0.139\nd_Hisp        -1.1084      0.534     -2.074      0.043      -2.181      -0.036\nd_Mex         -0.6566      0.338     -1.941      0.058      -1.335       0.022\nd_Oth         -0.0816      0.681     -0.120      0.905      -1.448       1.285\n==============================================================================\nOmnibus:                        0.297   Durbin-Watson:                   0.581\nProb(Omnibus):                  0.862   Jarque-Bera (JB):                0.478\nSkew:                          -0.097   Prob(JB):                        0.787\nKurtosis:                       2.607   Cond. No.                         486.\n==============================================================================\n\nNotes:\n[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.\n\nParameters:\nIntercept   -35.189807\nAge           1.894377\nEducation    -0.051375\nFemale        8.735906\nd_Blk        -0.459986\nd_Hisp       -1.108371\nd_Mex        -0.656576\nd_Oth        -0.081628\ndtype: float64\n\n\n\n\n\n# Perform linear regression\nlm_model &lt;- lm(Height ~ Age + Education + Female + d_Blk + d_Hisp + d_Mex + d_Oth, data = df)\n\n# Print the summary of the regression results\nsummary(lm_model)\n\n# Print the coefficient estimates\ncat('Parameters:\\n')\ncat(coef(lm_model))\n\n\nCall:\nlm(formula = Height ~ Age + Education + Female + d_Blk + d_Hisp + \n    d_Mex + d_Oth, data = df)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-2.23089 -0.56884 -0.02689  0.62088  1.72843 \n\nCoefficients:\n             Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) -35.18981    2.66179 -13.220   &lt;2e-16 ***\nAge           1.89438    0.12407  15.269   &lt;2e-16 ***\nEducation    -0.05137    0.12655  -0.406   0.6864    \nFemale        8.73591    0.30774  28.387   &lt;2e-16 ***\nd_Blk        -0.45999    0.29867  -1.540   0.1296    \nd_Hisp       -1.10837    0.53440  -2.074   0.0430 *  \nd_Mex        -0.65658    0.33824  -1.941   0.0577 .  \nd_Oth        -0.08163    0.68085  -0.120   0.9050    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.903 on 52 degrees of freedom\nMultiple R-squared:  0.9437,    Adjusted R-squared:  0.9361 \nF-statistic: 124.4 on 7 and 52 DF,  p-value: &lt; 2.2e-16\n\nParameters:\n-35.18981 1.894377 -0.05137474 8.735906 -0.4599857 -1.108371 -0.6565762 -0.08162771\n\n\n\n\n\nWhen you interpret the coefficient estimates of the race dummy variables, you interpret them in relation to the dropped category, which is \"white\" in my case. Here this would mean that on average, African Americans are \\(-0.46\\) units of height shorter than individuals in the base category that we have omitted. Similarly , on average Hispanics are \\(-1.1084\\) height units shorter than individuals in the base category. Keep in mind that these estimates are not really statistically significant (large p-values) and the sample is extremely small. So be careful with your statements!\nPrediction: If age = 20, education = 12 years, gender = female and you are Mexican then the predicted height is ...\n\n\nPython Code\nR Code\n\n\n\n\n# Take out results and define it as numpy-vector\nbetas = res.params.values\nprint(\"Prediction: {}\".\\\n  format(np.sum(betas * np.array([1, 20, 12, 1, 0, 0, 1,0]))))\n\nPrediction: 10.16056748631939\n\n\n\n\n\n# Define a vector of independent variables\nindependent_vars &lt;- c(1, 20, 12, 1, 0, 0, 1, 0)\n\n# Make a prediction for the given independent variables\nprediction &lt;- predict(lm_model, newdata = data.frame(independent_vars))\n\nError in eval(predvars, data, env): object 'Age' not found\n\n# Print the prediction\ncat('Prediction:', prediction)\n\nError in eval(expr, envir, enclos): object 'prediction' not found\n\n\n\n\n\nAnd here is the residual plot again to check for heteroskedasticity:\n\n\nPython Code\nR Code\n\n\n\n\nyv = y['Height'].values\ny_hatv = res.predict(X).values  # Predicts y-hat based on all X values in data\nresidualsv = yv - y_hatv\n\nfig, ax = plt.subplots()\nax.set_title('Residual Plot')\nax.plot(yv, residualsv, 'o', label = 'data')\nax.plot(yv, np.zeros(len(yv)),'k-')\nax.set_xlabel('Height (Y dependent variable)')\nplt.show()\n\n\n\n\n\n\nfig, ax = plt.subplots()\nax.set_title('Residual Plot')\nax.plot(y_hatv, residualsv, 'o', label = 'data')\nax.plot(y_hatv, np.zeros(len(yv)),'k-')\nax.set_xlabel('Predicted-Height (Y_hat variable)')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# Estimate model with dummies\nlm_model &lt;- lm(Height ~ Age + Education + Female + d_Blk + d_Hisp + d_Mex + d_Oth, data = df)\n\n# Calculate residuals\nresiduals &lt;- residuals(lm_model)\n\n# Create a residual plot\nresidual_plot &lt;- ggplot(data = NULL, aes(x = fitted(lm_model), y = residuals)) +\n  geom_point() +\n  geom_hline(yintercept = 0, linetype = \"dashed\", color = \"red\") +\n  xlab(\"Fitted Values\") +\n  ylab(\"Residuals\") +\n  ggtitle(\"Residual Plot\")\n\n# Display the residual plot\nprint(residual_plot)\n\n\n\n\n\n\n\n\n\n\n\n12.4.5 Regression: Example 2 Again\nA quicker way of implementing regressions with categorical variables is to use the C() syntax for categorical variables. This will automatically generate the categories and add them to your regression and drop one of the categories, here it is the “Black” race category.\n\nimport statsmodels.api as sm\nfrom patsy import dmatrices\n\ny, X = dmatrices('Height ~ Age + Education + Female + C(Race)', data=df, return_type='dataframe')\nres = sm.OLS(y, X).fit()\n\n# Show coefficient estimates\nprint(res.summary())\n\n                            OLS Regression Results                            \n==============================================================================\nDep. Variable:                 Height   R-squared:                       0.944\nModel:                            OLS   Adj. R-squared:                  0.936\nMethod:                 Least Squares   F-statistic:                     124.4\nDate:                Mon, 25 Mar 2024   Prob (F-statistic):           3.52e-30\nTime:                        15:48:33   Log-Likelihood:                -74.722\nNo. Observations:                  60   AIC:                             165.4\nDf Residuals:                      52   BIC:                             182.2\nDf Model:                           7                                         \nCovariance Type:            nonrobust                                         \n===================================================================================\n                      coef    std err          t      P&gt;|t|      [0.025      0.975]\n-----------------------------------------------------------------------------------\nIntercept         -35.6498      2.628    -13.566      0.000     -40.923     -30.377\nC(Race)[T.Hisp]    -0.6484      0.549     -1.181      0.243      -1.750       0.453\nC(Race)[T.Mex]     -0.1966      0.339     -0.580      0.564      -0.876       0.483\nC(Race)[T.Oth]      0.3784      0.686      0.552      0.583      -0.997       1.754\nC(Race)[T.Wht]      0.4600      0.299      1.540      0.130      -0.139       1.059\nAge                 1.8944      0.124     15.269      0.000       1.645       2.143\nEducation          -0.0514      0.127     -0.406      0.686      -0.305       0.203\nFemale              8.7359      0.308     28.387      0.000       8.118       9.353\n==============================================================================\nOmnibus:                        0.297   Durbin-Watson:                   0.581\nProb(Omnibus):                  0.862   Jarque-Bera (JB):                0.478\nSkew:                          -0.097   Prob(JB):                        0.787\nKurtosis:                       2.607   Cond. No.                         480.\n==============================================================================\n\nNotes:\n[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.\n\nprint()\nprint('Parameters:')\n\nParameters:\n\nprint(res.params)\n\nIntercept         -35.649793\nC(Race)[T.Hisp]    -0.648385\nC(Race)[T.Mex]     -0.196591\nC(Race)[T.Oth]      0.378358\nC(Race)[T.Wht]      0.459986\nAge                 1.894377\nEducation          -0.051375\nFemale              8.735906\ndtype: float64",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Working with Data II: Statistics</span>"
    ]
  },
  {
    "objectID": "Data-2.html#measures-of-non-linear-relationship",
    "href": "Data-2.html#measures-of-non-linear-relationship",
    "title": "\n12  Working with Data II: Statistics\n",
    "section": "\n12.5 Measures of Non-Linear Relationship",
    "text": "12.5 Measures of Non-Linear Relationship\nWe next demonstrate how to run Probit and Logit regressions. These type of regression models are used when the dependent variable is a categorical 0/1 variable. If you instead ran a simple linear OLS regression on such a variable, the possible predictions from this linear probability model could fall outside of the [0,1] range. The Probit and Logit specifications ensure that predictions are probabilities that will fall within the [0,1] range.\nMake sure that you have already downloaded the Excel data file Lecture_Data_Excel_c.xlsx &lt;Lecture_Data/Lecture_Data_Excel_c.xlsx&gt;.\nWe next import the Excel file data directly from Excel using the pd.read_excel() function from Pandas.\n\n\n\n\n\n\nImportant\n\n\n\nIn order for this to work you need to make sure that the xlrd package is installed. Open a terminal window and type:\nconda install xlrd\nPress yes at the prompt and it will install the package.\n\n\nYou can now use the command. It is important to specify the Excel Sheet that you want to import data from since an Excel file can have multiple spreadsheets inside.\nIn our example the data resides in the sheet with the name binary. So we specify this in the excel_read() function.\n\n\nPython Code\nR Code\n\n\n\n\n# Read entire excel spreadsheet\nfilepath = 'Lecture_Data/'\ndf = pd.read_excel(filepath + \"Lecture_Data_Excel_c.xlsx\", 'binary')\n\n# Check how many sheets we have inside the excel file\n#xl.sheet_names\n\n# Pick one sheet and define it as your DataFrame by parsing a sheet\n#df = xl.parse(\"binary\")\n\nprint(df.head())\n\n# rename the 'rank' column because there is also a DataFrame method called 'rank'\n\n   admit  gre   gpa  rank\n0      0  380  3.61     3\n1      1  660  3.67     3\n2      1  800  4.00     1\n3      1  640  3.19     4\n4      0  520  2.93     4\n\ndf.columns = [\"admit\", \"gre\", \"gpa\", \"prestige\"]\n\n\n\n\n# Load the \"readxl\" library for Excel file reading\nlibrary(readxl)\n\n# Define the file path\nfilepath &lt;- \"Lecture_Data/\"\n\n# Read the Excel file\ndf &lt;- read_excel(file.path(filepath, \"Lecture_Data_Excel_c.xlsx\"), sheet = \"binary\")\n\n# Display the first few rows of the DataFrame\nhead(df)\n\n# A tibble: 6 × 4\n  admit   gre   gpa  rank\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     0   380  3.61     3\n2     1   660  3.67     3\n3     1   800  4        1\n4     1   640  3.19     4\n5     0   520  2.93     4\n6     1   760  3        2\n\n# Rename the 'rank' column\ncolnames(df)[colnames(df) == \"rank\"] &lt;- \"prestige\"\n\nhead(df)\n\n# A tibble: 6 × 4\n  admit   gre   gpa prestige\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n1     0   380  3.61        3\n2     1   660  3.67        3\n3     1   800  4           1\n4     1   640  3.19        4\n5     0   520  2.93        4\n6     1   760  3           2\n\n\n\n\n\nWe next make dummies out of the rank variable.\n\n\nPython Code\nR Code\n\n\n\n\n# dummify rank\ndummy_ranks = pd.get_dummies(df['prestige'], prefix='d_prest')\n\n# Join dataframes\ndf = df.join(dummy_ranks)\nprint(df.head())\n\n   admit  gre   gpa  prestige  d_prest_1  d_prest_2  d_prest_3  d_prest_4\n0      0  380  3.61         3          0          0          1          0\n1      1  660  3.67         3          0          0          1          0\n2      1  800  4.00         1          1          0          0          0\n3      1  640  3.19         4          0          0          0          1\n4      0  520  2.93         4          0          0          0          1\n\n\n\n\n\n# Create dummy variables\ndf$d_prest_1 &lt;- 0\ndf$d_prest_2 &lt;- 0\ndf$d_prest_3 &lt;- 0\ndf$d_prest_4 &lt;- 0\n\n# Set dummy variables based on race\ndf$d_prest_1 &lt;- ifelse(df$prestige == 1, 1, 0)\ndf$d_prest_2 &lt;- ifelse(df$prestige == 2, 1, 0)\ndf$d_prest_3 &lt;- ifelse(df$prestige == 3, 1, 0)\ndf$d_prest_4 &lt;- ifelse(df$prestige == 4, 1, 0)\n\nprint(head(df))\n\n# A tibble: 6 × 8\n  admit   gre   gpa prestige d_prest_1 d_prest_2 d_prest_3 d_prest_4\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n1     0   380  3.61        3         0         0         1         0\n2     1   660  3.67        3         0         0         1         0\n3     1   800  4           1         1         0         0         0\n4     1   640  3.19        4         0         0         0         1\n5     0   520  2.93        4         0         0         0         1\n6     1   760  3           2         0         1         0         0\n\n\n\n\n\n\n12.5.1 Logit\nWe now estimate a Logit model as follows:\n\n\nPython Code\nR Code\n\n\n\n\n# Import the correct version of statsmodels\nimport statsmodels.api as sm\nfrom patsy import dmatrices\n\ny, X = dmatrices('admit ~ gre + gpa + d_prest_2 + d_prest_3 + d_prest_4', data=df, return_type='dataframe')\n\n# Define the model\nlogit = sm.Logit(y, X)\n\n# fit the model\nres = logit.fit()\n\n# Print results\n\nOptimization terminated successfully.\n         Current function value: 0.573147\n         Iterations 6\n\nprint(res.summary())\n\n                           Logit Regression Results                           \n==============================================================================\nDep. Variable:                  admit   No. Observations:                  400\nModel:                          Logit   Df Residuals:                      394\nMethod:                           MLE   Df Model:                            5\nDate:                Mon, 25 Mar 2024   Pseudo R-squ.:                 0.08292\nTime:                        15:48:36   Log-Likelihood:                -229.26\nconverged:                       True   LL-Null:                       -249.99\nCovariance Type:            nonrobust   LLR p-value:                 7.578e-08\n==============================================================================\n                 coef    std err          z      P&gt;|z|      [0.025      0.975]\n------------------------------------------------------------------------------\nIntercept     -3.9900      1.140     -3.500      0.000      -6.224      -1.756\ngre            0.0023      0.001      2.070      0.038       0.000       0.004\ngpa            0.8040      0.332      2.423      0.015       0.154       1.454\nd_prest_2     -0.6754      0.316     -2.134      0.033      -1.296      -0.055\nd_prest_3     -1.3402      0.345     -3.881      0.000      -2.017      -0.663\nd_prest_4     -1.5515      0.418     -3.713      0.000      -2.370      -0.733\n==============================================================================\n\n\n\n\nThis code defines a logistic regression model using the glm function, specifying the formula and the data frame. The family argument is set to “binomial” to indicate a logistic regression. Then, the summary function is used to print the results.\n\n# Define the logistic regression model\nlogit_model &lt;- glm(admit ~ gre + gpa  + d_prest_2 + d_prest_3 + d_prest_4, data = df, family = \"binomial\")\n\n# Print results\nsummary(logit_model)\n\n\nCall:\nglm(formula = admit ~ gre + gpa + d_prest_2 + d_prest_3 + d_prest_4, \n    family = \"binomial\", data = df)\n\nCoefficients:\n             Estimate Std. Error z value Pr(&gt;|z|)    \n(Intercept) -3.989979   1.139951  -3.500 0.000465 ***\ngre          0.002264   0.001094   2.070 0.038465 *  \ngpa          0.804038   0.331819   2.423 0.015388 *  \nd_prest_2   -0.675443   0.316490  -2.134 0.032829 *  \nd_prest_3   -1.340204   0.345306  -3.881 0.000104 ***\nd_prest_4   -1.551464   0.417832  -3.713 0.000205 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 499.98  on 399  degrees of freedom\nResidual deviance: 458.52  on 394  degrees of freedom\nAIC: 470.52\n\nNumber of Fisher Scoring iterations: 4\n\n\n\n\n\nA Slightly different summary\n\nprint(res.summary2())\n\n                         Results: Logit\n=================================================================\nModel:              Logit            Method:           MLE       \nDependent Variable: admit            Pseudo R-squared: 0.083     \nDate:               2024-03-25 15:48 AIC:              470.5175  \nNo. Observations:   400              BIC:              494.4663  \nDf Model:           5                Log-Likelihood:   -229.26   \nDf Residuals:       394              LL-Null:          -249.99   \nConverged:          1.0000           LLR p-value:      7.5782e-08\nNo. Iterations:     6.0000           Scale:            1.0000    \n------------------------------------------------------------------\n               Coef.   Std.Err.     z     P&gt;|z|    [0.025   0.975]\n------------------------------------------------------------------\nIntercept     -3.9900    1.1400  -3.5001  0.0005  -6.2242  -1.7557\ngre            0.0023    0.0011   2.0699  0.0385   0.0001   0.0044\ngpa            0.8040    0.3318   2.4231  0.0154   0.1537   1.4544\nd_prest_2     -0.6754    0.3165  -2.1342  0.0328  -1.2958  -0.0551\nd_prest_3     -1.3402    0.3453  -3.8812  0.0001  -2.0170  -0.6634\nd_prest_4     -1.5515    0.4178  -3.7131  0.0002  -2.3704  -0.7325\n=================================================================\n\n\nAnd here is the residual plot again to check for heteroskedasticity:\n\n\nPython Code\nR Code\n\n\n\n\nyv = y['admit'].values\ny_hatv = res.predict(X).values  # Predicts y-hat based on all X values in data\nresidualsv = yv - y_hatv\n\nfig, ax = plt.subplots()\nax.set_title('Residual Plot')\nax.plot(yv, residualsv, 'o', label = 'data')\nax.plot(yv, np.zeros(len(yv)),'k-')\nax.set_xlabel('admit (Y dependent variable)')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# Calculate residuals\nresiduals &lt;- residuals(logit_model)\n\n# Create a residual plot\nresidual_plot &lt;- ggplot(data = NULL, aes(x = fitted(logit_model), y = residuals)) +\n  geom_point() +\n  geom_hline(yintercept = 0, linetype = \"dashed\", color = \"red\") +\n  xlab(\"Fitted Values\") +\n  ylab(\"Residuals\") +\n  ggtitle(\"Residual Plot of Logit Model\")\n\n# Display the residual plot\nprint(residual_plot)\n\n\n\n\n\n\n\n\n\n\nNot surprisingly we see that since the dependent variable can only take on the values 0 or 1, the residual plot shows only residuals at these two locations.\n\n\n\n\n\n\nMachine Learning Library: scikit-learn.org\n\n\n\nIf you are mostly interested in prediction. You can also use the much faster implementation of the logit regression in the scikit-learn library.\n\n# Import the logit regression from scikit learn\nfrom sklearn.linear_model import LogisticRegression\nfrom patsy import dmatrices\n\ny, X = dmatrices('admit ~ gre + gpa + d_prest_2 + d_prest_3 + d_prest_4', data=df, return_type='matrix')\n\n# Define the model and fit it\n#res = LogisticRegression(random_state=0).fit(X,y.values.ravel())\nres = LogisticRegression(random_state=0).fit(X,y.ravel())\n\n# Print predictions of y --&gt; either 0 or 1 values\n# Predict for the first two rows in the data\nprint(res.predict(X[:2,:]))\n\n# Predict probability of y=0 and y=1\n# Predict for the first two rows in the data\n\n[0. 0.]\n\nprint(res.predict_proba(X[:2,:]))\n\n[[0.82072211 0.17927789]\n [0.70197308 0.29802692]]\n\n\n\n\n\n12.5.2 Probit\nIf you want to run a Probit regression, you can do:\n\n\nPython Code\nR Code\n\n\n\n\nimport statsmodels.api as sm\nfrom patsy import dmatrices\n\ny, X = dmatrices('admit ~ gre + gpa + d_prest_2 + d_prest_3 + d_prest_4', data=df, return_type='dataframe')\n# Define the model\nprobit = sm.Probit(y, X)\n\n# Fit the model\nres = probit.fit()\n\n# Print results\n\nOptimization terminated successfully.\n         Current function value: 0.573016\n         Iterations 5\n\nprint(res.summary())\n\n                          Probit Regression Results                           \n==============================================================================\nDep. Variable:                  admit   No. Observations:                  400\nModel:                         Probit   Df Residuals:                      394\nMethod:                           MLE   Df Model:                            5\nDate:                Mon, 25 Mar 2024   Pseudo R-squ.:                 0.08313\nTime:                        15:48:40   Log-Likelihood:                -229.21\nconverged:                       True   LL-Null:                       -249.99\nCovariance Type:            nonrobust   LLR p-value:                 7.219e-08\n==============================================================================\n                 coef    std err          z      P&gt;|z|      [0.025      0.975]\n------------------------------------------------------------------------------\nIntercept     -2.3868      0.674     -3.541      0.000      -3.708      -1.066\ngre            0.0014      0.001      2.120      0.034       0.000       0.003\ngpa            0.4777      0.195      2.444      0.015       0.095       0.861\nd_prest_2     -0.4154      0.195     -2.126      0.033      -0.798      -0.032\nd_prest_3     -0.8121      0.209     -3.893      0.000      -1.221      -0.403\nd_prest_4     -0.9359      0.246     -3.810      0.000      -1.417      -0.454\n==============================================================================\n\n\n\n\nThis code defines a probit regression model using the glm function, specifying the formula and the data frame. The family argument is set to binomial, and the link argument is set to “probit” to indicate a probit regression. Then, the summary function is used to print the results.\n\n# Define the probit regression model\nmodel &lt;- glm(admit ~ gre + gpa + + d_prest_2 + d_prest_3 + d_prest_4, data = df, family = binomial(link = \"probit\"))\n\n# Print results\nsummary(model)\n\n\nCall:\nglm(formula = admit ~ gre + gpa + +d_prest_2 + d_prest_3 + d_prest_4, \n    family = binomial(link = \"probit\"), data = df)\n\nCoefficients:\n             Estimate Std. Error z value Pr(&gt;|z|)    \n(Intercept) -2.386836   0.673946  -3.542 0.000398 ***\ngre          0.001376   0.000650   2.116 0.034329 *  \ngpa          0.477730   0.197197   2.423 0.015410 *  \nd_prest_2   -0.415399   0.194977  -2.131 0.033130 *  \nd_prest_3   -0.812138   0.208358  -3.898 9.71e-05 ***\nd_prest_4   -0.935899   0.245272  -3.816 0.000136 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 499.98  on 399  degrees of freedom\nResidual deviance: 458.41  on 394  degrees of freedom\nAIC: 470.41\n\nNumber of Fisher Scoring iterations: 4\n\n\n\n\n\nA Slightly different summary\n\nprint(res.summary2())\n\n                         Results: Probit\n=================================================================\nModel:              Probit           Method:           MLE       \nDependent Variable: admit            Pseudo R-squared: 0.083     \nDate:               2024-03-25 15:48 AIC:              470.4132  \nNo. Observations:   400              BIC:              494.3620  \nDf Model:           5                Log-Likelihood:   -229.21   \nDf Residuals:       394              LL-Null:          -249.99   \nConverged:          1.0000           LLR p-value:      7.2189e-08\nNo. Iterations:     5.0000           Scale:            1.0000    \n------------------------------------------------------------------\n               Coef.   Std.Err.     z     P&gt;|z|    [0.025   0.975]\n------------------------------------------------------------------\nIntercept     -2.3868    0.6741  -3.5408  0.0004  -3.7080  -1.0656\ngre            0.0014    0.0006   2.1200  0.0340   0.0001   0.0026\ngpa            0.4777    0.1955   2.4441  0.0145   0.0946   0.8608\nd_prest_2     -0.4154    0.1954  -2.1261  0.0335  -0.7983  -0.0325\nd_prest_3     -0.8121    0.2086  -3.8934  0.0001  -1.2210  -0.4033\nd_prest_4     -0.9359    0.2456  -3.8101  0.0001  -1.4173  -0.4545\n=================================================================",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Working with Data II: Statistics</span>"
    ]
  },
  {
    "objectID": "Data-2.html#tutorials",
    "href": "Data-2.html#tutorials",
    "title": "\n12  Working with Data II: Statistics\n",
    "section": "\n12.6 Tutorials",
    "text": "12.6 Tutorials\nSome of the notes above are summaries of these tutorials:\n\nyhat-Blog\nStatsmodels library\n\n\n\n\n\n\n\nKey Concepts and Summary\n\n\n\n\nBasic statistics\nRegression analysis\nNonlinear models\n\n\n\n\n\n\n\n\n\nSelf-check questions\n\n\n\n\n\n\n..",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Working with Data II: Statistics</span>"
    ]
  },
  {
    "objectID": "Data-3.html",
    "href": "Data-3.html",
    "title": "13  Working with Data III: Maps and Geospatial Data",
    "section": "",
    "text": "13.1 Importing Data\nWe will be working with data from the Johns Hopkins Whiting School of Engineering, Center for Systems Science and Engineering. Their Github portal is at: https://github.com/CSSEGISandData\nThis is the data repository for the 2019 Novel Coronavirus Visual Dashboard operated by the Johns Hopkins University Center for Systems Science and Engineering (JHU CSSE). Also, Supported by ESRI Living Atlas Team and the Johns Hopkins University Applied Physics Lab (JHU APL).\nYou can find their dashboard with all the visual information under this link: Dashboard\nWe will use their data (it's updated twice daily) and make our own graphs. We first need to import the data from their website. We can simply do this with a Pandas function .read_csv().\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# ----------------------------------------\ni_downloadData = 1   # Indicator flag whether you want to freshly download the\n                     # data\n# ----------------------------------------\n\nif i_downloadData == 1:\n    urlBase = 'https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/'\n    urlConf = urlBase + 'time_series_covid19_confirmed_global.csv'\n    urlDead = urlBase + 'time_series_covid19_deaths_global.csv'\n    urlRec  = urlBase + 'time_series_covid19_recovered_global.csv'\n\n    # Download and Save\n    dfConf = pd.read_csv(urlConf, on_bad_lines='skip')\n    #dfConf.to_pickle('CoronaConfirmed')\n\n    dfDead = pd.read_csv(urlDead, on_bad_lines='skip')\n    #dfDead.to_pickle('CoronaDeath')\n\n    dfRec = pd.read_csv(urlRec, on_bad_lines='skip')\n    #dfRec.to_pickle('CoronaRecovered')\nInstead of saving the data to a file I will simply assign the imported data into a new dataframe that I am not going to manipulate.\ndfConf_orig = dfConf.copy()\ndfDead_orig = dfDead.copy()\ndfRec_orig  = dfRec.copy()\nFor each application I will then copy the original data from the _orig dataframes.\nHave a careful look at the data. Use the Variable Explorer tab in Spyder to investigate the dataframe. The nature of your data is basically an observation over time of confirmed corona virus infections by Province/State as the \"smallest\" geographical denominator. You also know which country the Pronvince/State belongs to (you see this in the second column) and then you also have the Latitude/Longitude coordinates of the Province/State from which the corona cases are reported from. This is followed by daily observations from this Province/State.",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Working with Data III: Maps and Geospatial Data</span>"
    ]
  },
  {
    "objectID": "Data-3.html#importing-data",
    "href": "Data-3.html#importing-data",
    "title": "13  Working with Data III: Maps and Geospatial Data",
    "section": "",
    "text": "Note\n\n\n\nIf you want to locally store the data and not download the data everytime you run your script file you could save the data first with:\n# Save data locally on harddrive\n\ndfConf.to_pickle(\\'CoronaConfirmed\\') dfDead.to_pickle(\\'CoronaDeath\\')\ndfRec.to_pickle(\\'CoronaRecovered\\')\nAnd then simply read it from your harddisk using:\n# Read data from harddrive\n\ndfConf = pd.read_pickle(\\'CoronaConfirmed\\') dfDead =\npd.read_pickle(\\'CoronaDeath\\') dfRec=\npd.read_pickle(\\'CoronaRecovered\\')\nYou would then of course have to \"outcomment\" the webreading section above or set the i_downloadData flag equal to zero so that the downloading part gets skipped.",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Working with Data III: Maps and Geospatial Data</span>"
    ]
  },
  {
    "objectID": "Data-3.html#plotting-cases-of-infections",
    "href": "Data-3.html#plotting-cases-of-infections",
    "title": "13  Working with Data III: Maps and Geospatial Data",
    "section": "13.2 Plotting Cases of Infections",
    "text": "13.2 Plotting Cases of Infections\nI first copy the original data into new dataframes because I want to keep the raw data intact and untouched in case I want to come back to it later, which we will!\n\ndfConf = dfConf_orig.copy()\ndfDead = dfDead_orig.copy()\ndfRec  = dfRec_orig.copy()\n\nWe next add a column with the sum of all the confirmed coronavirus cases for each Province/State. In other words, we sum up all the columns of the time series of cases which starts in column five, so that we go from [4:] to the end.\n\ndfConf['Confirmed']=dfConf.iloc[:,-1]\ndfDead['Dead']=dfDead.iloc[:,-1]\ndfRec['Recovered']=dfRec.iloc[:,-1]\n\nWe then drop the entire time series and only keep the overall sum of cases. We are not interested in the single day observations for this first summary graph.\n\ndfConf.drop(dfConf.iloc[:, 4:-2], inplace = True, axis = 1)\ndfDead.drop(dfDead.iloc[:, 4:-2], inplace = True, axis = 1)\ndfRec.drop(dfRec.iloc[:, 4:-2], inplace = True, axis = 1)\n\nWe next merge the three dataframes together by Province/State, Country/Region, Lat, and Long variables so that we have the sum of all confirmed infection cases, the sum of all corona virus associated deaths, and the sum of all the recovered cases for each Province/State in the same dataframe.\n\ndftemp = pd.merge(dfConf, dfDead, \\\n   on=['Province/State', 'Country/Region','Lat','Long'], how='inner')\ndf = pd.merge(dftemp, dfRec, \\\n   on=['Province/State', 'Country/Region','Lat','Long'], how='inner')\n\nWe have now one dataframe with the sum of all confirmed coronavirus cases, the sum of all deaths due to corona virus, as well as the sum of all recorded recoveries from a coronavirus infection.\nWe next plot the infection cases by their latitude and longitude of the province/state where they were recorded. We plot circles and use the number of cases per 1000 as circle size. The larger the circle in the plot, the more cases have been recorded for the Latitude/Longitude coordinate.\n\nax = df.plot(kind=\"scatter\", x=\"Long\", y=\"Lat\", alpha=0.4,\n    s=df[\"Confirmed\"]/100000, label=\"Confirmed Infections\", color = \"Blue\")\ndf.plot(kind=\"scatter\", x=\"Long\", y=\"Lat\", alpha=0.4,\n    s=df[\"Dead\"]/100000, label=\"Deaths\", color=\"Red\", ax=ax)\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\nFigure 13.1: Confirmed Infections and Deaths by 100000\n\n\n\n\n\nFrom this graph you can already see the outline of countries. However, it would be better if we could superimpose the information onto a real map of the world. We do this next.",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Working with Data III: Maps and Geospatial Data</span>"
    ]
  },
  {
    "objectID": "Data-3.html#plotting-cases-of-infections-on-a-map",
    "href": "Data-3.html#plotting-cases-of-infections-on-a-map",
    "title": "13  Working with Data III: Maps and Geospatial Data",
    "section": "13.3 Plotting Cases of Infections on a Map",
    "text": "13.3 Plotting Cases of Infections on a Map\nWe next use the Cartopy library to plot the same information superimposed on a worl map.\n\n\n\n\n\n\nNote\n\n\n\nYou will need to install the cartopy library via the command line. Open a command line terminal and type:\nconda install cartopy\nFollowed by enter, then hit y for yes when it prompts you. This should install the cartopy library.\n\n\nWe will next import the cartopy library and superimpose the same plot on a World map in Figure 13.2 .\n\nimport cartopy.crs as ccrs\n\n\nfig = plt.figure(figsize=(8, 10))\nax = plt.axes(projection=ccrs.PlateCarree())\nax.coastlines()\nplt.scatter(df['Long'].values, df['Lat'].values, transform=ccrs.PlateCarree(), \\\n        label=None, s=df[\"Confirmed\"]/100000, c=\"Blue\", linewidth=0, alpha=0.4)\nplt.scatter(df['Long'].values, df['Lat'].values, transform=ccrs.PlateCarree(), \\\n        label=None, s=df[\"Dead\"]/100000, c=\"Red\", linewidth=0, alpha=0.4)\n\nplt.legend()\nplt.show()\n\nNo artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.\n\n\n\n\n\n\n\n\nFigure 13.2: Confirmed Infections and Deaths by 100000 with World Map Superimposed\n\n\n\n\n\nYou now have a nice plot of the world map and the corona cases superimposed on it.",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Working with Data III: Maps and Geospatial Data</span>"
    ]
  },
  {
    "objectID": "Data-3.html#plotting-time-series-of-cases",
    "href": "Data-3.html#plotting-time-series-of-cases",
    "title": "13  Working with Data III: Maps and Geospatial Data",
    "section": "13.4 Plotting Time Series of Cases",
    "text": "13.4 Plotting Time Series of Cases\nWe now go back to the original dataframe with the time series data of confirmed coronavirus cases. We then drop some variables that we do not need, such as Province/State, Lat, and Long.\n\n# Here is the original data again\ndfConf = dfConf_orig.copy()\ndfDead = dfDead_orig.copy()\ndfRec  = dfRec_orig.copy()\n\nNow pick the confirmed cases and drop some columns\n\ndfConf_t = dfConf\ndfConf_t = dfConf_t.drop(columns = ['Province/State', 'Lat', 'Long'])\n\nLet us have a look at the first three rows to see how our raw data look like.\n\nprint(dfConf_t[0:3])\n\n  Country/Region  1/22/20  1/23/20  1/24/20  1/25/20  1/26/20  1/27/20  \\\n0    Afghanistan        0        0        0        0        0        0   \n1        Albania        0        0        0        0        0        0   \n2        Algeria        0        0        0        0        0        0   \n\n   1/28/20  1/29/20  1/30/20  ...  2/28/23  3/1/23  3/2/23  3/3/23  3/4/23  \\\n0        0        0        0  ...   209322  209340  209358  209362  209369   \n1        0        0        0  ...   334391  334408  334408  334427  334427   \n2        0        0        0  ...   271441  271448  271463  271469  271469   \n\n   3/5/23  3/6/23  3/7/23  3/8/23  3/9/23  \n0  209390  209406  209436  209451  209451  \n1  334427  334427  334427  334443  334457  \n2  271477  271477  271490  271494  271496  \n\n[3 rows x 1144 columns]\n\n\nWe next add up all the cases for each day by Country/Region using the groupby() function that comes with Pandas.\n\ndfConf_t = dfConf_t.groupby('Country/Region').sum()\n\nAnd again, let us peek at the data real quick.\n\nprint(dfConf_t[0:3])\n\n                1/22/20  1/23/20  1/24/20  1/25/20  1/26/20  1/27/20  1/28/20  \\\nCountry/Region                                                                  \nAfghanistan           0        0        0        0        0        0        0   \nAlbania               0        0        0        0        0        0        0   \nAlgeria               0        0        0        0        0        0        0   \n\n                1/29/20  1/30/20  1/31/20  ...  2/28/23  3/1/23  3/2/23  \\\nCountry/Region                             ...                            \nAfghanistan           0        0        0  ...   209322  209340  209358   \nAlbania               0        0        0  ...   334391  334408  334408   \nAlgeria               0        0        0  ...   271441  271448  271463   \n\n                3/3/23  3/4/23  3/5/23  3/6/23  3/7/23  3/8/23  3/9/23  \nCountry/Region                                                          \nAfghanistan     209362  209369  209390  209406  209436  209451  209451  \nAlbania         334427  334427  334427  334427  334427  334443  334457  \nAlgeria         271469  271469  271477  271477  271490  271494  271496  \n\n[3 rows x 1143 columns]\n\n\nWe now transpose the dataframe because we want the time observations as rows and not columns.\n\ndfConf_t = dfConf_t.T\nprint(dfConf_t[0:3])\n\nCountry/Region  Afghanistan  Albania  Algeria  Andorra  Angola  Antarctica  \\\n1/22/20                   0        0        0        0       0           0   \n1/23/20                   0        0        0        0       0           0   \n1/24/20                   0        0        0        0       0           0   \n\nCountry/Region  Antigua and Barbuda  Argentina  Armenia  Australia  ...  \\\n1/22/20                           0          0        0          0  ...   \n1/23/20                           0          0        0          0  ...   \n1/24/20                           0          0        0          0  ...   \n\nCountry/Region  Uruguay  Uzbekistan  Vanuatu  Venezuela  Vietnam  \\\n1/22/20               0           0        0          0        0   \n1/23/20               0           0        0          0        2   \n1/24/20               0           0        0          0        2   \n\nCountry/Region  West Bank and Gaza  Winter Olympics 2022  Yemen  Zambia  \\\n1/22/20                          0                     0      0       0   \n1/23/20                          0                     0      0       0   \n1/24/20                          0                     0      0       0   \n\nCountry/Region  Zimbabwe  \n1/22/20                0  \n1/23/20                0  \n1/24/20                0  \n\n[3 rows x 201 columns]\n\n\nWe are now ready to convert the index of the dataframe into a date index so that we can use the built in time series commands in Pandas.\n\n# Converting the index as date\ndfConf_t.index = pd.to_datetime(dfConf_t.index)\n\n\nprint(dfConf_t[0:3])\n\nCountry/Region  Afghanistan  Albania  Algeria  Andorra  Angola  Antarctica  \\\n2020-01-22                0        0        0        0       0           0   \n2020-01-23                0        0        0        0       0           0   \n2020-01-24                0        0        0        0       0           0   \n\nCountry/Region  Antigua and Barbuda  Argentina  Armenia  Australia  ...  \\\n2020-01-22                        0          0        0          0  ...   \n2020-01-23                        0          0        0          0  ...   \n2020-01-24                        0          0        0          0  ...   \n\nCountry/Region  Uruguay  Uzbekistan  Vanuatu  Venezuela  Vietnam  \\\n2020-01-22            0           0        0          0        0   \n2020-01-23            0           0        0          0        2   \n2020-01-24            0           0        0          0        2   \n\nCountry/Region  West Bank and Gaza  Winter Olympics 2022  Yemen  Zambia  \\\n2020-01-22                       0                     0      0       0   \n2020-01-23                       0                     0      0       0   \n2020-01-24                       0                     0      0       0   \n\nCountry/Region  Zimbabwe  \n2020-01-22             0  \n2020-01-23             0  \n2020-01-24             0  \n\n[3 rows x 201 columns]\n\n\nDrop the last observation because it is an empty row.\n\nif np.sum(dfConf_t.iloc[-1,:].values) &gt; 0:\n    # Do nothing\n    print('Data complete.')\nelse:\n    # If data is not there yet, drop last row\n    dfConf_t = dfConf_t[:-1]\n\nData complete.\n\n\nWe are now ready to plot the time series for different countries. We can choose the number of days we want to plot. Here we choose the most recent 700 observations.\n\nnrObs = -700  # Just plot the recent 700 obs (days)\n\nax = dfConf_t['US'].iloc[nrObs:].plot()\n\nax.set_title('US: Number of Infections')\n# Customize the major grid\nax.grid(which='major', linestyle='-', linewidth='0.5', color='Black')\n# Customize the minor grid\nax.grid(which='minor', linestyle=':', linewidth='0.5', color='black')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nIn order to plot multiple countries into a single graph, I first make a list of countries and then run a loop over this list and invoke the plot command. Otherwise we would have a lot of repeat code which is bad programming style.\n\n# Plot\n\ncountryList = ['US', 'China', 'Korea, South', 'Austria', 'Japan', 'Italy', \\\n                'Germany', 'Spain', 'France', 'United Kingdom']\n\n# Shorter list for alternative graph\n# countryList = ['US', 'Korea, South', 'Austria', 'Japan', \\\n#                'Germany', 'Spain', 'France', 'United Kingdom']\n\nnrObs = -700\n\nax = dfConf_t[countryList[0]].iloc[nrObs:].plot(marker = '*')\nfor x in countryList[1:]:\n    dfConf_t[x].iloc[nrObs:].plot(ax=ax, marker = '.')\n\nax.set_title('Corona Virus Infections: Absolute Levels')\n# Customize the major grid\nax.grid(which='major', linestyle='-', linewidth='0.5', color='Black')\n# Customize the minor grid\nax.grid(which='minor', linestyle=':', linewidth='0.5', color='black')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nWe next investigate the changes in the numbers from one day to the next using the diff() function. It basically subtracts consecutive observations from each other, i.e., it takes the number of infections from day t and subtracts the number of infections from the prior day t-1.\n\nax = dfConf_t[countryList[0]].iloc[nrObs:].diff().plot(marker = '*')\nfor x in countryList[1:]:\n    dfConf_t[x].iloc[nrObs:].diff().plot(ax=ax, marker = '.')\n\nax.set_title('Corona Virus Infections: Daily Increases')\n# Customize the major grid\nax.grid(which='major', linestyle='-', linewidth='0.5', color='Black')\n# Customize the minor grid\nax.grid(which='minor', linestyle=':', linewidth='0.5', color='black')\nplt.legend()\nplt.show()",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Working with Data III: Maps and Geospatial Data</span>"
    ]
  },
  {
    "objectID": "Data-3.html#plotting-time-series-of-corona-virus-deaths",
    "href": "Data-3.html#plotting-time-series-of-corona-virus-deaths",
    "title": "13  Working with Data III: Maps and Geospatial Data",
    "section": "13.5 Plotting Time Series of Corona Virus Deaths",
    "text": "13.5 Plotting Time Series of Corona Virus Deaths\nWe again need to transform the data into a time series dataframe first.\n\n# Death Rates\ndfDead_t = dfDead\ndfDead_t = dfDead_t.drop(columns = ['Province/State', 'Lat', 'Long'])\ndfDead_t = dfDead_t.groupby('Country/Region').sum()\ndfDead_t = dfDead_t.T\n# Converting the index as date\ndfDead_t.index = pd.to_datetime(dfDead_t.index)\nif np.sum(dfDead_t.iloc[-1,:].values) &gt; 0:\n    # Do nothing\n    print('Data complete.')\nelse:\n    # If data is not there yet, drop last row\n    dfDead_t = dfDead_t[:-1]\n\nData complete.\n\n\nAnd we can now plot the information. We again start with the absolute levels.\n\nax = dfDead_t[countryList[0]].iloc[nrObs:].plot(marker = '*')\nfor x in countryList[1:]:\n    dfDead_t[x].iloc[nrObs:].plot(ax=ax, marker = '.')\n\nax.set_title('Corona Virus Deaths: Absolute Levels')\n# Customize the major grid\nax.grid(which='major', linestyle='-', linewidth='0.5', color='Black')\n# Customize the minor grid\nax.grid(which='minor', linestyle=':', linewidth='0.5', color='black')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nThe daily changes in number of deaths can be plotted as follows\n\nax = dfDead_t[countryList[0]].iloc[nrObs:].diff().plot(marker = '*')\nfor x in countryList[1:]:\n    dfDead_t[x].iloc[nrObs:].diff().plot(ax=ax, marker = '.')\n\nax.set_title('Corona Virus Deaths: Daily Increases')\n# Customize the major grid\nax.grid(which='major', linestyle='-', linewidth='0.5', color='Black')\n# Customize the minor grid\nax.grid(which='minor', linestyle=':', linewidth='0.5', color='black')\nplt.legend()\nplt.show()",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Working with Data III: Maps and Geospatial Data</span>"
    ]
  },
  {
    "objectID": "Data-3.html#key-concepts-and-summary",
    "href": "Data-3.html#key-concepts-and-summary",
    "title": "13  Working with Data III: Maps and Geospatial Data",
    "section": "13.6 Key Concepts and Summary",
    "text": "13.6 Key Concepts and Summary\n\n\n\n\n\n\nNote\n\n\n\n\nImporting data from Github\nPlotting scatterplots\nPlotting time series data\nDifferencing time series data",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Working with Data III: Maps and Geospatial Data</span>"
    ]
  },
  {
    "objectID": "Data-3.html#self-check-questions",
    "href": "Data-3.html#self-check-questions",
    "title": "13  Working with Data III: Maps and Geospatial Data",
    "section": "13.7 Self-Check Questions",
    "text": "13.7 Self-Check Questions\n\n\n\n\n\n\ntodo\n\n\n\n\nGenerate graphs that track the corona virus infection rates for all 50 US states\nGenerate graphs that show the daily change of number of infections for all 50 US states.\n\n\n\n\n\n\nFigure 13.1: Confirmed Infections and Deaths by 100000\nFigure 13.2: Confirmed Infections and Deaths by 100000 with World Map Superimposed",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Working with Data III: Maps and Geospatial Data</span>"
    ]
  },
  {
    "objectID": "WebData.html",
    "href": "WebData.html",
    "title": "14  Working with Data from the Web I",
    "section": "",
    "text": "14.1 Beautiful Soup Library\nThe Python library BeautifulSoup helps us parsing out the information from the html-data that we get after downloading the web page. The additional library request allows us to download source codes from websites. We therefore first need to import these two libraries.\nimport os\nimport requests\nfrom urllib.request import urlopen\nfrom bs4 import BeautifulSoup\nimport re\nimport pandas as pd\nThe first package allows us to open web pages and the second, BeautifulSoup parses the html code and stores it in an easily accessible database format, or object. This object has methods that are tailor made to extract information from the html code of the website that we scrape from. The other two packages are Pandas and Regular Expressions. The latter is useful for pattern matching as you will see below. See also the chapter on Regular Expressions in these lecture notes.",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Working with Data from the Web I</span>"
    ]
  },
  {
    "objectID": "WebData.html#scraping-professors-website",
    "href": "WebData.html#scraping-professors-website",
    "title": "14  Working with Data from the Web I",
    "section": "14.2 Scraping Professor’s Website",
    "text": "14.2 Scraping Professor’s Website\n\n\n\n\n\n\nWarning\n\n\n\nIf you scrape from any site, make sure you read the user guidelines, privacy documentation, and API rules, so that you do not run afoul of the law!\n\n\n\n14.2.1 Introduction\nIn this project we will analyze the research of Professor Jung.\n\nWe start with downloading all workingpapers from the Professors research website. We will extract the title for each paper, the number of references, the citations, and the download link to the pdf version of the working papers. We then store everything in a Pandas dataframe for further analysis.\nIn a second step we will download all the working papers and save them to a local file directory called ‘paperdownload_folder’.\nThird, we load each pdf article and extract the abstract information from the article and store that into a python list.\nFinally, we will make a word cloud that shows the prevalence of certain nouns used in the article which will highlight the research interests of the professor.\n\nWe first define the Website URL and assign it to a variable.\n\n# Define url to website\njurl = 'https://juejung.github.io/research.htm'\n\nWe next open the website site and read the page's html code and assign it to the variable html.\n\nhtml = urlopen(jurl).read()\n\nWe then assign the html code to the BeautifulSoup data format which allows us to sort through the html code more systematically.\n\nsoup = BeautifulSoup(html.decode('utf-8', 'ignore'), \"lxml\")\n\n\n\n14.2.2 Extracting Information from html Code\nNext look at the source code of the webpage (right click on the webpage and select View page source) and convince yourself that the links to the working papers all start with:\nhttps://ideas.repec.org\nIf you inspect this soup object it is a bit easier to see that all working papers are part of a link class that starts with:\n&lt;a &gt;\n\n\n\n\n\n\nNote\n\n\n\nWhere &lt;a&gt; is the anchor element that starts a section that contains a link. A typical html code with a link would look something like this:\n&lt;a href=\"http://example.com/\"&gt;Link to example.com&lt;/a&gt;\nwhere href stands for hyper reference (or link) and the &lt;/a&gt; at the end of the line closes the link section. That is &lt;a ...&gt; is the opening tag and /a&gt; is the closing tag.\n\n\nAlso note that the actual links to the working papers all start with the html tag:\nhttps://ideas.repec.org\nWe next extract all these a sections from the soup object. We limit the extraction of link sections to particular a sections that contain the actual links to working papers as opposed to other links that are also part of the html code of the professor’s research page. Since we observed above, that the links to the working papers all have the ideas keyword we will filter for these particular a sections next.\n\n# Now select all links with the keyword \"ideas\"\nlinkSections = soup.select(\"a[href*=ideas]\")\n\nWe can now define an empty list so we can store all the links to the working papers and then run a loop through the html source code and extract all links that start with href=\"/ideas. We append all these links to the link_list list.\nLet us test this first before we run a loop. Let's have a look at the first element of our extracted list.\n\nprint(linkSections[0])\n\n&lt;a href=\"http://ideas.repec.org/p/tow/wpaper/2017-01.html\"&gt;\n                Health Risk, Insurance and Optimal Progressive Income\n                Taxation&lt;/a&gt;\n\n\nNext let us have a look at the link to the working papers in that section.\n\nprint(linkSections[0]['href'])\n\nhttp://ideas.repec.org/p/tow/wpaper/2017-01.html\n\n\nIf we combine this with https://juejung.github.io/research.htm that we have already stored in variable jurl we have the complete html link to the working papers that we can copy/paste into a browser.\n\nlink_list = []\n\nfor link in linkSections:\n    # Store all links in a list\n    newLink = link['href']\n    link_list.append(newLink)\n\nLet's print the first 5 entries of the list\n\nprint(len(link_list))\nprint(link_list[0:6])\n\n20\n['http://ideas.repec.org/p/tow/wpaper/2017-01.html', 'http://ideas.repec.org/p/tow/wpaper/2020-04.html', 'http://ideas.repec.org/p/tow/wpaper/2020-02.html', 'http://ideas.repec.org/p/tow/wpaper/2016-02.html', 'http://ideas.repec.org/p/tow/wpaper/2020-03.html', 'https://ideas.repec.org/p/tow/wpaper/2016-16.html']\n\n\n\n\n14.2.3 Storing Information in a DataFrame\nWe then create an empty data frame that has the same number of rows as our list. In addition we add empty columns so that we can store the title, view, like and dislike information later on.\n\nindex = range(len(link_list))\ncolumns = ['Links', 'Title', 'Citations', 'References', 'Download-Link']\ndf = pd.DataFrame(index=index, columns=columns)\n\nWe next assign the link_list with all the working paper links to the dataframe.\n\ndf['Links'] = link_list\n\nWe then start the loop that runs through our list of working paper links and opens each one separately in a webpage. We then grab the title, number of references and number of citations, and pdf download link and store this information in the current row of our dataframe.\n\n\n\n\n\n\nWarning\n\n\n\nThe following code might not run all the way through. The reason is that sometimes when you try to open a website with a crawler script, you may run into a server side issue where the website cannot be accessed for a split second in which case the line:\nhtml = urlopen(df['Links'][i]).read()\nin the script below will return an empty object. The script then tries to read from this object which then ends up in errors such as:\nIndexError: list index out of range\nWe learn how to deal with such issues in the next section.\n\n\n\n\n14.2.4 Extract the View Count for the First Working Paper\nLet us now start with the link to the first working paper. We again read in the html code and decode it as a soup object.\n\ni = 0\n# Open first working paper link\nhtml = urlopen(df['Links'][i]).read()\n\n# Assign it to Soup object\nsoup = BeautifulSoup(html.decode('utf-8', 'ignore'), \"lxml\")\n\nWe first extract the title. This is such a common thing that it is pre-programmed as a function in of the Beautiful Soup library.\n\n# Extract info and store in dataframe\ndf['Title'][i] = soup.title.get_text()\n\nWe are next looking for the information about the references counts. This requires a bit of detective work. After staring at the html code for a bit we find that the number of references is in an html block with the keywork id=\"refs-tab\". We use this info and select the block of text where this occurs.\n\nprint(soup.find_all('a', id=\"refs-tab\"))\n\n[&lt;a aria-controls=\"refs\" aria-selected=\"false\" class=\"nav-link\" data-toggle=\"tab\" href=\"#refs\" id=\"refs-tab\" role=\"tab\"&gt;34 References&lt;/a&gt;]\n\n\nThis returns a list, so let us just grab the content (first entry) of this list.\n\nprint(soup.find_all('a', id=\"refs-tab\")[0])\n\n&lt;a aria-controls=\"refs\" aria-selected=\"false\" class=\"nav-link\" data-toggle=\"tab\" href=\"#refs\" id=\"refs-tab\" role=\"tab\"&gt;34 References&lt;/a&gt;\n\n\nNow let us just get the text between the html tags using the get_text() function.\n\nprint(soup.find_all('a', id=\"refs-tab\")[0].get_text())\n\n34 References\n\n\nOk, our number is in there. Let us now split this string into separate strings so that we can grab our number more easily.\n\nprint(soup.find_all('a', id=\"refs-tab\")[0].get_text().split())\n\n['34', 'References']\n\n\nAlmost there, grab the first element of this list.\n\nprint(soup.find_all('a', id=\"refs-tab\")[0].get_text().split()[0])\n\n34\n\n\nThis is still a string, so let us retype it as an integer number so we can assign it into our dataframe and do math with it.\n\nprint(int(soup.find_all('a', id=\"refs-tab\")[0].get_text().split()[0]))\n\n34\n\n\nAnd finally stick it into our dataframe in the References column at row zero, which is the first row.\n\ndf['References'][0] = int(soup.find_all('a', id=\"refs-tab\")[0].get_text().split()[0])\n\nLet us have a quick look at the dataframe to see whether it has been stored in the correct position.\n\nprint(df.head())\n\n                                              Links  \\\n0  http://ideas.repec.org/p/tow/wpaper/2017-01.html   \n1  http://ideas.repec.org/p/tow/wpaper/2020-04.html   \n2  http://ideas.repec.org/p/tow/wpaper/2020-02.html   \n3  http://ideas.repec.org/p/tow/wpaper/2016-02.html   \n4  http://ideas.repec.org/p/tow/wpaper/2020-03.html   \n\n                                               Title Citations References  \\\n0  Health Risk, Insurance and Optimal Progressive...       NaN         34   \n1                                                NaN       NaN        NaN   \n2                                                NaN       NaN        NaN   \n3                                                NaN       NaN        NaN   \n4                                                NaN       NaN        NaN   \n\n  Download-Link  \n0           NaN  \n1           NaN  \n2           NaN  \n3           NaN  \n4           NaN  \n\n\n\n\n14.2.5 Extract the Citations and PDF download links\nNext we do a similar procedure extracting the \"Citations\" information.\n\n# Extracting number of citations\ndf['Citations'][0] = int(soup.find_all('a', id=\"cites-tab\")[0].get_text().split()[0])\n\nValueError: invalid literal for int() with base 10: 'Citations'\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThe previous command could have thrown an error in case no citations were available yet. In this case the dataframe will just assign a nan.\n\n\nLet us have a look at the dataframe again.\n\nprint(df.head())\n\n                                              Links  \\\n0  http://ideas.repec.org/p/tow/wpaper/2017-01.html   \n1  http://ideas.repec.org/p/tow/wpaper/2020-04.html   \n2  http://ideas.repec.org/p/tow/wpaper/2020-02.html   \n3  http://ideas.repec.org/p/tow/wpaper/2016-02.html   \n4  http://ideas.repec.org/p/tow/wpaper/2020-03.html   \n\n                                               Title Citations References  \\\n0  Health Risk, Insurance and Optimal Progressive...       NaN         34   \n1                                                NaN       NaN        NaN   \n2                                                NaN       NaN        NaN   \n3                                                NaN       NaN        NaN   \n4                                                NaN       NaN        NaN   \n\n  Download-Link  \n0           NaN  \n1           NaN  \n2           NaN  \n3           NaN  \n4           NaN  \n\n\nFinally, here is the entire code that extracts all the information for the working paper:\n\n# First working paper i.e., first element of the Links column in dataframe\ni = 0\n\n# Open first working paper link\nhtml = urlopen(df['Links'][i]).read()\n\n# Assign it to Soup object\nsoup = BeautifulSoup(html.decode('utf-8', 'ignore'), features=\"lxml\")\n\n# Extract info and store in dataframe\ndf['Title'][i] = soup.title.get_text()\ndf['References'][i] = int(soup.find_all('a', id=\"refs-tab\")[0].get_text().split()[0])\ndf['Citations'][i] = int(soup.find_all('a', id=\"cites-tab\")[0].get_text().split()[0])\ndf['Download-Link'] = soup.find_all(string=re.compile(r'webapps'))[0]\n\nValueError: invalid literal for int() with base 10: 'Citations'\n\n\n\n\n14.2.6 Extract Remaining Working Paper Info Using Loop\nWe finally scrape all the other working papers in the same way. In order to make this a bit nicer we simply put it into a loop.\n\nfor i in range(len(link_list)):\n    if i&lt;5 or i&gt;len(link_list)-5:\n        print('{} out of {}'.format(i, len(link_list)))\n\n    # Open first working paper link\n    html = urlopen(df['Links'][i]).read()\n\n    # Assign it to Soup object\n    soup = BeautifulSoup(html.decode('utf-8', 'ignore'), \"lxml\")\n\n    # Extract info and store in dataframe\n    df['Title'][i] = soup.title.get_text()\n    df['References'][i] = int(soup.find_all('a', id=\"refs-tab\")[0].get_text().split()[0])\n    df['Citations'][i] = int(soup.find_all('a', id=\"cites-tab\")[0].get_text().split()[0])\n    df['Download-Link'] = soup.find_all(string=re.compile(r'webapps'))[0]\n\n0 out of 20\n\n\nValueError: invalid literal for int() with base 10: 'Citations'\n\n\nThis may have resulted in an error if there was a server issues for one of the many working papers we tried to scrape. Do not worry. We will fix this now.",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Working with Data from the Web I</span>"
    ]
  },
  {
    "objectID": "WebData.html#how-to-deal-with-errors",
    "href": "WebData.html#how-to-deal-with-errors",
    "title": "14  Working with Data from the Web I",
    "section": "14.3 How to Deal with Errors",
    "text": "14.3 How to Deal with Errors\nSometimes a website is down or cannot be read for some reason. In this case the line in the above script that opens or loads the webpage, html = urlopen(df['Links'][i]).read(), may result in an empty object so that html would not be defined. The next line in the script above that uses the html object would then break the code and throw an error.\nIn order to circumvent that we could put the entire code-block into a try-except statement. In this case the Python interpreter will try to load the content of the website and extract all the info from the website. However, if the interpreter is not able to load the website then, instead of breaking the code, it will simply jump into an alternate branch (the Except part) and continue running the commands that are there.\n\nfor i in range(len(link_list)):\n    if i&lt;5 or i&gt;len(link_list)-5:\n        print('{} out of {}'.format(i, len(link_list)))\n\n    # Sometimes a website is down or cannot be read for some reason\n    # The\n    try:\n       # Open first working paper link\n        html = urlopen(df['Links'][i]).read()\n\n        # Assign it to Soup object\n        soup = BeautifulSoup(html.decode('utf-8', 'ignore'), \"lxml\")\n\n        # Extract info and store in dataframe\n        # We extract:\n        # Title of article\n        # Number of references used by workingpaper\n        # Number of citations of workingpaper\n        # Download URL (or link) to pdf so we can download pdf files later\n        df['Title'][i] = soup.title.get_text()\n        df['References'][i] = int(soup.find_all('a', id=\"refs-tab\")[0].get_text().split()[0])\n        df['Citations'][i] = int(soup.find_all('a', id=\"cites-tab\")[0].get_text().split()[0])\n        df['Download-Link'] = soup.find_all(string=re.compile(r'webapps'))[0]\n\n    except Exception as e:\n        print('Something is wrong with link {}'.format(i))\n        print('Probably a server side issue!')\n        # The next line prints the error message\n        print(e)\n\n0 out of 20\nSomething is wrong with link 0\nProbably a server side issue!\ninvalid literal for int() with base 10: 'Citations'\n1 out of 20\n2 out of 20\nSomething is wrong with link 2\nProbably a server side issue!\nlist index out of range\n3 out of 20\n4 out of 20\nSomething is wrong with link 13\nProbably a server side issue!\nlist index out of range\nSomething is wrong with link 15\nProbably a server side issue!\nlist index out of range\n16 out of 20\nSomething is wrong with link 16\nProbably a server side issue!\nlist index out of range\n17 out of 20\n18 out of 20\n19 out of 20\nSomething is wrong with link 19\nProbably a server side issue!\nlist index out of range\n\n\nIf you write your code in this way, your program will never break in case you hit a bad link. It will simply print the exception message and then continue with the next link from the link_list.\n\n# Sort by impact measured by the workingpaper's citations\ndf.head()\n\n\n\n\n\n\n\n\n\nLinks\nTitle\nCitations\nReferences\nDownload-Link\n\n\n\n\n0\nhttp://ideas.repec.org/p/tow/wpaper/2017-01.html\nHealth Risk, Insurance and Optimal Progressive...\nNaN\n34\nhttp://webapps.towson.edu/cbe/economics/workin...\n\n\n1\nhttp://ideas.repec.org/p/tow/wpaper/2020-04.html\nHealthcare Reform and Gender Specific Infant M...\n1\n29\nhttp://webapps.towson.edu/cbe/economics/workin...\n\n\n2\nhttp://ideas.repec.org/p/tow/wpaper/2020-02.html\nHealth Risk and the Welfare Effects of Social ...\nNaN\nNaN\nhttp://webapps.towson.edu/cbe/economics/workin...\n\n\n3\nhttp://ideas.repec.org/p/tow/wpaper/2016-02.html\nSocial Health Insurance: A Quantitative Explor...\n5\n99\nhttp://webapps.towson.edu/cbe/economics/workin...\n\n\n4\nhttp://ideas.repec.org/p/tow/wpaper/2020-03.html\nCoronavirus Infections and Deaths by Poverty S...\n14\n16\nhttp://webapps.towson.edu/cbe/economics/workin...\n\n\n\n\n\n\n\n\nWe finally sort the data according to number of citations, starting with the most cited working paper and print the first couple of entries:\n\n\n\n\n\n\nWarning\n\n\n\nIn Pandas there was a change from df.sort() to df.sort_values(). Make sure you use the latter command.\n\n\n\n# Sort by impact measured by the workingpaper's citations\ndf.sort_values('Citations', ascending = False).head()\n\n\n\n\n\n\n\n\n\nLinks\nTitle\nCitations\nReferences\nDownload-Link\n\n\n\n\n8\nhttps://ideas.repec.org/p/tow/wpaper/2014-01.html\nMarket Inefficiency, Insurance Mandate and Wel...\n50\n59\nhttp://webapps.towson.edu/cbe/economics/workin...\n\n\n6\nhttps://ideas.repec.org/p/tow/wpaper/2013-01.html\nFiscal Austerity Measures: Spending Cuts vs. T...\n17\n26\nhttp://webapps.towson.edu/cbe/economics/workin...\n\n\n4\nhttp://ideas.repec.org/p/tow/wpaper/2020-03.html\nCoronavirus Infections and Deaths by Poverty S...\n14\n16\nhttp://webapps.towson.edu/cbe/economics/workin...\n\n\n17\nhttp://ideas.repec.org/p/tow/wpaper/2010-12.html\nThe Macroeconomics of Health Savings Accounts\n14\n51\nhttp://webapps.towson.edu/cbe/economics/workin...\n\n\n7\nhttps://ideas.repec.org/p/tow/wpaper/2016-04.html\nAging and Health Financing in the U.S. A Gener...\n12\n55\nhttp://webapps.towson.edu/cbe/economics/workin...",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Working with Data from the Web I</span>"
    ]
  },
  {
    "objectID": "WebData.html#downloading-the-pdf-files-and-storing-them-on-disk",
    "href": "WebData.html#downloading-the-pdf-files-and-storing-them-on-disk",
    "title": "14  Working with Data from the Web I",
    "section": "14.4 Downloading the PDF files and Storing them on disk",
    "text": "14.4 Downloading the PDF files and Storing them on disk\nIn order to help with the PDF download we use the requests library. We also write a little helper function for the download that we define first.\n\n# Helper function that will download a pdf file from a specific URL\n# and save it under the name: file_name\n\ndef download_pdf(url, file_name, headers):\n\n    # Send GET request\n    response = requests.get(url, headers=headers)\n\n    # Save the PDF\n    if response.status_code == 200:\n        with open(file_name, \"wb\") as f:\n            f.write(response.content)\n    else:\n        print(response.status_code)\n\nNow we use the main script to generate the sub-directory for storing the articles.\n\n# [2] Save pdfs in a subfolder called 'paperdownload_folder'\n# ---------------------------------------------------------------\ncurrent_directory = os.getcwd()\nfinal_directory = os.path.join(current_directory, r'paperdownload_folder')\nif not os.path.exists(final_directory):\n    os.makedirs(final_directory)\n\n# Define HTTP Headers\nheaders = {\n    \"User-Agent\": \"Firefox/124.0\",\n}\n\n# Run loop over all paper urls stored in our dataframe above\ntry:\n    for i in range(len(df)):\n        print(\"Downloading file: \", i)\n\n        # Define URL of a PDF\n        url = df['Download-Link'][i]\n\n        # Define PDF file name\n        file_name = final_directory + \"/file\" + str(i) + \".pdf\"\n\n        # Download PDF\n        download_pdf(url, file_name, headers)\n\n    print('Download Complete')\nexcept Exception as e:\n    print('Something is wrong with pdf link {}'.format(i))\n    print('Probably a server side issue!')\n    print(e)\n\nDownloading file:  0\nDownloading file:  1\nDownloading file:  2\nDownloading file:  3\nDownloading file:  4\nDownloading file:  5\nDownloading file:  6\nDownloading file:  7\nDownloading file:  8\nDownloading file:  9\nDownloading file:  10\nDownloading file:  11\nDownloading file:  12\nDownloading file:  13\nDownloading file:  14\nDownloading file:  15\nDownloading file:  16\nDownloading file:  17\nDownloading file:  18\nDownloading file:  19\nDownload Complete",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Working with Data from the Web I</span>"
    ]
  },
  {
    "objectID": "WebData.html#open-pdf-files-and-scrape-abstract-for-word-cloud",
    "href": "WebData.html#open-pdf-files-and-scrape-abstract-for-word-cloud",
    "title": "14  Working with Data from the Web I",
    "section": "14.5 Open PDF Files and Scrape Abstract for Word Cloud",
    "text": "14.5 Open PDF Files and Scrape Abstract for Word Cloud\nWe next load all the previously downloaded pdf articles and scrape them for the abstract info. We put all the abstract info into a list and then produce a word cloud to highlight the research interests of the professor.\nWe use the third party libraries pdfminer and WordCloud libraries that we need to install prior to using it.\n\n# conda install -c conda-forge pdfminer.six\nfrom pdfminer.high_level import extract_pages, extract_text\n\n# [1] Open pdfs and scrape Abstract\n# -----------------------------------------\nnrArticles = len(os.listdir(\"paperdownload_folder\"))\nfirst = 'Abstract'\nsecond = 'JEL'\nabstractList = []\n\nfor i in range(nrArticles):\n    #print(i)\n\n    # Extract text from page 2 (the title page of the paper)\n    text = extract_text(\"paperdownload_folder/file\"+str(i)+\".pdf\", page_numbers=[1])\n\n    # Cut text between 'Abstract' and 'JEL'\n    temp_text = text[text.find('Abstract')+8: text.find('JEL')]\n\n    # Clean text string\n    clean_text = temp_text.replace('\\n', ' ').replace('ﬀ', 'ff')\n\n    # Append to list\n    abstractList.append(clean_text)\n\nWe finally produce the word cloud.\n\nimport matplotlib.pyplot as plt\n\n# conda install WordCloud\nfrom wordcloud import WordCloud\n\n# [2] Make wordcloud out of Abstract text\n# -----------------------------------------\n# Convert list to string and generate\nunique_string=(\" \").join(abstractList)\n\nAnd for plotting we use the following code.\n\nwordcloud = WordCloud(width = 1000, height = 500).generate(unique_string)\nplt.figure(figsize=(15,8))\nplt.axis(\"off\")\nplt.imshow(wordcloud)\n\n\n\n\n\n\n\nFigure 14.1: Word Cloud of Abstracts",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Working with Data from the Web I</span>"
    ]
  },
  {
    "objectID": "WebData.html#more-tutorials",
    "href": "WebData.html#more-tutorials",
    "title": "14  Working with Data from the Web I",
    "section": "14.6 More Tutorials",
    "text": "14.6 More Tutorials\nHere are additional web tutorials about Python web scraping that you can check out:\n\n\nScraping URLs from the Pycon 2014 Conference by Miguel Grinberg\nA youtube tutorial for web scraping with Python\nDan Nguyens blog entry for scraping public data\n\n\n\n\n\n\n\n\nKey Concepts and Summary\n\n\n\n\nScrape webpage with beautiful soup\nData organization\n\n\n\n\n\n\n\n\n\nSelf-check questions\n\n\n\n\n\n\nScrape information from your favorite website\n\n\n\n\n\n\n\nFigure 14.1: Word Cloud of Abstracts",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Working with Data from the Web I</span>"
    ]
  },
  {
    "objectID": "WebData-2.html",
    "href": "WebData-2.html",
    "title": "\n15  Working with Data from the Web II\n",
    "section": "",
    "text": "15.1 Intro to APIs\nA web application API allows the user to make requests via HTTP for some type of data and the API will return this data in pre-packaged XML or JSON formats.\nAn API request is very much like accessing a website with a browser. Both calls use the HTTP protocol to download a file. The only difference is that an API follows a much more regulated syntax and downloads data in XML (eXtensible Markup Language) or JSON (JavaScript Object Notation) formats as opposed to HTML (HyperText Markup Language).\nAn API uses four separate methods to access a web server via HTTP:\nThe GET method is used to download data. The POST method is used to fill out a form or submit information to the server. PUT is similar to post and used for updating already existing objects. Most APIs use POST instead of PUT, so PUT is very rare. Finally, the DELETE method is used to delete information/data from a web server.\nMost websites that provide APIs require prior authentication to operate with the web server via the API. In other words, you will first need to 'apply for an API' by registering with the website. After registering for an API you may have to wait for a few days. Once your application is granted you are provided with an api_key value that allows the server to identify you when you are making your calls.\nSome APIs require more detailed forms of identification using the OAuth protocol parameters for each request:\nThis seems a bit complicated, but most larger website provide sample codes for using their APIs in various popular programming languages. Sometimes, they even provide small Python libraries to facilitate the interaction with their website.",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Working with Data from the Web II</span>"
    ]
  },
  {
    "objectID": "WebData-2.html#intro-to-apis",
    "href": "WebData-2.html#intro-to-apis",
    "title": "\n15  Working with Data from the Web II\n",
    "section": "",
    "text": "GET\nPOST\nPUT\nDELETE\n\n\n\n\n\n\n\n\n\n\nOAuth Parameter\nValue\n\n\n\noauth_consumer_key\nYour OAuth consumer key (from Manage API Access)\n\n\noauth_token\nThe access token obtained (from Manage API Access)\n\n\noauth_signature_method\nhmac-sha1\n\n\noauth_signature\nThe generated request signature, signed with the oauth_token_secret obtained\n\n\noauth_timestamp\nTimestamp for the request in secs since the Unix epoch\n\n\noauth_nonce\nA unique string randomly generated per request",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Working with Data from the Web II</span>"
    ]
  },
  {
    "objectID": "WebData-2.html#yelp-api",
    "href": "WebData-2.html#yelp-api",
    "title": "\n15  Working with Data from the Web II\n",
    "section": "\n15.2 Yelp-API",
    "text": "15.2 Yelp-API\nFor interacting with the Yelp API for instance you can find information here. There is also a Python library available that you can download from here.\nIf you want to install this library you simply open a command line window (in Windows click on the windows start menu and type cmd followed by enter) and type:\npip install yelpapi\n\nBefore you can use this library in a Python script you need to have a yelp account, so make one. Then log in. You then need to apply for a 'new app'. This usually takes a few minutes. You will then be issued a unique client_id as well as a unique client_secret key. These two keys identify you as the user. Do not make these keys public.\nNow, in order to use this library you can then simply write a small script as follows:\n1from yelpapi import YelpAPI\nfrom pprint import pprint\n\nclient_id = 'YOUR_CLIENT_ID_FROM_YOUR_YELP_APPLICATION'\nclient_secret = 'YOUR_CLIENT_SECRET_FROM_YOUR_YELP_APPLICATION'\n\nyelp_api = YelpAPI(client_id, client_secret)\n\n1\n\nImport the Yelp API\n\n\nYou can then search the yelp_api client object with:\nresponse = yelp_api.search_query(term='ice cream', \\\n    location='austin, tx', sort_by='rating', limit=5)\npprint(response)\nWhich searches for the top 5 rated ice cream places in Austin TX and orders the results by ratings. The pprint() function prints the dictionary data with nice indents so that you can see the data structure better.\n\n\n\n\n\n\nNote\n\n\n\nThe yelp-api returns data in the form of a Python dictionary object. Go to the earlier chapter on data types on refresh your memory. It's often convenient to transform the dictionary data into a Pandas DataFrame. Ultimately, it's easier to analyse data when it is in a DataFrame.\n\n\nHere is a small example script that shows an entire solution for this:\nfrom yelpapi import YelpAPI\nfrom pprint import pprint\nimport pandas as pd\n\nclient_id = 'YOUR_CLIENT_ID_FROM_YOUR_YELP_APPLICATION'\nclient_secret = 'YOUR_CLIENT_SECRET_FROM_YOUR_YELP_APPLICATION'\n\ndef parse_dict(init, lkey=''):\n    \"\"\"\n    This function 'flattens' a nested dictionary so that all subkeys become\n    primary keys and can then be read into a DataFrame as separate columns\n    \"\"\"\n    ret = {}\n    for rkey,val in init.items():\n        key = lkey+rkey\n        if isinstance(val, dict):\n            ret.update(parse_dict(val, key+'_'))\n        else:\n            ret[key] = val\n    return ret\n\n# Access Yelp with the user idenficiation codes\nyelp_api = YelpAPI(client_id, client_secret)\n\n# Query Yelp via its API and search for 5 top ice cream places in Texas\n# This will return a 'dictionary' data object.\nresponse = yelp_api.search_query(term='ice cream', \\\n    location='austin, tx', sort_by='rating', limit=5)\n\n# Print the results nicely with tabls for sub-keys in the resulting\n# dictionary\npprint(response)\n\n# Prepare a Pandas DataFrame so we can transform the dictionary-data into\n# a Pandas DataFrame object\n\n# Nr. of obs from our search\nnrObs = len(response['businesses'])\nindex = range(nrObs)\n\n# Take first observation as an example for key-extraction\n#print(parse_dict(response['businesses'][0],''))\ntempDict = parse_dict(response['businesses'][0],'')\n\n# Make a list that contains all the keys in the dictionary\ncolumns = []\nfor keys in tempDict:\n    columns.append(keys)\n\n# Generate the empty dataframe with all the key-columns\ndf = pd.DataFrame(index=index, columns=columns)\n\n# Run a loop through the dictionary data and extract it into the DataFrame\nfor i in range(nrObs):\n    tempDict = parse_dict(response['businesses'][i],'')\n    for key in tempDict:\n        # From dictionary into dataframe\n        df.loc[df.index[i], key] = tempDict[key]\n\n# Sort by rating\ndf = df.sort_values('rating', ascending=False)",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Working with Data from the Web II</span>"
    ]
  },
  {
    "objectID": "WebData-2.html#economic-data-from-the-federal-reserve",
    "href": "WebData-2.html#economic-data-from-the-federal-reserve",
    "title": "\n15  Working with Data from the Web II\n",
    "section": "\n15.3 Economic Data from the Federal Reserve",
    "text": "15.3 Economic Data from the Federal Reserve\nThe Federal Reserve Economic Data (FRED) can be accessed with the library pandas_datareader.data.\n\n\n\n\n\n\nWarning\n\n\n\nWarning If you google how to access FRED you may come across a library (or service) called Quandl. Do not use it, it does not work well in my experience.\n\n\nHere is the link with instructions about how you can install the library pandas-datareader\nSimply open a terminal window and type:\nconda install -c anaconda pandas-datareader\nYou will be prompted whether you want to install this library and possible a couple others. Simply type y to accept and the pandas-datareader library will install. You need internet access for this. Restart the iPython console within Spyder by simply closing it. It will then open a new interactive console (command line window) within Spyder. Now you are good to go.\nYou can now easily download data from the FRED database as follows:\n\n\nPython Code\nR Code\n\n\n\n\nimport time\nimport calendar\nimport datetime\nimport os\nimport socket\n\nimport pandas_datareader.data as web\nimport datetime\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.set_style(\"whitegrid\", {'grid.linestyle': ':'})\n\nstart = datetime.datetime(1947, 1, 1)\nend = datetime.datetime(2024, 3, 1)\n\n# Quarterly data\n# -----------------------------------------------------------------------------\nprint('Downloading quarterly data ... ')\n\ndata_list = ['USRECQ', 'GDP', 'GNP', 'GDPC1']\nname_list =  ['Recession', 'GDP', 'GNP', 'rGDP']\n\ndf_q = web.DataReader(data_list, 'fred', start, end)\ndf_q.columns = name_list\n\n# Plot data\nprint(df_q)\n\n# Plot single column\nprint(df_q['GDP'])\n\n# You can also save your graphs using\n#plt.savefig(gtexpath+'GDP_Fig1.png', format='png')\n#plt.show()\n\nDownloading quarterly data ... \n            Recession        GDP        GNP       rGDP\nDATE                                                  \n1947-01-01          0    243.164    244.142   2182.681\n1947-04-01          0    245.968    247.063   2176.892\n1947-07-01          0    249.585    250.716   2172.432\n1947-10-01          0    259.745    260.981   2206.452\n1948-01-01          0    265.742    267.133   2239.682\n...               ...        ...        ...        ...\n2022-10-01          0  26408.405  26593.998  21989.981\n2023-01-01          0  26813.601  26972.528  22112.329\n2023-04-01          0  27063.012  27236.100  22225.350\n2023-07-01          0  27610.128  27774.189  22490.692\n2023-10-01          0  27944.627        NaN  22668.986\n\n[308 rows x 4 columns]\nDATE\n1947-01-01      243.164\n1947-04-01      245.968\n1947-07-01      249.585\n1947-10-01      259.745\n1948-01-01      265.742\n                ...    \n2022-10-01    26408.405\n2023-01-01    26813.601\n2023-04-01    27063.012\n2023-07-01    27610.128\n2023-10-01    27944.627\nFreq: QS-OCT, Name: GDP, Length: 308, dtype: float64\n\n\n\n\nThis code downloads the same data but organizes it differently.\n\nlibrary(tidyquant)\n\nError in library(tidyquant): there is no package called 'tidyquant'\n\nstart &lt;- as.Date(\"1947-01-01\")\nend &lt;- as.Date(\"2024-03-01\")\n\n# Quarterly data\n# -----------------------------------------------------------------------------\ncat('Downloading quarterly data ... \\n')\n\ndata_list &lt;- c('USRECQ', 'GDP', 'GNP', 'GDPC1')\n\ndf_q &lt;- tq_get(data_list, from = start, to = end, get = \"economic.data\")\n\nError in tq_get(data_list, from = start, to = end, get = \"economic.data\"): could not find function \"tq_get\"\n\n#names(df_q) &lt;- name_list\n\n# Plot data\nprint(df_q)\n\nError in eval(expr, envir, enclos): object 'df_q' not found\n\n\nDownloading quarterly data ... \n\n\n\n\n\nThis will download GDP and other variables and plot them. When you download the data you can specify the time frame. This will of course depend on the specific time series you are interested in. Read the documentation about the data on the FRED to see what is available.\nWe can next plot some of the data.\n\n\nPython Code\nR Code\n\n\n\n\ndf_q[['GDP', 'rGDP']].plot(title='Nominal and Real US-GDP')\nplt.show()\n\n\n\nNominal and Real GDP\n\n\n\n\n\nSince the code is organized differently, you would first have to reorganize it so that each variable has its own column before you plot it.\n\n# Try it.\n\n\n\n\nSimilarly you can use daily or monthly data using:\nimport time\nimport calendar\nimport datetime\n\nimport pandas_datareader.data as web\nimport datetime\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.set_style(\"whitegrid\", {'grid.linestyle': ':'})\n\nstart = datetime.datetime(1947, 1, 1)\nend = datetime.datetime(2024, 3, 1)\n\n# Daily data\n# -----------------------------------------------------------------------------\nprint('Downloading daily data ... ')\ndata_list = ['USRECD', 'DFF', 'DPCREDIT']\nname_list = ['Recession', 'FedFunds', 'FedDiscountRate']\n\ndf_d = web.DataReader(data_list, 'fred', start, end)\ndf_d.columns = name_list\n\n# Monthly data\n# -----------------------------------------------------------------------------\nprint('Downloading monthly data ... ')\ndata_list = ['USREC', 'UNRATE', 'FEDFUNDS', 'CPIAUCSL', 'CPILFESL', 'CIVPART', \\\n 'LNS14000003', 'LNS14000006', 'LNS14000009', 'LNU04032183',\\\n 'LNS14000001', 'LNS14000002', \\\n 'LNS14000028', 'LNS14000029', \\\n 'LNS14000031', 'LNS14000032', 'LNU04000034', 'LNU04000035', \\\n 'LNS14000036', 'LNS14000089', 'LNS14000091', \\\n 'LNS14000093', 'LNS14024230', \\\n 'LNS14027659', 'LNS14027660', \\\n 'LNS14027662', 'CGMD25O', 'CGDD25O', \\\n 'M2SL']\n\nname_list = ['Recession', 'Unemployment', 'Interest-Rate', 'CPI_Urban', \\\n  'CPI_Core', 'LaborForcePart', \\\n  'UE_White', 'UE_Black', 'UE_Hispanic','UE_Asian', \\\n  'UE_Men', 'UE_Women', \\\n  'UE_White_Men', 'UE_White_Women', 'UE_Black_Men', \\\n  'UE_Black_Women', 'UE_Hispanic_Men', 'UE_Hispanic_Women',\n  '20-24', '25-34', '35-44', '45-54', '55 and up', \\\n  'UE (&gt;25, less than HS)', 'UE (&gt;25, HS)', 'UE (&gt;25, College)', \\\n  'UE (&gt;25, Master)', 'UE (&gt;25, Doctoral)', \\\n  'M2']\n\ndf_m = web.DataReader(data_list, 'fred', start, end)",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Working with Data from the Web II</span>"
    ]
  },
  {
    "objectID": "WebData-2.html#more-tutorials",
    "href": "WebData-2.html#more-tutorials",
    "title": "\n15  Working with Data from the Web II\n",
    "section": "\n15.4 More Tutorials",
    "text": "15.4 More Tutorials\nHere are additional web tutorials about how to use Python together with the API of popular websites:\n\n\nESPN APIs\nTrip Advisor API\nList of media APIs\nList of Python APIs for beginners\n\n\n\n\n\n\n\n\nKey Concepts and Summary\n\n\n\n\nUsing API to download FRED data\nUser token management\n\n\n\n\n\n\n\n\n\nSelf-check questions\n\n\n\n\n\n\nDownload GDP data\nPlot GDP data for the 20 most recent years\n\n\n\n\n\n\n\nNominal and Real GDP",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Working with Data from the Web II</span>"
    ]
  },
  {
    "objectID": "RegularExpressions.html",
    "href": "RegularExpressions.html",
    "title": "\n16  Regular Expressions\n",
    "section": "",
    "text": "16.1 First Steps\nWe first import the powerful Python regular expressions library\nimport re\nWhen working with Regex remember that we usually use three commands from the Regex library:\nThe first command defines the regex-pattern that we want to use. The second applies the regex-pattern and searches a string for the pattern. The last command presents all the found information in a list for further processing.\nIn python this is implemented as follows:",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Regular Expressions</span>"
    ]
  },
  {
    "objectID": "RegularExpressions.html#first-steps",
    "href": "RegularExpressions.html#first-steps",
    "title": "\n16  Regular Expressions\n",
    "section": "",
    "text": "compile\nsearch\ngroup\n\n\n\n\nimport re\nmyRegex = re.compile('regex pattern')\nmySearchObject = myRegex.search('Textstring that contains the pattern ...')\nmyList = mysearchObject.group()\nprint(myList)",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Regular Expressions</span>"
    ]
  },
  {
    "objectID": "RegularExpressions.html#example-1-matching-phone-numbers",
    "href": "RegularExpressions.html#example-1-matching-phone-numbers",
    "title": "\n16  Regular Expressions\n",
    "section": "\n16.2 Example 1: Matching Phone Numbers",
    "text": "16.2 Example 1: Matching Phone Numbers\nLet's try a first example and extract all the phone numbers from a text-string. The text string is as follows:\nWe need to call John (412-233-9876), James (312-323-7658) as well as Jimmy (450-123-1234) to make sure it gets all done.\nYou could try to run a loop over this string and use some of the string manipulation commands from the earlier chapters to try to extract the three phone numbers from this text. However, that would be somewhat cumbersome. Since the phone numbers follow a very specific pattern---i.e., 3 numbers followed by a dash followed by 3 numbers followed by a dash followed by 4 numbers---regular expressions are a perfect vehicle for content extraction.\nWe first need to define the pattern of what we are looking for in regular expression syntax. You can think of this as a separate sub-language within Python. Regular expressions can be used across different programming languages. So what you learn here about regular expressions in the Python context will be applicable in a very similar fashion in all other programming languages that support regular expressions like Java, C or Ruby etc.\n\n\n\n\n\n\nNote\n\n\n\nRegular expressions are not a fully specified programming languague as they miss some of the branching features of real programming languages like Python, C, or Java.\n\n\nOur task is to match a phone number like 412-233-9876. The pattern of this is ddd-ddd-dddd which means a digit, followed by another digit, followed by a third digit followed by a dash followed by a digit etc. In Regex we have so called character classes for this where:\n\n\n\n\\d Digit character (i.e., a number)\n\n\\w Word characters (i.e., letters and numbers)\n\n\\s Space characters (i.e., space, tab, \\n)\n\n\nas well as their logical negatives:\n\n\n\n\\D Non-Digit\n\n\\W Non-Word\n\n\\S Non-Space\n\n\nYou can also create your own character classes by putting them inside brackets:\n\n\n[aeiouAEIOU] matches vowels a or e or i etc.\n\nBy putting the caret ^ character in front of your class definition you can negate the meaning so that\n\n\n[^aeiouAEIOU] matches all non-vowels b or c or d etc. So this would include all the consonants, numbers, and other symbols.\n\nYou will often see the group [0-9a-zA-Z] which is the same as \\w above, it matches either a digit or a lowercase letter or an upper case letter. The hyphen character - acts as a range indicator, so 0-9 means any of the digits from 0, 1, 2, ... , 9. Similarly a-z means any of the lowercase characters a, b, ... , z.\nPunctuation symbols such as ., ,, *, (, ), ^, $, |, ?, \\, {, }, [, ], + have meaning in regular expression \"language\". If the pattern that you are looking for contains some of these characters, you need to \"escape\" them first in order to use them. If you want to match parenthesis ( and ) for instance you can define your regex pattern as\n\n\n[\\(\\)] which matches open an parenthesis ( or a closed parenthesis )\n\n\nThe pattern definition for matching the phone number in the example above is therefore:\nr'\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d'\nThe r'some string' is the raw string notation in Python which indicates that all the characters within the string definition are taken \"literally.\" In Python some characters have special meaning, especially the \\ backslash character. If we didn't indicate the string as a raw-string using the r prefix we'd have to \"escape\" all the backslashes that we use inside the string to tell python that it needs to use them literally in the pattern definition. This would result in a very ugly pattern definition (without the r prefix) of:\n'\\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d\\\\d'\nIf certain character classes get repeated, we can use curly brackets to indicate how often a character gets repeated. For our phone number pattern this would look like:\nr'\\d{3}-\\d{3}-\\d{4}'\nwhere the curly brackets indicate how many times the \\d character is repeated in the pattern. Notice how we do not put the backslash escape character \\ in front of the curly brackets. Curly brackets have meaning in regular expression language. Once you put the escape character in front of it, the regular expression interpreter thinks you are looking for a curly bracket in the text that you are analysing.\nNow let's combine everything. The following code block will extract the first instance of a phone number pattern match.\n\n\nPython Code\nR Code\n\n\n\n\nimport re\n\n# Assign your text info to a string variable\nmyTextString = \"\"\"We need to call\n    John (412-233-9876), James (312-323-7658)\n    as well as Jimmy (450-123-1234) to make sure it gets all done.\"\"\"\n\nmyRegex = re.compile(r'\\d{3}-\\d{3}-\\d{4}')\nmySearchObject = myRegex.search(myTextString)\nmyList = mySearchObject.group()\nprint(myList)\n\n412-233-9876\n\n\n\n\n\n# Load the stringr library\nlibrary(stringr)\n\n# Assign your text info to a string variable\nmyTextString &lt;- \"We need to call John (412-233-9876), James (312-323-7658) as well as Jimmy (450-123-1234) to make sure it gets all done.\"\n\n# Define the regular expression pattern\nmyRegexPattern &lt;- \"\\\\d{3}-\\\\d{3}-\\\\d{4}\"\n\n# Use str_extract to find and extract the first match\nmyList &lt;- str_extract(myTextString, myRegexPattern)\n\n# Print the result\ncat(myList, \"\\n\")\n\n412-233-9876 \n\n\n\n\n\nIf you want to return all the phone numbers you can use the findall method.\n\n\nPython Code\nR Code\n\n\n\n\nimport re\n\n# Assign your text info to a string variable\nmyTextString = \"\"\"We need to call\n    John (412-233-9876), James (312-323-7658)\n    as well as Jimmy (450-123-1234) to make sure it gets all done.\"\"\"\n\n\nmyRegex = re.compile(r'\\d{3}-\\d{3}-\\d{4}')\nmyList = myRegex.findall(myTextString)\nprint(myList)\n\n['412-233-9876', '312-323-7658', '450-123-1234']\n\n\n\n\n\n# Load the stringr library\nlibrary(stringr)\n\n# Assign your text info to a string variable\nmyTextString &lt;- \"We need to call John (412-233-9876), James (312-323-7658) as well as Jimmy (450-123-1234) to make sure it gets all done.\"\n\n# Define the regular expression pattern\nmyRegexPattern &lt;- \"\\\\d{3}-\\\\d{3}-\\\\d{4}\"\n\n# Use str_extract_all to find and extract all matches\nmyList &lt;- str_extract_all(myTextString, myRegexPattern)[[1]]\n\n# Print the result\ncat(myList, \"\\n\")\n\n412-233-9876 312-323-7658 450-123-1234 \n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThere are additional ways to specify how often to repeat a character. Here's a brief summary for the quantity of character classes:\n\n\nregex expression\nExplanation\n\n\n\n\\d\none digit\n\n\n\\d?\nzero or one digit\n\n\n\\d*\nzero or more digits\n\n\n\\d+\none or more digits\n\n\n\\d{3}\nexactly three digits\n\n\n\\d{3,5}\nbetween 3 and 5 digits\n\n\n\\d{3,}\n3 or more digits\n\n\n\n\n\nSimilarly you can do this for your own defined classes such as the vowel class above [aeiou], which results in:\n\n\n\nregex expression\nExplanation\n\n\n\n[aeiou]\none vowel\n\n\n[aeiou]?\nzero or one vowel\n\n\n[aeiou]*\nzero or more vowels\n\n\n[aeiou]+\none or more vowels\n\n\n[aeiou]{3}\nexactly three vowels\n\n\n[aeiou]{3,5}\nbetween 3 and 5 vowels\n\n\n[aeiou]{3,}\n3 or more vowels",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Regular Expressions</span>"
    ]
  },
  {
    "objectID": "RegularExpressions.html#example-2-matching-email-addresses",
    "href": "RegularExpressions.html#example-2-matching-email-addresses",
    "title": "\n16  Regular Expressions\n",
    "section": "\n16.3 Example 2: Matching Email Addresses",
    "text": "16.3 Example 2: Matching Email Addresses\nWe next want to extract email addresses from a text string. Typically the pattern of an email address is: something@somethingelse.extension. We can try to come up with a pattern for this. A good way to \"build\" regular expressions like these is to use tools like Regexr which is a website-tool where you see how your regular expression matches certain patterns in real time. In addition, if you hover over the regular expression a pop-out appears that describes what the regular expression does.\n\n\nPython Code\nR Code\n\n\n\n\nimport re\n\nmyTextString = \"\"\"We need to call\n    John (foo@demo.net), James (bar.ba@test.co.au)\n    as well as Jimmy (jjing@towson.edu) and Charles\n    (ch.ch.43-1_20@towson.students.edu) to make sure it gets all done.\"\"\"\n\nmyRegex = re.compile(r'[\\w_\\-\\.]+@[\\w_\\-\\.]+\\.[a-zA-Z]{2,5}')\nmyList = myRegex.findall(myTextString)\nprint(myList)\n\n['foo@demo.net', 'bar.ba@test.co.au', 'jjing@towson.edu', 'ch.ch.43-1_20@towson.students.edu']\n\n\n\n\nThis R code uses the stringr library and the str_extract_all function to extract email addresses based on the specified regular expression pattern. It then prints the extracted email addresses in a readable format.\n\n# Load the stringr library\nlibrary(stringr)\n\n# Assign your text info to a string variable\nmyTextString &lt;- \"We need to call John (foo@demo.net), James (bar.ba@test.co.au) as well as Jimmy (jjing@towson.edu) and Charles (ch.ch.43-1_20@towson.students.edu) to make sure it gets all done.\"\n\n# Define the regular expression pattern for email addresses\nmyRegexPattern &lt;- \"[\\\\w_\\\\-\\\\.]+@[\\\\w_\\\\-\\\\.]+\\\\.[a-zA-Z]{2,5}\"\n\n# Use str_extract_all to find and extract all matches\nmyList &lt;- str_extract_all(myTextString, myRegexPattern)[[1]]\n\n\n\n\nOr prettier\n\n\nPython Code\nR Code\n\n\n\n\nfor i,email in enumerate(myList):\n    print('{} Email: {}'.format(i+1, email))\n\n1 Email: foo@demo.net\n2 Email: bar.ba@test.co.au\n3 Email: jjing@towson.edu\n4 Email: ch.ch.43-1_20@towson.students.edu\n\n\n\n\n\n# Print the extracted email addresses\nfor (i in 1:length(myList)) {\n  cat(i, \"Email:\", myList[i], \"\\n\")\n}\n\n1 Email: foo@demo.net \n2 Email: bar.ba@test.co.au \n3 Email: jjing@towson.edu \n4 Email: ch.ch.43-1_20@towson.students.edu",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Regular Expressions</span>"
    ]
  },
  {
    "objectID": "RegularExpressions.html#tutorials",
    "href": "RegularExpressions.html#tutorials",
    "title": "\n16  Regular Expressions\n",
    "section": "\n16.4 Tutorials",
    "text": "16.4 Tutorials\nSome of the notes above are summaries of these tutorials:\n\nAutomate the Boring Stuff with Python\nWikipedia on Regular Expressions\nRegexr Website",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Regular Expressions</span>"
    ]
  },
  {
    "objectID": "RegularExpressions.html#references",
    "href": "RegularExpressions.html#references",
    "title": "\n16  Regular Expressions\n",
    "section": "\n16.5 References",
    "text": "16.5 References\n\n\nSweigart2015\n\nSweigart, Al \"Automate the Boring Stuff with Python,\" No Starch Press, 2015.",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Regular Expressions</span>"
    ]
  },
  {
    "objectID": "RegularExpressions.html#key-concepts-and-summary",
    "href": "RegularExpressions.html#key-concepts-and-summary",
    "title": "\n16  Regular Expressions\n",
    "section": "\n16.6 Key Concepts and Summary",
    "text": "16.6 Key Concepts and Summary\n\n\n\n\n\n\nNote\n\n\n\n\nRegular expressions\nPattern matching",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Regular Expressions</span>"
    ]
  },
  {
    "objectID": "RegularExpressions.html#self-check-questions",
    "href": "RegularExpressions.html#self-check-questions",
    "title": "\n16  Regular Expressions\n",
    "section": "\n16.7 Self-Check Questions",
    "text": "16.7 Self-Check Questions\n\n\n\n\n\n\ntodo\n\n\n\n\nWrite up a regular expression that can match a US phone number\nWrite up a regular expression that can match a US social security number",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Regular Expressions</span>"
    ]
  },
  {
    "objectID": "Random.html",
    "href": "Random.html",
    "title": "\n17  Random Numbers\n",
    "section": "",
    "text": "17.1 Drawing a Random Number\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport math\nfrom scipy import stats as st\nimport time  # Imports system time module to time your script\n\nplt.close('all')  # close all open figures\ntic = time.time()\nLet us start with a simple example. Draw a random number that is between zero and one.\nIf you run this again you will get a different random number.\nSometimes it is useful to make sure that the random number sequence that you draw at each run is identical. What you can now do is to set the random number generator on your computer to a specific starting value, or seed. On each run, the same sequence of random numbers is now generated.\nNow we reset the seed to the same value again and draw the second random number. You see, this time, it's identical because it is the first number in a restarted sequence of random numbers.\nIf you now draw yet another random number without re-setting the seed, you will get a different random number again.",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Random Numbers</span>"
    ]
  },
  {
    "objectID": "Random.html#drawing-a-random-number",
    "href": "Random.html#drawing-a-random-number",
    "title": "\n17  Random Numbers\n",
    "section": "",
    "text": "Python Code\nR Code\n\n\n\n\nmyNumber = np.random.uniform(0,1)\nprint('My first random number in [0,1] is {}'.format(myNumber))\n\nMy first random number in [0,1] is 0.7224080847261912\n\n\n\n\nIn R, set.seed(42) is used to initialize the random number generator with a specific seed for reproducibility. The function runif(1, 0, 1) generates a single random number between 0 and 1. The cat() function is used for printing, and paste() is used to concatenate strings and variables.\n\nset.seed(42)  # Setting a seed for reproducibility\nmyNumber &lt;- runif(1, 0, 1)\ncat(paste(\"My first random number in [0,1] is \", myNumber))\n\nMy first random number in [0,1] is  0.914806043496355\n\n\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nmyNumber = np.random.uniform(0,1)\nprint('My second random number in [0,1] is {}'.format(myNumber))\n\nMy second random number in [0,1] is 0.29420780253657497\n\n\n\n\n\nmyNumber &lt;- runif(1, 0, 1)\ncat(paste(\"My first random number in [0,1] is \", myNumber))\n\nMy first random number in [0,1] is  0.937075413297862\n\n\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nnp.random.seed(123456789)\nmyNumber = np.random.uniform(0,1)\nprint('My first random number in [0,1] is {}'.format(myNumber))\n\nMy first random number in [0,1] is 0.532833024789759\n\n\n\n\n\nset.seed(123456789)\nmyNumber &lt;- runif(1, 0, 1)\ncat(paste(\"My first random number in [0,1] is \", myNumber))\n\nMy first random number in [0,1] is  0.693175739841536\n\n\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nnp.random.seed(123456789)\nmyNumber = np.random.uniform(0,1)\nprint('My second random number in [0,1] is {}'.format(myNumber))\n\nMy second random number in [0,1] is 0.532833024789759\n\n\n\n\n\nset.seed(123456789)\nmyNumber &lt;- runif(1, 0, 1)\ncat(paste(\"My second random number in [0,1] is \", myNumber))\n\nMy second random number in [0,1] is  0.693175739841536\n\n\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nmyNumber = np.random.uniform(0,1)\nprint('My third random number in [0,1] is {}'.format(myNumber))\n\nMy third random number in [0,1] is 0.5341366008904166\n\n\n\n\n\nmyNumber &lt;- runif(1, 0, 1)\ncat(paste(\"My third random number in [0,1] is \", myNumber))\n\nMy third random number in [0,1] is  0.672880954574794",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Random Numbers</span>"
    ]
  },
  {
    "objectID": "Random.html#uniformly-distributed-random-numbers",
    "href": "Random.html#uniformly-distributed-random-numbers",
    "title": "\n17  Random Numbers\n",
    "section": "\n17.2 Uniformly Distributed Random Numbers",
    "text": "17.2 Uniformly Distributed Random Numbers\nYou can also draw multiple numbers at the same time without running a loop. In the next example we draw a sequence of 10,000 random numbers from the [0,1] interval.\n\n\nPython Code\nR Code\n\n\n\n\nnp.random.seed(123456789)\n\n# Uniform distributed random numbers\nu = np.random.uniform(0,1,(10000,))\n\n\n\n\nset.seed(123456789)\n\n# Generate 10,000 uniform distributed random numbers\nu &lt;- runif(10000)\n\n\n\n\nWe next make a histogram of these numbers to see the shape of the distribution where they come from. I set the number of bars in the histogram to 30 in order to get a nice picture.\n\n\nPython Code\nR Code\n\n\n\n\nN = 50\n\n\n\n\nN &lt;- 50\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nfig, ax = plt.subplots()\nprob, bins, patches = ax.hist(u, bins=N, align='mid' )\nax.set_ylabel('Number of obs')\nax.set_title('Histogram of uniform random variable')\nplt.show()\n\n\n\n\n\n\n\n\n\nIn this R code, hist() generates a histogram of the variable u with N bins, where N is the number of breaks or bins for the histogram. The main parameter specifies the title of the plot, and xlab and ylab label the x-axis and y-axis, respectively.\n\n# N represents the number of bins\nN &lt;- 30\n\n# Create a histogram plot of the generated uniform random numbers\nhist(u, breaks = N, main = \"Histogram of uniform random variable\", xlab = \"Value\", ylab = \"Number of obs\")",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Random Numbers</span>"
    ]
  },
  {
    "objectID": "Random.html#normally-distributed-random-numbers",
    "href": "Random.html#normally-distributed-random-numbers",
    "title": "\n17  Random Numbers\n",
    "section": "\n17.3 Normally distributed random numbers",
    "text": "17.3 Normally distributed random numbers\nThe density function of a normal distribution is:\n\\[f(x) = \\frac{1}{\\sigma \\times \\sqrt{2 \\times \\pi}} \\times e^{-\\frac{(x-\\mu)^2}{2\\times \\sigma^2}}\\]\nwhere \\(\\mu\\) and \\(\\sigma\\) are the mean and standard deviation the normal distribution.\nA standard normal distribution has a mean of zero and a standard deviation of one so that the density function simplifies to\n\\[f(x) = \\frac{1}{\\sqrt{2 \\times \\pi}} \\times e^{-\\frac{x^2}{2}}\\]\n\n\nPython Code\nR Code\n\n\n\n\ndef f_phi(x):\n    # density function of standard normal\n    s = np.exp(-(x**2/2))/np.sqrt(2*np.pi)\n    return s\n\n# Draws 10,000 standard normally distributed random numbers\nz = np.random.normal(0,1,(10000,))\n\n\n\n\n# Define the density function of standard normal\nf_phi &lt;- function(x) {\n  s &lt;- exp(-(x^2/2)) / sqrt(2 * pi)\n  return(s)\n}\n\n# Generate 10,000 standard normal random numbers\nz &lt;- rnorm(10000, mean = 0, sd = 1)\n\n\n\n\nThen plot it.\n\n\nPython Code\nR Code\n\n\n\n\nfig, ax = plt.subplots()\nprob, bins, patches = ax.hist(z, bins=N, align='mid', alpha=0.5)\nax.set_ylabel('Number of Observations')\nax.set_title('Histogram of normal random variable')\n#\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# N represents the number of bins\nN &lt;- 30\n\n# Plot the histogram of the normal random variable\nhist(z, breaks = N, main = \"Histogram of normal random variable\", xlab = \"Value\", ylab = \"Number of Observations\")\n\n\n\n\n\n\n\n\n\n\nIf you want to see the density function used the keyword density. You can then also compare your simulation density with the theoretical density of the Standard Normal distribution.\n\n\nPython Code\nR Code\n\n\n\n\nfig, ax = plt.subplots()\nprob, bins, patches = ax.hist(z, bins=N, density=1, align='mid', alpha=0.5)\nax.set_ylabel('Density')\nax.set_title('Histogram of normal random variable')\n\n# Plot the N(0,1) density function into the histogram\nx = np.arange(-5,5,0.1)\nax.plot(x, f_phi(x))\n\nax.legend(['Histogram','Normal Density'], loc='best')\n#\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# Number of bins\nN &lt;- 30\n\n# Create the histogram of the normal random variable with density\nhist(z, breaks = N, freq = FALSE, main = \"Histogram of normal random variable\", xlab = \"Value\", ylab = \"Density\")\n\n# Generate x-values for the standard normal distribution curve\nx &lt;- seq(-5, 5, by = 0.1)\n\n# Compute the density function values\ny &lt;- dnorm(x, mean = 0, sd = 1)\n\n# Add the N(0,1) density function to the histogram plot\nlines(x, y, col = \"blue\")\n\n# Add legend\nlegend(\"topright\", legend = c(\"Histogram\", \"Normal Density\"), col = c(\"black\", \"blue\"), lty = 1)\n\n\n\n\n\n\n\n\n\n\nNow back to the regular normal distribution with mean mu and standard deviation sigma. Here is the density function in Python with the mean and standard deviation as additional inputs. I also programmed default values for these, so if the user does not specify mean and variance, the function is going to be the standard normal distribution by default.\n\n\nPython Code\nR Code\n\n\n\n\ndef f_normalDensity(x, mu=0, sigma=1):\n    # density function of standard normal\n    s = np.exp(-((x - mu)**2/(2*sigma**2)))/(sigma * np.sqrt(2*np.pi))\n    return s\n\n\n\n\nf_normalDensity &lt;- function(x, mu = 0, sigma = 1) {\n  s &lt;- exp(-((x - mu)^2 / (2 * sigma^2))) / (sigma * sqrt(2 * pi))\n  return(s)\n}\n\n\n\n\nHere is another example of two normally distributed random variables. The first random variable has a smaller standard deviation than the second. Let us see how the distribution of these two compare.\n\n\nPython Code\nR Code\n\n\n\n\nz1 = np.random.normal(0,1,(10000,))\nz2 = np.random.normal(0,2,(10000,))\n\n\n\n\n# Number of bins\nN &lt;- 30\n\n# Create two normally distributed random variables\nz1 &lt;- rnorm(10000, mean = 0, sd = 1)\nz2 &lt;- rnorm(10000, mean = 0, sd = 2)\n\n\n\n\nNow plot it.\n\n\nPython Code\nR Code\n\n\n\n\nfig, ax = plt.subplots(2,1)\nfig.subplots_adjust(hspace=0.8)\n#\nprob, bins, patches = ax[0].hist(z1, bins=N, align='mid' )\nax[0].set_ylabel('Number of obs')\nax[0].set_title('Histogram of N(0,1) random variable')\nax[0].set_xlim([-10, 10])\n#\n\n(-10.0, 10.0)\n\nprob, bins, patches = ax[1].hist(z2, bins=N, align='mid' )\nax[1].set_ylabel('Number of obs')\nax[1].set_title('Histogram of N(0,2) random variable')\nax[1].set_xlim([-10, 10])\n\n(-10.0, 10.0)\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# Plot the histograms for both random variables\npar(mfrow = c(2, 1))  # Arrange the plots in a 2x1 grid\nhist(z1, breaks = N, freq = FALSE, main = \"Histogram of N(0,1) random variable\", xlab = \"Value\", ylab = \"Density\", xlim = c(-10, 10))\nhist(z2, breaks = N, freq = FALSE, main = \"Histogram of N(0,2) random variable\", xlab = \"Value\", ylab = \"Density\", xlim = c(-10, 10))\n\n\n\n\n\n\n\n\n\n\nIf you want to compare the distribution to the density function again, you can accomplish this by specifying the density option in the hist() method. This makes sure that the area under the curve sums up to one.\n\n\nPython Code\nR Code\n\n\n\n\nfig, ax = plt.subplots(2,1)\nfig.subplots_adjust(hspace=0.8)\n#\nprob, bins, patches = ax[0].hist(z1, density=1, bins=N, align='mid' )\nax[1].set_ylabel('Density')\nax[0].set_title('Histogram of N(0,1) random variable')\nax[0].set_xlim([-10, 10])\n\n# Plot the N(0,1) density function into the histogram\n\n(-10.0, 10.0)\n\nxv = np.arange(-5,5,0.1)\nax[0].plot(xv, f_normalDensity(xv, 0, 1))\nax[0].legend(['Histogram','Normal Density'], loc='best')\n\n#\nprob, bins, patches = ax[1].hist(z2, density=1, bins=N, align='mid' )\nax[1].set_ylabel('Density')\nax[1].set_title('Histogram of N(0,2) random variable')\nax[1].set_xlim([-10, 10])\n#\n\n(-10.0, 10.0)\n\nax[1].plot(xv, f_normalDensity(xv, 0, 2))\nax[1].legend(['Histogram','Normal Density'], loc='best')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# Histogram for N(0,1) random variable\npar(mfrow = c(2, 1))  # To create a layout of two plots\nlayout(matrix(c(1, 2), nrow = 2))  # To define plot arrangement\n\n# N(0,1) random variable histogram and density function\nhist(z1, prob = TRUE, breaks = N, xlim = c(-10, 10), main = \"Histogram of N(0,1) random variable\")\ncurve(dnorm(x, mean = 0, sd = 1), from = -5, to = 5, col = \"blue\", lwd = 2, add = TRUE, legend = \"topright\",\n      xlab = \"x values\", ylab = \"Density\")\n\nWarning in plot.xy(xy.coords(x, y), type = type, ...): \"legend\" is not a\ngraphical parameter\n\nlegend(\"topright\", legend = c(\"Histogram\", \"Normal Density\"), col = c(\"black\", \"blue\"), lwd = c(1, 2))\n\n# N(0,2) random variable histogram and density function\nhist(z2, prob = TRUE, breaks = N, xlim = c(-10, 10), main = \"Histogram of N(0,2) random variable\")\ncurve(dnorm(x, mean = 0, sd = 2), from = -5, to = 5, col = \"blue\", lwd = 2, add = TRUE, legend = \"topright\",\n      xlab = \"x values\", ylab = \"Density\")\n\nWarning in plot.xy(xy.coords(x, y), type = type, ...): \"legend\" is not a\ngraphical parameter\n\nlegend(\"topright\", legend = c(\"Histogram\", \"Normal Density\"), col = c(\"black\", \"blue\"), lwd = c(1, 2))",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Random Numbers</span>"
    ]
  },
  {
    "objectID": "Random.html#t-distributed-random-variable",
    "href": "Random.html#t-distributed-random-variable",
    "title": "\n17  Random Numbers\n",
    "section": "\n17.4 T-Distributed Random Variable",
    "text": "17.4 T-Distributed Random Variable\n\n\nPython Code\nR Code\n\n\n\n\ndof = 29\nxv = np.random.standard_t(dof, 5)\nprint(xv)\n\n[ 1.39223765 -0.52924457 -0.82809716 -0.39349782 -1.98709951]\n\n\n\n\n\ndof &lt;- 29\nxv &lt;- rt(5, df = dof)\nprint(xv)\n\n[1]  0.5461816  1.5169804  0.3559650 -1.5192155  0.6941430\n\n\n\n\n\nWe can also code the t-distribution as a combination of a normal and \\(\\chi^2\\) distribution.\n\\[X \\sim N(0,1)\\]\\[Y \\sim \\chi^2_v\\]\\[T = \\frac{X}{\\sqrt(Y/v)}\\]\nwhere \\(v\\) are the degrees of freedom. The \\(\\chi^2\\) distribution itself can be expressed as a gamma distribution\n\n\\[\\chi^2_v = \\Gamma(1/2, v/2),\\]\n\nwith \\(v\\) degrees of freedom.\n\n\nPython Code\nR Code\n\n\n\n\ndef student_tvariate(df): # df is the number of degrees of freedom\n    if df &lt; 2 or int(df) != df:\n        raise ValueError('student_tvariate: df must be a integer &gt; 1')\n    x = np.random.normal(0, 1)\n    y = np.random.gamma(df/2.0, 2)\n    return x / (np.sqrt(y/df))\n\nt = np.zeros((10000),float)\nfor i in range(10000):\n    t[i] = student_tvariate(20)\n\n\n\n\n# Define a function to generate Student's t-distributed variable\nstudent_tvariate &lt;- function(df) {\n  if (df &lt; 2 | as.integer(df) != df) {\n    stop('student_tvariate: df must be an integer &gt; 1')\n  }\n  x &lt;- rnorm(1, 0, 1)\n  y &lt;- rgamma(1, shape = df/2, rate = 2)\n  return(x / sqrt(y/df))\n}\n\n# Generate the Student's t-distributed variable with 20 degrees of freedom\nset.seed(123)  # Setting seed for reproducibility\nt &lt;- replicate(10000, student_tvariate(20))\n\n# Create a histogram of the generated values\nhist(t, breaks = 'FD', main = 'Histogram of T(dof=20) random variable',\n     xlab = 'Value', ylab = 'Number of observations')\n\n\n\n\n\n\n\n\n\n\nAnd the plotting routine is:\n\n\nPython Code\nR Code\n\n\n\n\nfig, ax = plt.subplots()\n#\nprob, bins, patches = ax.hist(t, bins=N, align='mid' )\nax.set_ylabel('Number of obs')\nax.set_title('Histogram of T(dof=20) random variable')\n#\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# Create a histogram of the generated values\nhist(t, breaks = 'FD', main = 'Histogram of T(dof=20) random variable',\n     xlab = 'Value', ylab = 'Number of observations')",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Random Numbers</span>"
    ]
  },
  {
    "objectID": "Random.html#drawing-random-integer-values",
    "href": "Random.html#drawing-random-integer-values",
    "title": "\n17  Random Numbers\n",
    "section": "\n17.5 Drawing Random Integer Values",
    "text": "17.5 Drawing Random Integer Values\nIf you want to draw integer numbers at random you can use the np.random.randint() method. If we would like to draw random integer numbers that are either {1,2,3,4} we need to specify np.random.randint(1,5). Note the half open interval definition again that is consistently used across the numpy library.\n\n\n\n\n\n\nNote\n\n\n\nAlternatively you can use the random library. But be careful, the random library defines random.randint() as closed intervals. The example above using the random library would use random.randint(1,4).\n\n\nIn the following I will always use the random number generator from the numpy library.\n\n\nPython Code\nR Code\n\n\n\n\nimport numpy as np\n\nintegerList = np.random.randint(1, 5, 10)\nprint(integerList)\n\n[2 2 3 3 4 4 2 3 1 2]\n\n\n\n\n\n# Generating random integers between 1 and 4 for 10 times\nintegerList &lt;- sample(1:4, 10, replace = TRUE)\nprint(integerList)\n\n [1] 3 3 3 3 4 3 3 1 2 1\n\n\n\n\n\nSimilarly, if you would like to draw five random integer numbers between 7 and 10 you would specify:\n\n\nPython Code\nR Code\n\n\n\n\nintegerList = np.random.randint(7, 11, 5)\nprint(integerList)\n\n[10  9  9  7  8]\n\n\n\n\n\n# Drawing five random integer numbers between 7 and 10\nintegerList_2 &lt;- sample(7:10, 5, replace = TRUE)\nprint(integerList_2)\n\n[1] 10  9  7 10  7\n\n\n\n\n\nWe can again draw 10,000 values and plot them into a bar-chart.\n\n\nPython Code\nR Code\n\n\n\n\nintegerList = np.random.randint(7, 11, 10000)\n\n\n\n\n# Drawing 10,000 values between 7 and 10\nintegerList &lt;- sample(7:10, 10000, replace = TRUE)\n\n# Counting the number of occurrences of each integer value\ntable(integerList)\n\nintegerList\n   7    8    9   10 \n2455 2573 2536 2436 \n\n\n\n\n\nWe next count the number of occurrences of each integer value.\n\n\nPython Code\nR Code\n\n\n\n\nxv = np.bincount(integerList)\nprint(xv)\n\n[   0    0    0    0    0    0    0 2553 2515 2444 2488]\n\n\n\n\n\n# Here is the vector to represent the occurrences of numbers from 7 to 10\nxv &lt;- table(integerList)\n\n\n\n\nAnd now we plot the bar-chart with the absolute frequency of each one of the numbers from 7 to 10.\n\n\nPython Code\nR Code\n\n\n\n\nfig, ax = plt.subplots()\nax.bar(7 + np.arange(4), xv[7:11], align='center')\n\n&lt;BarContainer object of 4 artists&gt;\n\nax.set_xticks(7. + np.arange(4))\nax.set_ylabel('Number of obs')\nax.set_title('Bar Chart of Random Number Occurrences')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# Plotting the bar chart to display the absolute frequency of each number\nbarplot(xv, names.arg = names(xv), xlab = 'Numbers', ylab = 'Number of Observations', main = 'Bar Chart of Random Number Occurrences')",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Random Numbers</span>"
    ]
  },
  {
    "objectID": "Random.html#generating-actions-based-on-probabilities",
    "href": "Random.html#generating-actions-based-on-probabilities",
    "title": "\n17  Random Numbers\n",
    "section": "\n17.6 Generating actions based on probabilities",
    "text": "17.6 Generating actions based on probabilities\nIn simulations, statistical applications, or computer games it is often necessary to generate actions based on a certain probability.\nFor instance, a person wake up in the morning and has a 20 percent chance of having a headache.\nSimulate 10 people based on this given probability and check how many of them have a headache. We know that theoretically we would expect out of the 10 people, 2 (on average) should wake up with headaches.\nBut of course, waking up with a headache is a probabilistic event, so that it could be that out of the 10 people nobody has a headache, one person has a headache and so on. All of these outcomes are possible but some are more likely than other given the 20 percent probability that we have been given.\nIn any case, let's simulate the 10 people. Since we only track whether they have headaches or not (and nothing else), I will not use OOP for this. OOP with a more complete simulation follows in the next section. I will simply collect the information about headaches in a list.\n\n\nPython Code\nR Code\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nheadacheList  = []\n\n# We now generate 10 \"people\"\nfor i in range(10):\n    if np.random.rand() &lt;=0.2:\n        # Person has headache\n        headacheList.append('yes')\n    else:\n        # Person does not have headache\n        headacheList.append('no')\n\n\n\n\n# Generating a list of people with or without headaches\nset.seed(123)  # Setting seed for reproducibility\nheadacheList &lt;- ifelse(runif(10) &lt;= 0.2, \"yes\", \"no\")\n\n\n\n\nWe next plot a bar chart with the absolute frequencies.\n\n\nPython Code\nR Code\n\n\n\n\n# Frequency table\nabsFreqv = np.array([headacheList.count('yes'), headacheList.count('no')])\nlabelList = ['headache', 'no-headache']\n\nfig, ax = plt.subplots()\nax.bar(labelList, absFreqv, align='center')\n\n&lt;BarContainer object of 2 artists&gt;\n\nax.set_ylabel('Number of people')\nax.set_title('Number of people with and without headaches')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# Creating a frequency table\nabsFreqv &lt;- table(headacheList)\n\n# Plotting a bar chart to display the number of people with and without headaches\nbarplot(absFreqv, main = \"Number of People with and without Headaches\", xlab = \"Headache\", ylab = \"Number of People\", col = c(\"blue\", \"red\"))\n\n\n\n\n\n\n\n\n\n\nAnd finally a pie chart with the relative frequencies:\n\n\nPython Code\nR Code\n\n\n\n\n# Calculate relative frequencies\nrelFeqv = absFreqv/np.sum(absFreqv)\n\nfig, ax = plt.subplots()\nax.pie(relFeqv , labels=labelList, autopct='%.1f%%')\n\n([&lt;matplotlib.patches.Wedge object at 0x7f970e30c810&gt;, &lt;matplotlib.patches.Wedge object at 0x7f970c433790&gt;], [Text(0.6465637441936395, 0.8899187180267095, 'headache'), Text(-0.6465637441936395, -0.8899187180267095, 'no-headache')], [Text(0.3526711331965306, 0.48541020983275057, '30.0%'), Text(-0.3526711331965306, -0.48541020983275057, '70.0%')])\n\nax.set_title('Fraction of people with and without headaches')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# Calculating relative frequencies\nrelFeqv &lt;- prop.table(absFreqv)\n\n# Example label list (Replace this with your labelList variable)\nlabelList &lt;- c(\"headache\", \"no-headache\")\n\n# Creating a pie chart to display the fraction of people with and without headaches\npie(relFeqv, labels = labelList, main = \"Fraction of People with and without Headaches\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nWe have essentially used draws from the uniform distribution as np.random.rand() draws numbers between [0,1] with equal probability i.e., from a uniform distribution. You could also have used np.random.uniform(0,1) to accomplish the same type of random draw.\n\n\nThe same method works for more complicated probability events. Let us say that you have a change of 10 percent of having a headache, a 30 percent chance of having a backache, and a residual 60 percent chance of having no pain at all. You can simulate this easily using the uniform distribution again. Draw the random number using np.random.rand() and\n\n\nif it is less than 0.1 (happens with a 10 percent chance) you have the headache,\nif it is between 0.1 and 0.4 (happens with a 30 percent chance) you have a backache, and\nif it is larger than 0.4 (happens with a 60 percent chance) you have no pain.\n\n\nHere is the implementation:\n\n\nPython Code\nR Code\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\npainList  = []\n\n# We now generate 10 \"people\"\nfor i in range(10):\n    randNr = np.random.rand()\n    if randNr &lt;=0.1:\n        # Person has headache with 10% chance\n        painList.append('headache')\n    elif randNr &gt;0.1 and randNr &lt;= 0.4:\n        # Person has backache with 30% chance\n        painList.append('backache')\n    else:\n        # Person does not have pain with 60%\n        painList.append('no-ache')\n\nprint(painList)\n\n['no-ache', 'backache', 'no-ache', 'no-ache', 'no-ache', 'headache', 'no-ache', 'no-ache', 'no-ache', 'headache']\n\n\n\n\n\n# Generate a list of pain types for 10 people\npainList &lt;- c()\n\nfor (i in 1:10) {\n  randNr &lt;- runif(1)\n\n  if (randNr &lt;= 0.1) {\n    painList &lt;- c(painList, \"headache\")\n  } else if (randNr &gt; 0.1 && randNr &lt;= 0.4) {\n    painList &lt;- c(painList, \"backache\")\n  } else {\n    painList &lt;- c(painList, \"no-ache\")\n  }\n}\n\nprint(painList)\n\n [1] \"no-ache\"  \"no-ache\"  \"no-ache\"  \"no-ache\"  \"backache\" \"no-ache\" \n [7] \"backache\" \"headache\" \"backache\" \"no-ache\" \n\n\n\n\n\nYou can do the frequency count and graphs as an exercise.",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Random Numbers</span>"
    ]
  },
  {
    "objectID": "Random.html#drawing-objects-with-random-values",
    "href": "Random.html#drawing-objects-with-random-values",
    "title": "\n17  Random Numbers\n",
    "section": "\n17.7 Drawing Objects with Random Values",
    "text": "17.7 Drawing Objects with Random Values\nIn this section we demonstrate how we can combine the concepts from the prior chapter on object oriented programming with generating random numbers. We will generate a number of objects whose attributes (or self. variables) will be drawn randomly from certain distributions. In addition we define methods, that will call on random number generators to do something randomly to our objects.\n\n\n\n\n\n\nObject Oriented Programming\n\n\n\nOOP is not at the core of R and was “bolted on” later as a new feature. It is often very difficult/cumbersome to program in this style in R. I therefore recommend to stick with Python if you know that your code will require OOP.\n\n\nWe start by defining our class and the methods that we can subsequently call on these type of objects. We call it the RandomMan class. Objects generated according to this blueprint are then instantiations of this class which we call RandomMan objects.\n\n# Set random seed\nnp.random.seed(123456789)\n\nclass RandomMan(object):\n    \"\"\"This is a random man object.\n    RandomMan has a name, numer of children and income.\n    RandomMan can showMan(), earnIncome(),\n    buyInsurance() and experience and incomeShock()\"\"\"\n\n    def __init__(self, name = 'John Doe'):\n        \"\"\"Initialize the man-object with a\n        random nr. of children between 0 and 10 and\n        with random income drawn from a log-normal distribution\n        and an insurance state of 0.\"\"\"\n        self.name = name\n        self.children = np.random.randint(0, 10, 1)\n        self.income = np.random.lognormal(np.log(50000), 0.2, 1)\n        self.insurance = 0  # 0 no insurance, 1 has insurance\n\n    def showMan(self):\n        \"\"\"Method: showMan() prints out\n        the variables stored in the man\n        object.\"\"\"\n        print(\"\\n\")\n        print(\"Hello, let me introduce myself.\")\n        print(\"-------------------------------\")\n        print(\"My name is {}\".format(self.name))\n        if self.children == 1:\n            # Get grammar right child/children\n            print(\"I have {:1.0f} child\" \\\n                .format(self.children.item()))\n        else:\n            print(\"I have {:1.0f} children\" \\\n                .format(self.children.item()))\n\n        print(\"My income is ${:6.0f}\" \\\n          .format(self.income.item()))\n        if self.insurance == 0:\n            print(\"I have NO insurance\")\n        else:\n            print(\"I have insurance\")\n\n    def earnIncome(self, workTime = 0.0):\n        \"\"\"Make man richer by working.\"\"\"\n        self.income += np.sqrt(1 + workTime)\n\n    def buyInsurance(self):\n        \"\"\"Buy insurance if the man is lucky.\n        Lucky is define as a [0, 1] random number\n        to be smaller than 0.4. So the guy has\n        a 40% chance of being lucky. If she is lucky\n        she will buy insurance.\"\"\"\n        if np.random.rand()&lt;0.4:\n            # Insurance state flips to 1\n            self.insurance = 1\n            # Insurance costs $100, so the premium is subtracted\n            # from her income\n            self.income += -100\n        else:\n            # Insurance state flips to 0\n            self.insurance = 0\n\n    def shockIncome(self):\n        \"\"\"Shocks income randomly with a negative\n        value between -5000 and 0.\"\"\"\n        if self.insurance == 0:\n            # If she has no insurance, her income\n            # is randomly reduced\n            self.income += np.random.uniform(-5000, 0, 1)\n\nWe next generate 10 randomMan objects.\n\nrandomManList = []\n\nprint(' --- Create men --- ')\n\n --- Create men --- \n\nfor i in range(10):\n    # Here we create the randomMan objects and store them in\n    # the list\n    randomManList.append(RandomMan())\n    randomManList[i].showMan()\n\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is John Doe\nI have 8 children\nMy income is $ 43714\nI have NO insurance\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is John Doe\nI have 4 children\nMy income is $ 54296\nI have NO insurance\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is John Doe\nI have 3 children\nMy income is $ 63022\nI have NO insurance\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is John Doe\nI have 2 children\nMy income is $ 65839\nI have NO insurance\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is John Doe\nI have 4 children\nMy income is $ 57828\nI have NO insurance\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is John Doe\nI have 1 child\nMy income is $ 56013\nI have NO insurance\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is John Doe\nI have 3 children\nMy income is $ 40094\nI have NO insurance\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is John Doe\nI have 5 children\nMy income is $ 44958\nI have NO insurance\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is John Doe\nI have 9 children\nMy income is $ 55136\nI have NO insurance\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is John Doe\nI have 0 children\nMy income is $ 64535\nI have NO insurance\n\nprint(' --- Done --- ')\n\n --- Done --- \n\n\nFinally we let them live for one round.\n\nprint('----------------------')\n\n----------------------\n\nprint(' --- Let man live --- ')\n\n --- Let man live --- \n\nprint('----------------------')\n\n----------------------\n\nfor i in range(len(randomManList)):\n    # Earn income by working randomly between\n    # 0 and 40 hours\n    randomManList[i].earnIncome(np.random.uniform(0, 40, 1))\n    # Buy insurance, if luck\n    randomManList[i].buyInsurance()\n    # Experience random income shock if NOT insured\n    randomManList[i].shockIncome()\n    # Show yourself\n    randomManList[i].showMan()\n\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is John Doe\nI have 8 children\nMy income is $ 43619\nI have NO insurance\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is John Doe\nI have 4 children\nMy income is $ 54201\nI have insurance\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is John Doe\nI have 3 children\nMy income is $ 58692\nI have NO insurance\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is John Doe\nI have 2 children\nMy income is $ 62261\nI have NO insurance\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is John Doe\nI have 4 children\nMy income is $ 57734\nI have NO insurance\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is John Doe\nI have 1 child\nMy income is $ 55919\nI have insurance\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is John Doe\nI have 3 children\nMy income is $ 38834\nI have NO insurance\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is John Doe\nI have 5 children\nMy income is $ 44865\nI have insurance\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is John Doe\nI have 9 children\nMy income is $ 50320\nI have NO insurance\n\n\nHello, let me introduce myself.\n-------------------------------\nMy name is John Doe\nI have 0 children\nMy income is $ 64440\nI have insurance\n\n\nNow let's blow it up and generate 1,000 random people.\n\nprint(' --- Create men --- ')\n\n --- Create men --- \n\nrandomManList = []\nN = 1000\n\nfor i in range(N):\n    # Here we create the randomMan objects and store them in\n    # the list\n    randomManList.append(RandomMan())\n\nprint(' --- Done --- ')\n\n --- Done --- \n\n\nLet's check the distribution of their income. We know it should look like a normal distribution. Let us first extract the income information and store it into a numpy array (or vector).\n\nincomev = np.zeros(N)\n\nfor i in range(N):\n    incomev[i] = randomManList[i].income\n\nprint('Mean income = {}'.format(incomev.mean()))\n\nMean income = 50745.14039661928\n\n\n\nfig, ax = plt.subplots()\nprob, bins, patches = ax.hist(incomev, bins=40, align='mid', alpha=0.5)\nax.set_ylabel('Number of obs')\nax.set_title('Histogram of Income')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\nKey Concepts and Summary\n\n\n\n\nDrawing random numbers\nDrawing random numbers from a specific distribution\nWriting a simple simulation\n\n\n\n\n\n\n\n\n\nSelf-check questions\n\n\n\n\n\n\nDraw 100 random numbers from a Standard Normal distribution",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Random Numbers</span>"
    ]
  },
  {
    "objectID": "Random2.html",
    "href": "Random2.html",
    "title": "18  Random Numbers II: An Infectious Disease Simulation",
    "section": "",
    "text": "18.1 Defining a Class Object of a Person\nimport time\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n#%% Class Definition\nclass person(object):\n    def __init__(self, id=0, xmax=100, ymax=100):\n        self.id = id\n        self.sick = int((np.random.random()&lt;0.01))\n        self.immune = False\n        self.xpos = np.random.randint(1,xmax,1)[0]\n        self.ypos = np.random.randint(1,ymax,1)[0]\n        self.age = np.random.randint(1,90,1)[0]\n        return\n    #end\n\n    def movePerson(self, jumpSize):\n        # Generate a random integer number [1,2,...,8]\n        pos = np.random.randint(1,9,1)[0]\n\n        if pos == 1:\n            self.ypos += jumpSize\n        elif pos == 2:\n            self.ypos+= jumpSize\n            self.xpos+= jumpSize\n        elif pos == 3:\n            self.xpos += jumpSize\n        elif pos == 4:\n            self.xpos += jumpSize\n            self.ypos -= jumpSize\n        elif pos == 5:\n            self.ypos -= jumpSize\n        elif pos == 6:\n            self.xpos -= jumpSize\n            self.ypos -= jumpSize\n        elif pos == 7:\n            self.xpos -= jumpSize\n        else:\n            self.xpos -= jumpSize\n            self.ypos += jumpSize\n\n        # Check boundaries\n        if self.xpos &lt; 0:\n            self.xpos = xmax\n        if self.xpos &gt; xmax:\n            self.xpos =0\n\n        if self.ypos &lt; 0:\n            self.ypos = ymax\n        if self.ypos &gt; ymax:\n            self.ypos = 0\n\n        return np.empty(1, np.float64)\n    #end\n\n    def updateHealth(self, boardXY, xmax, ymin):\n        # Neighborhood\n        neighxv = np.array([self.xpos, self.xpos+1, self.xpos+1, \\\n                           self.xpos+1, self.xpos, self.xpos-1, \\\n                           self.xpos-1, self.xpos-1])\n        neighyv = np.array([self.ypos+1, self.ypos+1, self.ypos, \\\n                           self.ypos-1, self.ypos-1, self.ypos-1, \\\n                           self.ypos, self.ypos+1])\n\n        neighxv[neighxv &gt; xmax] = xmax\n        neighxv[neighxv &lt; 0] = 0\n        neighyv[neighyv &gt; ymax] = ymax\n        neighyv[neighyv &lt; 0] = 0\n\n        neighv = np.zeros(8)\n        for i,(x,y) in enumerate(zip(neighxv,neighyv)):\n            neighv[i] = boardXY[x,y]\n        #end\n\n        if self.sick &gt; 0:\n            self.sick += 1\n        #end\n\n        if self.sick &gt; 14:\n            self.sick = 0 # recovered and healthy again\n            self.immune = True\n        #end\n\n        # If you bump into a sick person-field, make guy sick\n        if ((self.sick == 0) and (np.sum(neighv) &gt; 0) \\\n            and (self.immune == False)):\n            self.sick = 1 # newly sick\n        #end\n\n        return\n    #end\n\n#end",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Random Numbers II: An Infectious Disease Simulation</span>"
    ]
  },
  {
    "objectID": "Random2.html#defining-functions-for-plotting-and-moving-individuals",
    "href": "Random2.html#defining-functions-for-plotting-and-moving-individuals",
    "title": "18  Random Numbers II: An Infectious Disease Simulation",
    "section": "18.2 Defining Functions for Plotting and Moving Individuals",
    "text": "18.2 Defining Functions for Plotting and Moving Individuals\nWe next define functions that allow us to make interim plots after each simulation round. One simulation round represents a day in our setup.\n\ndef f_plotPeople(nrPeople, persList):\n    fig = plt.figure()\n    ax = plt.subplot(111, aspect='equal')\n    ax.set_title('Healthy/Sick Population')\n\n    xposSickv = np.array([],dtype=int)\n    yposSickv = np.array([],dtype=int)\n    xposHealthyv = np.array([],dtype=int)\n    yposHealthyv = np.array([],dtype=int)\n    for i in range(nrPeople):\n        person = persList[i]\n        if person.sick &gt; 0:\n            xposSickv = np.append(xposSickv, person.xpos)\n            yposSickv = np.append(yposSickv, person.ypos)\n        else:\n            xposHealthyv = np.append(xposHealthyv, person.xpos)\n            yposHealthyv = np.append(yposHealthyv, person.ypos)\n        #end\n    #end\n\n    ax.plot(xposSickv, yposSickv, marker='s', linestyle = 'None', \\\n            color = 'red', markersize=5, alpha=0.6)\n    ax.plot(xposHealthyv, yposHealthyv, marker='s', linestyle = 'None', \\\n            color = 'blue', markersize=5, alpha=0.6)\n    plt.legend(['Infected', 'Healthy'], loc = 1)\n    plt.show()\n    return\n#end\n\nThe next function updates the population of people by first allowing the person to move according to the jumpSize variable. If jumpSize equals zero the person self isolates and does not move at all.\n\ndef f_update(nrPeople, persList, boardXYin, xmax, ymax):\n    nrSick = 0\n    for i in range(nrPeople):\n        person = persList[i]\n        person.movePerson(jumpSize)\n        person.updateHealth(boardXYin, xmax, ymax)\n    #end\n    # Make new board and mark all the sick fields\n    boardXY = np.zeros([xmax+1, ymax+1])\n    for i in range(nrPeople):\n        person = persList[i]\n        if person.sick &gt; 0:\n            nrSick += 1\n            boardXY[person.xpos, person.ypos] = 1\n        #end\n    #end\n    return nrSick, boardXY\n#end\n\n\ndef f_simulateCase(nrPeople,jumpSize,xmax,ymax,maxIter,i_plotBoard):\n    persList = []\n\n    boardXY = np.zeros([xmax+1, ymax+1])\n    nrSickv = np.zeros(maxIter, dtype=int)\n\n    # Make person list\n    for i in range(nrPeople):\n        # Make person\n        person_i = person(id = i, xmax=xmax, ymax=ymax)\n        # If person is sick update board\n        if person_i.sick == True:\n            boardXY[person_i.xpos, person_i.ypos] = 1\n        #end\n        # Store person in list\n        persList.append(person_i)\n    #end\n\n    for i_loop in range(maxIter):\n        nrSickv[i_loop], boardXY = \\\n            f_update(nrPeople, persList, boardXY, xmax, ymax)\n\n        if i_loop &lt;10 or i_loop&gt;(maxIter-5):\n            print('---------------------------')\n            print('Round {} nr. sick {}'.format(i_loop, nrSickv[i_loop]))\n\n        if ((i_loop%10 == 0) and (i_plotBoard == 1)):\n            f_plotPeople(nrPeople, persList)\n        #end\n    #end\n\n    return nrSickv\n#end",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Random Numbers II: An Infectious Disease Simulation</span>"
    ]
  },
  {
    "objectID": "Random2.html#running-the-simulation",
    "href": "Random2.html#running-the-simulation",
    "title": "18  Random Numbers II: An Infectious Disease Simulation",
    "section": "18.3 Running the Simulation",
    "text": "18.3 Running the Simulation\nWe first set some basic parameters for our simulation. The number of days we want to simulate is determined by variable maxIter. The size of the grid where the people live is guided by xmax and ymax and the number of individuals is determined by nrPeople.\n\ntic = time.perf_counter()\n\n# Set random seed\nmySeedNumber = 143895784\n\n# Maximum days to simulate\nmaxIter = 70\n\n# Size of their world\nxmax = 40\nymax = 40\n\n# People\nnrPeople = 200\n\nWe next run our simulation for three different cases.\n\nIn the first everybody is allowed to move freely. We set jumpSize = 2 which allows for this wider movement. This entails a high risk of getting infected.\nIn the second case the government recommends some restrictions on the movement of the individuals which we simulate by setting jumpSize = 1. People move less, their risk of getting infected is therefore somewhat lower.\nIn the final case, the government completely locks down the country and everybody is \"forced to\" self-isolate so that the movement parameter jumpSize = 0.\n\nWe start start the simulation with a case where the government is not restricting any of the movements so that jumpSize is set to a \"large\" value of 2. People are allowed to move a lot and are at great risk of getting infected if they bump into someone who is sick i.e. land on an adjacent field of a sick person. We also plot the entire grid every 10 days so you can track the changes. The simulation tracks the number of sick people on each day of the simulation in vector nrSickv1.\n\n# Case 1: Move a lot (no restrictions)\nnp.random.seed(mySeedNumber)\ni_plotBoard = 1\njumpSize = 2  # How far they travel (interaction radius)\nnrSick1v = f_simulateCase(nrPeople,jumpSize,xmax,ymax,maxIter,i_plotBoard)\n\n---------------------------\nRound 0 nr. sick 5\n\n\n\n\n\n\n\n\n\n---------------------------\nRound 1 nr. sick 9\n---------------------------\nRound 2 nr. sick 12\n---------------------------\nRound 3 nr. sick 20\n---------------------------\nRound 4 nr. sick 26\n---------------------------\nRound 5 nr. sick 30\n---------------------------\nRound 6 nr. sick 35\n---------------------------\nRound 7 nr. sick 40\n---------------------------\nRound 8 nr. sick 48\n---------------------------\nRound 9 nr. sick 58\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n---------------------------\nRound 66 nr. sick 0\n---------------------------\nRound 67 nr. sick 0\n---------------------------\nRound 68 nr. sick 0\n---------------------------\nRound 69 nr. sick 0\n\n\nWe next simulate the case where the jumpSize variable is set to one. People are allowed to move (somewhat) and are at risk of getting infected if they bump into someone who is sick i.e. land on an adjacent field of a sick person. We also plot the entire grid for every 10 days so you can track the changes. The simulation tracks the number of sick people on for each day of the simulation in vector nrSickv2.\n\n\n\n\n\n\nWarning\n\n\n\nWhen we run the simulation again, we set the seed to the identical number as before so that the initial conditions remain the same and changes are therefore driven by the difference in policies and not random differences from the random number generation process.\n\n\n\n# Case 2: Some distancing\nnp.random.seed(mySeedNumber)\ni_plotBoard = 0\njumpSize = 1  # How far they travel (interaction radius)\nnrSick2v = f_simulateCase(nrPeople,jumpSize,xmax,ymax,maxIter,i_plotBoard)\n\n---------------------------\nRound 0 nr. sick 3\n---------------------------\nRound 1 nr. sick 5\n---------------------------\nRound 2 nr. sick 8\n---------------------------\nRound 3 nr. sick 10\n---------------------------\nRound 4 nr. sick 13\n---------------------------\nRound 5 nr. sick 16\n---------------------------\nRound 6 nr. sick 16\n---------------------------\nRound 7 nr. sick 19\n---------------------------\nRound 8 nr. sick 19\n---------------------------\nRound 9 nr. sick 21\n---------------------------\nRound 66 nr. sick 35\n---------------------------\nRound 67 nr. sick 28\n---------------------------\nRound 68 nr. sick 24\n---------------------------\nRound 69 nr. sick 22\n\n\nFinally, the government locks everything down and nobody is allowed to move anymore. The jumpSize variable is set to zero. We suppress the graphical output for this case since nothing much happens here. The number of infected people stays roughly constant and after 14 days everybody is immune and nobody is sick anymore. The simulation tracks the number of sick people on for each day of the simulation in vector nrSickv3.\n\n# Case 3: Total Isolation\nnp.random.seed(mySeedNumber)\ni_plotBoard = 0\njumpSize = 0  # How far they travel (interaction radius)\nnrSick3v = f_simulateCase(nrPeople,jumpSize,xmax,ymax,maxIter,i_plotBoard)\n\n---------------------------\nRound 0 nr. sick 2\n---------------------------\nRound 1 nr. sick 2\n---------------------------\nRound 2 nr. sick 2\n---------------------------\nRound 3 nr. sick 2\n---------------------------\nRound 4 nr. sick 2\n---------------------------\nRound 5 nr. sick 2\n---------------------------\nRound 6 nr. sick 2\n---------------------------\nRound 7 nr. sick 2\n---------------------------\nRound 8 nr. sick 2\n---------------------------\nRound 9 nr. sick 2\n---------------------------\nRound 66 nr. sick 0\n---------------------------\nRound 67 nr. sick 0\n---------------------------\nRound 68 nr. sick 0\n---------------------------\nRound 69 nr. sick 0\n\n\nWe now generate a plot of all three cases over time where we plot the total number of infected people on each day.\n\n#%% Plot Barchard of Nr. of Sick People\nfig, ax = plt.subplots()\nax.bar(1. + np.arange(maxIter), nrSick1v, color = 'red', alpha=0.5)\nax.bar(1. + np.arange(maxIter), nrSick2v, color = 'blue', alpha=0.5)\nax.bar(1. + np.arange(maxIter), nrSick3v, color = 'green', alpha=0.7)\nax.set_title('Nr. of Sick over Time')\nplt.legend(['No Distancing', 'Some Distancing', 'Total Isolation'])\nplt.show()\n\nprint(\" \")\nprint(\"Time (sec)\",(time.perf_counter() - tic))\n\n\n\n\n\n\n\n\n \nTime (sec) 4.0811791541054845\n\n\nWithout any distancing the virus spreads very quickly and leads to the highest number if infections per day which can easily overwhelm any healthcare system.\nWith some distancing the peak is much lower but more spread out. While in this case the whole pandemic lasts longer, the total number of infected people on any given day is smaller and might be more manageable for a healthcare system.\nFinally, we can clearly see that with total isolation the infection rate is very low and the virus dies out after about two weeks. Keep in mind, in this scenario nobody is leaving their house for two weeks at all.",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Random Numbers II: An Infectious Disease Simulation</span>"
    ]
  },
  {
    "objectID": "Random2.html#s.i.r.-model---a-more-complete-model-of-infectious-disease",
    "href": "Random2.html#s.i.r.-model---a-more-complete-model-of-infectious-disease",
    "title": "18  Random Numbers II: An Infectious Disease Simulation",
    "section": "18.4 S.I.R. Model - A More Complete Model of Infectious Disease",
    "text": "18.4 S.I.R. Model - A More Complete Model of Infectious Disease\nWe next build on the previous section and introduce a more complete model. This model is referred to as SIR model as it track the number of\n\n\nSusceptible individuals, the number of\nInfected (and therefore infectious) individuals, and the number of\nRecovered individuals\n\n\nin a dynamic framework. In addition, I also introduce a death probability that is experienced by the infected population only. In this model only the infected can die.\nHere are the codes. We again start with a class definition and change some of the wording. Individuals can be infected, recovered, or dead. If they are not any of these, they are currently healthy and susceptible to be infected. We therefore add new attributes to the person class.\nThe method movePerson() is unchanged. The method updateHealth() includes a deathProbability variable which is the probability that an infected person dies as well as a recoveryTime variable which is the time (in the simulation it is the number of simulation iterations) it takes for an infectious person to recover from the infection.\n\nimport time\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n#%% Class Definition\nclass person(object):\n    def __init__(self, id=0, xmax=100, ymax=100):\n        self.id = id\n        self.infected = int((np.random.random()&lt;0.01))\n        self.recovered = False\n        self.dead = False\n        self.xpos = np.random.randint(1,xmax,1)[0]\n        self.ypos = np.random.randint(1,ymax,1)[0]\n        self.age = np.random.randint(1,90,1)[0]\n        return\n    #end\n\n    def movePerson(self, jumpSize):\n        # Generate a random integer number [1,2,...,8]\n        pos = np.random.randint(1,9,1)[0]\n        if pos == 1:\n            self.ypos += jumpSize\n        elif pos == 2:\n            self.ypos+= jumpSize\n            self.xpos+= jumpSize\n        elif pos == 3:\n            self.xpos += jumpSize\n        elif pos == 4:\n            self.xpos += jumpSize\n            self.ypos -= jumpSize\n        elif pos == 5:\n            self.ypos -= jumpSize\n        elif pos == 6:\n            self.xpos -= jumpSize\n            self.ypos -= jumpSize\n        elif pos == 7:\n            self.xpos -= jumpSize\n        else:\n            self.xpos -= jumpSize\n            self.ypos += jumpSize\n\n        # Check boundaries\n        if self.xpos &lt; 0:\n            self.xpos = xmax\n        if self.xpos &gt; xmax:\n            self.xpos =0\n\n        if self.ypos &lt; 0:\n            self.ypos = ymax\n        if self.ypos &gt; ymax:\n            self.ypos = 0\n\n        return np.empty(1, np.float64)\n    #end\n\n    def updateHealth(self, boardXY, xmax, ymin, deathProbability, recoveryTime):\n        # Neighborhood\n        neighxv = np.array([self.xpos, self.xpos+1, self.xpos+1, \\\n                           self.xpos+1, self.xpos, self.xpos-1, \\\n                           self.xpos-1, self.xpos-1])\n        neighyv = np.array([self.ypos+1, self.ypos+1, self.ypos, \\\n                           self.ypos-1, self.ypos-1, self.ypos-1, \\\n                           self.ypos, self.ypos+1])\n\n        neighxv[neighxv &gt; xmax] = xmax\n        neighxv[neighxv &lt; 0] = 0\n        neighyv[neighyv &gt; ymax] = ymax\n        neighyv[neighyv &lt; 0] = 0\n\n        neighv = np.zeros(8)\n        for i,(x,y) in enumerate(zip(neighxv,neighyv)):\n            neighv[i] = boardXY[x,y]\n        #end\n\n        if self.infected &gt; 0:\n            # Calculate whether infected person dies\n            if (np.random.random() &lt; deathProbability):\n                # Dead\n                self.dead = True\n                self.infected = 0\n            else:\n                # Still alive, we count nr. of days infected in this variable\n                self.infected += 1\n            #end\n        #end\n\n        if ( (self.infected &gt; recoveryTime) and (self.dead == False) ):\n            self.infected = 0 # recovered and now immune --&gt; recovered status\n            self.recovered = True\n        #end\n\n        # If you bump into a infected field, make guy infected\n        if ((self.infected == 0) and (np.sum(neighv) &gt; 0) \\\n            and (self.recovered == False) and (self.dead == False)):\n            self.infected = 1 # newly infected\n        #end\n\n        return\n    #end\n\n#end\n\nWe next need to change the f_update() function so that it accounts for all four possible person types: susceptible, infectious, recovered, or diseased.\n\n#%% Functions\ndef f_update(nrPeople, persList, boardXYin, xmax, ymax, deathProbability, recoveryTime):\n\n    for person in persList:\n        person.movePerson(jumpSize)\n        person.updateHealth(boardXYin, xmax, ymax, deathProbability, recoveryTime)\n    #end\n\n    # Make new board and mark all the sick fields and count SIR cases\n    boardXY = np.zeros([xmax+1, ymax+1])\n    nrInfected = 0\n    nrDead = 0\n    nrRecovered = 0\n    for person in persList:\n        if person.infected &gt; 0:\n            nrInfected += 1\n            boardXY[person.xpos, person.ypos] = 1\n        #end\n        if person.dead == True:\n            nrDead += 1\n        #end\n        if person.recovered == True:\n            nrRecovered += 1\n        #end\n    #end\n\n    nrSusceptible = nrPeople - nrInfected - nrRecovered - nrDead\n\n    return nrSusceptible, nrInfected, nrRecovered, nrDead, boardXY\n#end\n\nSimilar changes need to be made for the plot function. Each person type is attributed to a color: * Susceptible individuals are blue * Infectious individuals are red * Recovered individuals are green, and * Dead individuals are black.\n\ndef f_plotPeople(persList):\n    fig = plt.figure()\n    ax = plt.subplot(111, aspect='equal')\n    ax.set_title('Susceptible/Infected/Recovered/Dead Population')\n\n    xposSusceptiblev = np.array([],dtype=int)\n    yposSusceptiblev = np.array([],dtype=int)\n\n    xposInfectedv = np.array([],dtype=int)\n    yposInfectedv = np.array([],dtype=int)\n\n    xposRecoveredv = np.array([],dtype=int)\n    yposRecoveredv = np.array([],dtype=int)\n\n    xposDeadv = np.array([],dtype=int)\n    yposDeadv = np.array([],dtype=int)\n\n    for person in persList:\n        if person.infected &gt; 0:\n            xposInfectedv = np.append(xposInfectedv, person.xpos)\n            yposInfectedv = np.append(yposInfectedv, person.ypos)\n        elif person.recovered == True:\n            xposRecoveredv = np.append(xposRecoveredv, person.xpos)\n            yposRecoveredv = np.append(yposRecoveredv, person.ypos)\n        elif person.dead == True:\n            xposDeadv = np.append(xposDeadv, person.xpos)\n            yposDeadv = np.append(yposDeadv, person.ypos)\n        else:\n            # Susceptible\n            xposSusceptiblev = np.append(xposSusceptiblev, person.xpos)\n            yposSusceptiblev = np.append(yposSusceptiblev, person.ypos)\n        #end\n    #end\n\n    ax.plot(xposSusceptiblev, yposSusceptiblev, marker='s', linestyle = 'None', \\\n            color = 'blue', markersize=5, alpha=0.6)\n    ax.plot(xposInfectedv, yposInfectedv, marker='s', linestyle = 'None', \\\n            color = 'red', markersize=5, alpha=0.6)\n    ax.plot(xposRecoveredv, yposRecoveredv, marker='s', linestyle = 'None', \\\n            color = 'green', markersize=5, alpha=0.6)\n    ax.plot(xposDeadv, yposDeadv, marker='s', linestyle = 'None', \\\n            color = 'black', markersize=5, alpha=0.6)\n    plt.legend(['Susceptible', 'Infected', 'Recovered', 'Dead'], loc = 1)\n    plt.show()\n    return\n#end\n\nThe simulation function is also updated so reflect the four person types that are now possible. We suppress some of the output to not clutter the screen.\n\ndef f_simCase(nrPeople,jumpSize,xmax,ymax,maxIter,i_plotBoard, deathProbability, recoveryTime):\n    persList = []\n\n    boardXY = np.zeros([xmax+1, ymax+1])\n    # Tracking SIR model\n    nrSusceptiblev = np.zeros(maxIter, dtype=int)\n    nrInfectedv = np.zeros(maxIter, dtype=int)\n    nrRecoveredv = np.zeros(maxIter, dtype=int)\n    nrDeadv = np.zeros(maxIter, dtype=int)\n\n    # Make person list\n    for i in range(nrPeople):\n        # Make person\n        person_i = person(id = i, xmax=xmax, ymax=ymax)\n        # If person is infected update board\n        if person_i.infected == True:\n            boardXY[person_i.xpos, person_i.ypos] = 1\n        #end\n        # Store person in list\n        persList.append(person_i)\n    #end\n\n    for i_loop in range(maxIter):\n        nrSusceptiblev[i_loop], nrInfectedv[i_loop], nrRecoveredv[i_loop], nrDeadv[i_loop], boardXY = \\\n            f_update(nrPeople, persList, boardXY, xmax, ymax, deathProbability, recoveryTime)\n\n        if i_loop &lt;3 or i_loop&gt;(maxIter-3):\n            print('---------------------------')\n            print('Round {} nr. Susceptible {}'.format(i_loop, nrSusceptiblev[i_loop]))\n            print('Round {} nr. Infected    {}'.format(i_loop, nrInfectedv[i_loop]))\n            print('Round {} nr. Recovered   {}'.format(i_loop, nrDeadv[i_loop]))\n            print('Round {} nr. dead        {}'.format(i_loop, nrDeadv[i_loop]))\n\n\n        if ((i_loop%5 == 0) and (i_plotBoard == 1)):\n            f_plotPeople(persList)\n        #end\n    #end\n\n    return nrSusceptiblev, nrInfectedv, nrRecoveredv, nrDeadv\n#end\n\nWe finally introduce a new plot function that tracks all for types over time.\n\n#%% Plot Time Series of all different types\ndef f_plotTimeSeries(nrSusceptiblev, nrInfectedv, nrRecoveredv, nrDeadv):\n    fig, ax = plt.subplots()\n    ax.plot(1. + np.arange(maxIter), nrSusceptiblev, color = 'blue')\n    ax.plot(1. + np.arange(maxIter), nrInfectedv, color = 'red')\n    ax.plot(1. + np.arange(maxIter), nrRecoveredv, color = 'green')\n    ax.plot(1. + np.arange(maxIter), nrDeadv, color = 'black')\n    ax.set_title('Nr. Susceptible, Infected, Recovered, and Dead over Time')\n    plt.legend(['Susceptible', 'Infected', 'Recovered', 'Dead'])\n    plt.minorticks_on()\n    # Customize the major grid\n    ax.grid(which='major', linestyle='-', linewidth='0.5', color='Black')\n    # Customize the minor grid\n    ax.grid(which='minor', linestyle=':', linewidth='0.5', color='black')\n    plt.show()\n#end\n\nWe are now ready to start the simulation. We again define the core parameters of the model. The two new parameters are deathProbability and recoveryTime.\n\n# Maximum days to simulate\nmaxIter = 70\n\n# Size of their world\nxmax = 40\nymax = 40\n\n# People\nnrPeople = 200\n\n# Death probability when infected\ndeathProbability = 0.02\n\n# Recovery time from infection\nrecoveryTime = 14\n\nWe now run the first case where we assume that the government does nothing and everybody in the economy (or simulation) is free to move 2 steps in any direction.\n\n\n\n\n\n\nNote\n\n\n\nWe again set the random seed in all three simulations so that differences in the outcomes are driven by policy changes and not differences in the way that random numbers are generated.\n\n\n\n# Case 1: Move a lot (no restrictions)\nnp.random.seed(mySeedNumber)\ni_plotBoard = 1\njumpSize = 2  # How far they travel (interaction radius)\nnrSusceptible1v, nrInfected1v, nrRecovered1v, nrDead1v \\\n    = f_simCase(nrPeople,jumpSize,xmax,ymax,maxIter,i_plotBoard, deathProbability, recoveryTime)\n\n---------------------------\nRound 0 nr. Susceptible 197\nRound 0 nr. Infected    3\nRound 0 nr. Recovered   0\nRound 0 nr. dead        0\n\n\n\n\n\n\n\n\n\n---------------------------\nRound 1 nr. Susceptible 193\nRound 1 nr. Infected    7\nRound 1 nr. Recovered   0\nRound 1 nr. dead        0\n---------------------------\nRound 2 nr. Susceptible 190\nRound 2 nr. Infected    10\nRound 2 nr. Recovered   0\nRound 2 nr. dead        0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n---------------------------\nRound 68 nr. Susceptible 0\nRound 68 nr. Infected    0\nRound 68 nr. Recovered   54\nRound 68 nr. dead        54\n---------------------------\nRound 69 nr. Susceptible 0\nRound 69 nr. Infected    0\nRound 69 nr. Recovered   54\nRound 69 nr. dead        54\n\n\nAfter running the simulation we can plot the four types over time using the new plot function f_plotTimeSeries.\n\nf_plotTimeSeries(nrSusceptible1v, nrInfected1v, nrRecovered1v, nrDead1v)\n\n\n\n\n\n\n\n\nWe next run the other two cases with some government intervention in Case 2 and with full government intervention in Case 3 where nobody is allowed to move anymore. We again plot the time series for each case.\n\n# Case 2: Some distancing\nnp.random.seed(mySeedNumber)\ni_plotBoard = 0\njumpSize = 1  # How far they travel (interaction radius)\nnrSusceptible2v, nrInfected2v, nrRecovered2v, nrDead2v \\\n    = f_simCase(nrPeople,jumpSize,xmax,ymax,maxIter,i_plotBoard, deathProbability, recoveryTime)\nf_plotTimeSeries(nrSusceptible2v, nrInfected2v, nrRecovered2v, nrDead2v)\n\n# Case 3: Total Isolation\nnp.random.seed(mySeedNumber)\ni_plotBoard = 0\njumpSize = 0  # How far they travel (interaction radius)\nnrSusceptible3v, nrInfected3v, nrRecovered3v, nrDead3v \\\n    = f_simCase(nrPeople,jumpSize,xmax,ymax,maxIter,i_plotBoard, deathProbability, recoveryTime)\nf_plotTimeSeries(nrSusceptible3v, nrInfected3v, nrRecovered3v, nrDead3v)\n\n---------------------------\nRound 0 nr. Susceptible 197\nRound 0 nr. Infected    3\nRound 0 nr. Recovered   0\nRound 0 nr. dead        0\n---------------------------\nRound 1 nr. Susceptible 195\nRound 1 nr. Infected    5\nRound 1 nr. Recovered   0\nRound 1 nr. dead        0\n---------------------------\nRound 2 nr. Susceptible 194\nRound 2 nr. Infected    6\nRound 2 nr. Recovered   0\nRound 2 nr. dead        0\n---------------------------\nRound 68 nr. Susceptible 64\nRound 68 nr. Infected    25\nRound 68 nr. Recovered   23\nRound 68 nr. dead        23\n---------------------------\nRound 69 nr. Susceptible 63\nRound 69 nr. Infected    23\nRound 69 nr. Recovered   24\nRound 69 nr. dead        24\n\n\n\n\n\n\n\n\n\n---------------------------\nRound 0 nr. Susceptible 198\nRound 0 nr. Infected    2\nRound 0 nr. Recovered   0\nRound 0 nr. dead        0\n---------------------------\nRound 1 nr. Susceptible 198\nRound 1 nr. Infected    2\nRound 1 nr. Recovered   0\nRound 1 nr. dead        0\n---------------------------\nRound 2 nr. Susceptible 198\nRound 2 nr. Infected    2\nRound 2 nr. Recovered   0\nRound 2 nr. dead        0\n---------------------------\nRound 68 nr. Susceptible 198\nRound 68 nr. Infected    0\nRound 68 nr. Recovered   0\nRound 68 nr. dead        0\n---------------------------\nRound 69 nr. Susceptible 198\nRound 69 nr. Infected    0\nRound 69 nr. Recovered   0\nRound 69 nr. dead        0\n\n\n\n\n\n\n\n\n\nWe finally compare across the three cases and plot the number of infected people for all three cases superimposed into the same graph.\n\n#%% Plot Bar chart of Nr. of Infected People of the 3 Cases\nfig, ax = plt.subplots()\nax.bar(1. + np.arange(maxIter), nrInfected1v, color = 'red', alpha=0.5)\nax.bar(1. + np.arange(maxIter), nrInfected2v, color = 'blue', alpha=0.5)\nax.bar(1. + np.arange(maxIter), nrInfected3v, color = 'green', alpha=0.8)\nax.set_title('Nr. of Infected over Time')\nplt.legend(['No Distancing', 'Some Distancing', 'Total Isolation'])\nplt.show()\n\n\n\n\n\n\n\n\nFrom this graph we again see, as before, that government intervention helps keeping the number of infected people lower.\nIn our final graph we compare the number of diseased people across the three cases.\n\n#%% Plot Time Series of Nr. of Dead People Across the 3 Cases\nfig, ax = plt.subplots()\nax.plot(1. + np.arange(maxIter), nrDead1v, color = 'red')\nax.plot(1. + np.arange(maxIter), nrDead2v, color = 'blue')\nax.plot(1. + np.arange(maxIter), nrDead3v, color = 'green')\nax.set_title('Nr. of Dead over Time')\nplt.legend(['No Distancing', 'Some Distancing', 'Total Isolation'])\nplt.show()\n\n\n\n\n\n\n\n\nFrom this graph it is pretty clear that without government intervention the death count is very large, even with a \"small\" death probability of 2 percent.\nSome government intervention would mitigate the death count dramatically.\nNot surprisingly, full government intervention, where the government mandates that everybody has to stay home from day one of the disease would keep the death count the lowest.",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Random Numbers II: An Infectious Disease Simulation</span>"
    ]
  },
  {
    "objectID": "Random2.html#key-concepts-and-summary",
    "href": "Random2.html#key-concepts-and-summary",
    "title": "18  Random Numbers II: An Infectious Disease Simulation",
    "section": "18.5 Key Concepts and Summary",
    "text": "18.5 Key Concepts and Summary\n\n\n\n\n\n\nNote\n\n\n\n\nDrawing random numbers\nWriting a simple simulation",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Random Numbers II: An Infectious Disease Simulation</span>"
    ]
  },
  {
    "objectID": "Random2.html#self-check-questions",
    "href": "Random2.html#self-check-questions",
    "title": "18  Random Numbers II: An Infectious Disease Simulation",
    "section": "18.6 Self-Check Questions",
    "text": "18.6 Self-Check Questions\n\n\n\n\n\n\ntodo\n\n\n\n\nChange the simulation to include more people\nChange the simulation to allow for age dependent death probabilities\nChange the simulation to allow for age dependent infection probabilities. Currently, if a healthy (susceptible) person bumps into an infectious one, she will contract with 100 percent probability. It is more realistic that this happens with a certain probability and it might also depend on one's age.",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Random Numbers II: An Infectious Disease Simulation</span>"
    ]
  },
  {
    "objectID": "Root.html",
    "href": "Root.html",
    "title": "\n19  Root Finding\n",
    "section": "",
    "text": "19.1 First Steps\nimport numpy as np\nimport matplotlib.pyplot as plt\n#\nimport time  # Imports system time module to time your script\n#\nplt.close('all')  # close all open figures\nDefine am example function for which we calculate the root. Let us use this function:\n\\[f(x) = ln(x) - e^{-x}\\]\nWe first program this function using the def keyword in Python. Do not forget to also load the numpy library first.\nWe next plot the function.\nAnd finally we plot the results.\nWe clearly see that the \"root\" of the function is somewhere near an x of 1.25 to 1.35.",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Root Finding</span>"
    ]
  },
  {
    "objectID": "Root.html#first-steps",
    "href": "Root.html#first-steps",
    "title": "\n19  Root Finding\n",
    "section": "",
    "text": "Python Code\nR Code\n\n\n\n\ndef f_func(x):\n    # Function: f(x)\n    fx = np.log(x) - np.exp(-x)\n    return fx\n\n\n\n\nf_func &lt;- function(x) {\n    # Function: f(x)\n    fx &lt;- log(x) - exp(-x)\n    return(fx)\n}\n\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nxmin = 1\nxmax = 3\nxv  = np.arange(xmin, xmax, (xmax - xmin)/200.0)\nfxv = np.zeros(len(xv),float) # define column vector\nfor i in range(len(xv)):\n    fxv[i] = f_func(xv[i])\n\n\n\n\n# Define the range and step size\nxmin &lt;- 1\nxmax &lt;- 3\nstep &lt;- (xmax - xmin) / 200\n\n# Generate the vector of x values\nxv &lt;- seq(xmin, xmax, by = step)\n\n# Define a function to compute f(x)\nf_func &lt;- function(x) {\n  return(log(x) - exp(-x))\n}\n\n# Compute the vector of f(x) values using the function\nfxv &lt;- sapply(xv, f_func)\n\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nfig, ax = plt.subplots()\nax.plot(xv, fxv)\nax.plot(xv, np.zeros(len(xv)))\n# Create a title with a red, bold/italic font\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# Create a plot\nplot(xv, fxv, type = \"l\", col = \"blue\", lwd = 2, xlab = \"x\", ylab = \"f(x)\", main = \"Plot of f(x)\")\n\n# Add a horizontal line at y = 0\nabline(h = 0, col = \"red\", lty = 2)",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Root Finding</span>"
    ]
  },
  {
    "objectID": "Root.html#newton-raphson",
    "href": "Root.html#newton-raphson",
    "title": "\n19  Root Finding\n",
    "section": "\n19.2 Newton-Raphson",
    "text": "19.2 Newton-Raphson\nFigure 19.1 presents an illustration of the Newton-Raphson algorithm.\n\n\n\n\n\nFigure 19.1: The Newton-Raphson Algorithm\n\n\nWe start with an initial guess \\(x_0\\). The slope of the tangent line through the initial guess can be defined as rise \\(f(x_0) - 0\\) over run \\(x_0-x_1\\) or:\n\\[slope=\\frac{f(x_0)-0}{x_0-x_1},\\]\nwhere \\(x_1\\) is the point where the tangent line crosses the x-axis. This point has coordinates \\(x_1\\) and \\(y_1 = 0\\). Our goal is to find the value of \\(x_1\\).\nSince this line is a tangent line, we can also write its slope as the derivative of function \\(f\\) that is: \\(f'(x)\\). We now set the derivative equal to the expression for the slope:\n\n\\[f'(x_0) = slope = \\frac{f(x_0)-0}{x_0-x_1},\\]\n\nwhich we can now use to solve for the value of \\(x_1\\):\n\\[x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)}.\\]\nWe next put a tangent line through the value of \\(f(x_1)\\) and search where this tangent line crosses the x-axis at point \\(x_2\\) in Figure 19.1. This results in\n\n\\[f'(x_1) = slope = \\frac{f(x_1)-0}{x_1-x_2},\\]\n\nwhich we can now use to solve for the value of \\(x_2\\):\n\\[x_2 = x_1 - \\frac{f(x_1)}{f'(x_1)}.\\]\n\n\n\n\n\n\nNote\n\n\n\nWe can now repeat this successively using the iterative procedure:\n\\[\\boxed{x_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}}\\]\n\n\nIn order for this function to work well we need to be able to calculate the derivative of the function around the root point and preferably over the entire domain of the function.\nIn the following code we \"hand in\" a function ftn which is a user specified function. This function needs to return 2! values: 1. the functional value \\(f(x)\\), and 2. the value of the first derivative \\(f'(x)\\).\n\n\nPython Code\nR Code\n\n\n\n\ndef newtonraphson(ftn, x0, tol = 1e-9, maxiter = 100):\n    # Newton_Raphson algorithm for solving ftn(x)[1] == 0\n    # we assume that ftn is a function of a single\n    # variable that returns the function value and\n    # the first derivative as a vector of length 2\n    #\n    # x0 is the initial guess at the root\n    # the algorithm terminates when the function\n    # value is within distance tol of 0, or the\n    # number of iterations exceeds maxiter\n\n    x = x0\n\n    # Evaluate user supplied function at starting value\n    fxv = ftn(x)\n    fx = fxv[0]   # function value f(x)\n    d_fx = fxv[1]  # derivative value f'(x)\n\n    jiter =  0\n\n    # Continue iterating until stopping conditions are met\n    while ((abs(fx) &gt; tol) and (jiter &lt; maxiter)):\n\n        # Newton-Raphson iterative formula\n        x = x - fx/d_fx\n\n        # Update function and derivative value\n        fxv = ftn(x)\n        fx = fxv[0]   # new function value f(x)\n        d_fx = fxv[1]  # new derivative value f'(x)\n\n        jiter =  jiter + 1\n        print(\"At iteration: {} the value of x is {}:\" \\\n          .format(jiter, x))\n\n    # Output depends on success of algorithm\n    if (abs(fx) &gt; tol):\n        print(\"Algorithm failed to converge\")\n        return None\n    else:\n        print(\"fx = \", fx)\n        print(\"Algorithm converged\")\n        return x\n\n\n\n\nnewtonraphson &lt;- function(ftn, x0, tol = 1e-9, maxiter = 100) {\n  # Newton-Raphson algorithm for solving ftn(x)[1] == 0\n  # We assume that ftn is a function of a single variable\n  # that returns the function value and the first derivative\n  # as a vector of length 2.\n  #\n  # x0 is the initial guess at the root.\n  # The algorithm terminates when the function value is within\n  # a distance tol of 0, or the number of iterations exceeds maxiter.\n\n  x &lt;- x0\n\n  # Evaluate user-supplied function at the starting value\n  fxv &lt;- ftn(x)\n  fx &lt;- fxv[1]  # function value f(x)\n  d_fx &lt;- fxv[2]  # derivative value f'(x)\n\n  jiter &lt;- 0\n\n  # Continue iterating until stopping conditions are met\n  while ((abs(fx) &gt; tol) && (jiter &lt; maxiter)) {\n\n    # Newton-Raphson iterative formula\n    x &lt;- x - fx / d_fx\n\n    # Update function and derivative values\n    fxv &lt;- ftn(x)\n    fx &lt;- fxv[1]  # new function value f(x)\n    d_fx &lt;- fxv[2]  # new derivative value f'(x)\n\n    jiter &lt;- jiter + 1\n    cat(\"At iteration:\", jiter, \"the value of x is:\", x, \"\\n\")\n  }\n\n  # Output depends on the success of the algorithm\n  if (abs(fx) &gt; tol) {\n    cat(\"Algorithm failed to converge\\n\")\n    return(NULL)\n  } else {\n    cat(\"fx =\", fx, \"\\n\")\n    cat(\"Algorithm converged\\n\")\n    return(x)\n  }\n}\n\n\n\n\nIn order to implement this method we will need the derivative value of the function. Calculus to the rescue. Let us take the derivative of our function. Here is the function:\n\\[f(x) = ln(x) - e^{-x}\\]\nAnd here is its derivative. Check your calculus books if you forgot how to do this!\n\\[f'(x) = \\frac{1}{x} - e^{-x} \\times (-1),\\]\nwhich can be written as\n\\[f'(x) = \\frac{1}{x} + e^{-x}\\]\nSo let us define our example function from the beginning of the chapter again but this time we return both, the functional value and the value of the first derivate (i.e., the gradient).\n\n\nPython Code\nR Code\n\n\n\n\ndef f_func1(x):\n    # Function: f(x)\n    fx = np.log(x) - np.exp(-x)\n\n    # Derivative of function: f'(x)\n    d_fx = 1.0/x + np.exp(-x)\n\n    return np.array([fx, d_fx])\n\n\n\n\nf_func1 &lt;- function(x) {\n  # Function: f(x)\n  fx &lt;- log(x) - exp(-x)\n\n  # Derivative of function: f'(x)\n  d_fx &lt;- 1.0 / x + exp(-x)\n\n  return(c(fx, d_fx))\n}\n\n\n\n\nWe next calculate the root of the function func1 calling the newtonraphson algorithm.\n\n\nPython Code\nR Code\n\n\n\n\nmyRoot = newtonraphson(f_func1, 2.0)\n\nprint('--------------------------------')\nprint('My Root is at {:8.4f}'.format(myRoot))\nprint('--------------------------------')\n\nAt iteration: 1 the value of x is 1.122019645309717:\nAt iteration: 2 the value of x is 1.2949969704390394:\nAt iteration: 3 the value of x is 1.3097090626648604:\nAt iteration: 4 the value of x is 1.309799582422906:\nAt iteration: 5 the value of x is 1.3097995858041505:\nfx =  -5.551115123125783e-17\nAlgorithm converged\n--------------------------------\nMy Root is at   1.3098\n--------------------------------\n\n\n\n\n\n# Find the root using the newtonraphson function\nmyRoot &lt;- newtonraphson(f_func1, 2.0)\n\ncat(\"--------------------------------\\n\")\ncat(\"My Root is at:\", myRoot, \"\\n\")\ncat(\"--------------------------------\\n\")\n\nAt iteration: 1 the value of x is: 1.12202 \nAt iteration: 2 the value of x is: 1.294997 \nAt iteration: 3 the value of x is: 1.309709 \nAt iteration: 4 the value of x is: 1.3098 \nAt iteration: 5 the value of x is: 1.3098 \nfx = -5.551115e-17 \nAlgorithm converged\n--------------------------------\nMy Root is at: 1.3098 \n--------------------------------\n\n\n\n\n\nWe can now plot the function again. Using axvline we can mark the root of the function in the graph.\n\n\nPython Code\nR Code\n\n\n\n\nfig, ax = plt.subplots()\nax.plot(xv, fxv)\nax.plot(xv, np.zeros(len(xv)), 'k', linewidth = 1)\nax.axvline(x = myRoot, ymin=-0.3, ymax=0.8, color='r', linestyle='--')\n# Create a title with a red, bold/italic font\nplt.show()\n\n\n\n\n\n\n\n\n\n\nplot(xv, fxv, type = \"l\", col = \"blue\", xlab = \"x\", ylab = \"f(x)\", lwd = 2)\n\n# Add a horizontal black line at y=0\nabline(h = 0, col = \"black\", lwd = 1)\n\n# Add a vertical dashed red line at myRoot\nabline(v = myRoot, col = \"red\", lwd = 2, lty = 2)\n\n# Add a legend\nlegend(\"topright\", legend = c(\"f(x)\", \"y = 0\", paste(\"Root =\", round(myRoot, 4))),\n       col = c(\"blue\", \"black\", \"red\"), lwd = c(2, 1, 2), lty = c(1, 1, 2))\n\n# Add a title\ntitle(\"Plot of f(x) with Root Location\")\n\n\n\n\n\n\n# Show the plot\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThe Newton-Raphson algorithm has two shortcomings:\n\nIt requires that the function is differentiable. For non-differential functions (i.e., functions with \"kinks\" or steps) this algorithm will not work.\nIt is sensitive to starting values. If a bad starting value is chosen and if the function exhibits \"flat\" spots, the algorithm will not converge.\n\n\n\nFigure 19.2 presents an illustration of the Newton-Raphson algorithm when the starting value is chosen far from the root point in the \"flat\" area of the function. In this case the tangent line crosses the z-axis at a very distant point from the root we are looking for and might not converge or only converge very slowly.\n\n\n\n\n\nFigure 19.2: The Newton-Raphson Algorithm with Bad Starting Value",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Root Finding</span>"
    ]
  },
  {
    "objectID": "Root.html#secant-method",
    "href": "Root.html#secant-method",
    "title": "\n19  Root Finding\n",
    "section": "\n19.3 Secant Method",
    "text": "19.3 Secant Method\nAs pointed out above, in order to use the Newton-Raphson method we need to be able to calculate the derivative \\(f'(x)\\) of the function. If this is computationally expensive or maybe even impossible, we can use the secant method which only requires that the function is continuous. That is, it does not have to be differentiable over its domain.\nIn this case we start with two starting values or initial guesses, \\(x_0\\) and \\(x_1\\) and put a line through the functional values \\(f(x_0)\\) and \\(f(x_1)\\). The advantage of this method is that we do not have to calculate the first derivative of the function.\nFigure 19.3 presents an illustration of the Secant method. The green line is formed using the functional values of the two starting guesses ,\\(x_0\\) and \\(x_1\\). The closer the two starting values are to each other the more the green secant (line) will resemble the tangent line in Figure 19.1 that was used in the Newton-Raphson algorithm above.\n\n\n\n\n\nFigure 19.3: The Secant Algorithm\n\n\nThe algorithm then proceeds in finding point \\(x_2\\) where the green secant crosses the x-axis. The slope of the secant line can be calculated in two ways using the rise-over-run method. We can first express the slope as:\n\\[\\text{slope} = \\frac{f(x_0)-f(x_1)}{x_0-x_1}\\]\nAnd similarly we can use a second triangle (rise over run) and express the slope as:\n\\[\\text{slope} = \\frac{f(x_1)- 0}{x_1-x_2}\\]\nWe can now set the two expressions equal to each other\n\\[\\frac{f(x_0)-f(x_1)}{x_0-x_1} = \\text{slope} = \\frac{f(x_1)- 0}{x_1-x_2}\\]\nand since we have \\(x_0,x_1,f(x_0),\\) and \\(f(x_1)\\) we can solve for \\(x_2\\).\n\\[x_2 = x_1 - f(x_1)\\frac{x_0-x_1}{f(x_0)-f(x_1)}.\\]\nThe iterative procedure can be written as:\n\\[\\boxed{x_{n+1} = x_n - f(x_n)\\frac{x_{n-1}-x_n}{f(x_{n-1})-f(x_n)}}\\]\n\n\n\n\n\n\nNote\n\n\n\nKeep in mind that if \\(x_0\\) and \\(x_1\\) are close together then:\n\\[f'(x_n) \\approx \\frac{f(x_n)-f(x_{n-1})}{x_n-x_{n-1}}.\\]\n\n\nSo that the Secant method is really an approximation of the Newton-Raphson method, where we substitute \\(\\frac{f(x_n)-f(x_{n-1})}{x_n-x_{n-1}}\\) for \\(f'(x)\\).\nIn this sense we can also write the iterative procedure of the Secant method as:\n\\[\\boxed{x_{n+1} = x_n - \\frac{f(x_n)}{\\frac{f(x_{n-1})-f(x_n)}{x_{n-1}-x_n}}}\\]\n\n\nPython Code\nR Code\n\n\n\n\ndef secant(ftn, x0, x1, tol = 1e-9, maxiter = 100):\n    # Secant algorithm for solving ftn(x) == 0\n    # we assume that ftn is a function of a\n    # single variable that returns the function value\n    #\n    # x0 and x1 are the initial guesses around the root\n    # the algorithm terminates when the function\n    # value is within distance\n    # tol of 0, or the number of iterations exceeds max.iter\n\n    fx0 = ftn(x0)\n    fx1 = ftn(x1)\n    jiter =  0\n\n    # continue iterating until stopping conditions are met\n    while ((abs(fx1) &gt; tol) and (jiter &lt; maxiter)):\n        x  = x1 - fx1 * (x1-x0)/(fx1 - fx0)\n        fx0 = ftn(x1)\n        fx1 = ftn(x)\n        x0  = x1\n        x1  = x\n        jiter =  jiter + 1\n        print(\"At iteration: {} the value of x is: {}\" \\\n          .format(jiter, x))\n\n    # output depends on success of algorithm\n    if (abs(fx1) &gt; tol):\n        print(\"Algorithm failed to converge\")\n        return None\n    else:\n       print(\"Algorithm converged\")\n       return x\n\n\n\n\nsecant &lt;- function(ftn, x0, x1, tol = 1e-9, maxiter = 100) {\n  # Secant algorithm for solving ftn(x) == 0\n  # we assume that ftn is a function of a single variable that returns the function value\n  #\n  # x0 and x1 are the initial guesses around the root\n  # the algorithm terminates when the function\n  # value is within distance\n  # tol of 0, or the number of iterations exceeds max.iter\n\n  fx0 &lt;- ftn(x0)\n  fx1 &lt;- ftn(x1)\n  jiter &lt;- 0\n\n  # continue iterating until stopping conditions are met\n  while ((abs(fx1) &gt; tol) && (jiter &lt; maxiter)) {\n    x &lt;- x1 - fx1 * (x1 - x0) / (fx1 - fx0)\n    fx0 &lt;- ftn(x1)\n    fx1 &lt;- ftn(x)\n    x0 &lt;- x1\n    x1 &lt;- x\n    jiter &lt;- jiter + 1\n    cat(\"At iteration: \", jiter, \" the value of x is: \", x, \"\\n\")\n  }\n\n  # output depends on success of algorithm\n  if (abs(fx1) &gt; tol) {\n    cat(\"Algorithm failed to converge\\n\")\n    return(NULL)\n  } else {\n    cat(\"Algorithm converged\\n\")\n    return(x)\n  }\n}\n\n\n\n\nWe next calculate the root point using the secant method:\n\n\nPython Code\nR Code\n\n\n\n\nmyRoot = secant(f_func, 1,2)\nprint('--------------------------------')\nprint('My Root is at {:8.4f}'.format(myRoot))\nprint('--------------------------------')\n\nAt iteration: 1 the value of x is: 1.3974104821696125\nAt iteration: 2 the value of x is: 1.2854761201506528\nAt iteration: 3 the value of x is: 1.310676758082541\nAt iteration: 4 the value of x is: 1.3098083980193003\nAt iteration: 5 the value of x is: 1.3097995826147546\nAt iteration: 6 the value of x is: 1.309799585804162\nAlgorithm converged\n--------------------------------\nMy Root is at   1.3098\n--------------------------------\n\n\n\n\n\nmyRoot &lt;- secant(f_func, 1, 2)\ncat('--------------------------------\\n')\ncat('My Root is at ', sprintf(\"%.4f\", myRoot), '\\n')\ncat('--------------------------------\\n')\n\nAt iteration:  1  the value of x is:  1.39741 \nAt iteration:  2  the value of x is:  1.285476 \nAt iteration:  3  the value of x is:  1.310677 \nAt iteration:  4  the value of x is:  1.309808 \nAt iteration:  5  the value of x is:  1.3098 \nAt iteration:  6  the value of x is:  1.3098 \nAlgorithm converged\n--------------------------------\nMy Root is at  1.3098 \n--------------------------------",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Root Finding</span>"
    ]
  },
  {
    "objectID": "Root.html#bisection",
    "href": "Root.html#bisection",
    "title": "\n19  Root Finding\n",
    "section": "\n19.4 Bisection",
    "text": "19.4 Bisection\nThe Newton-Raphson as well as the Secant method are not guaranteed to work. The bisection method is the most robust method, but it is slow. We start with two values \\(x_l &lt; x_r\\) which bracket the root of the function. It therefore must hold that \\(f(x_l) \\times f(x_r) &lt; 0\\). The algorithm then repeatedly brackets around the root in the following systematic way:\n\n\n\n\n\n\nNote\n\n\n\n\nif \\(x_r - x_l \\le \\epsilon\\) then stop\ncalculate midpoint: \\(x_m = (x_l+x_r)/2\\)\n\nif \\(f(x_m)==0\\) stop\nif \\(f(x_l) \\times  f(x_m) &lt; 0\\) then set \\(x_r = x_m\\) otherwise \\(x_l=x_m\\)\n\ngo back to step 1\n\n\n\nFigure 19.4 demonstrates the Bisection algorithm. In the figure we demonstrate the first case in step 4 above, where \\(f(x_l) \\times  f(x_m)\n&lt; 0\\) so that we move the right bracket inwards.\n\n\n\n\n\nFigure 19.4: The Bisection Algorithm\n\n\nHere is the algorithm of the Bisection method:\n\n\nPython Code\nR Code\n\n\n\n\ndef bisection(ftn, xl, xr, tol = 1e-9):\n    # applies the bisection algorithm to find x\n    # such that ftn(x) == 0\n    # we assume that ftn is a function of a single variable\n    #\n    # x.l and x.r must bracket the fixed point, that is\n    # x.l &lt; x.r and ftn(x.l) * ftn(x.r) &lt; 0\n    #\n    # the algorithm iteratively refines\n    # x.l and x.r and terminates when\n    # x.r - x.l &lt;= tol\n\n    # check inputs\n    if (xl &gt;= xr):\n        print(\"error: xl &gt;= xr\")\n        return None\n\n    fl = ftn(xl)\n    fr = ftn(xr)\n\n    if (fl == 0):\n        return xl\n    elif (fr == 0):\n        return xr\n    elif (fl * fr &gt; 0):\n        print(\"error: ftn(xl) * ftn(xr) &gt; 0\")\n        return None\n\n    # successively refine x.l and x.r\n    n = 0\n    while ((xr - xl) &gt; tol):\n        xm = (xl + xr)/2.0\n        fm = ftn(xm)\n        if (fm == 0):\n            return fm\n        elif (fl * fm &lt; 0):\n            xr = xm\n            fr = fm\n        else:\n            xl = xm\n            fl = fm\n        n = n + 1\n        print(\"at iteration: {} the root lies between {} and {}\" \\\n            .format(n, xl, xr))\n    # return (approximate) root\n    return (xl + xr)/2.0\n\n\n\n\nbisection &lt;- function(ftn, xl, xr, tol = 1e-9) {\n  # applies the bisection algorithm to find x\n  # such that ftn(x) == 0\n  # we assume that ftn is a function of a single variable\n  #\n  # xl and xr must bracket the fixed point, that is\n  # xl &lt; xr and ftn(xl) * ftn(xr) &lt; 0\n  #\n  # the algorithm iteratively refines\n  # xl and xr and terminates when\n  # xr - xl &lt;= tol\n\n  # check inputs\n  if (xl &gt;= xr) {\n    cat(\"error: xl &gt;= xr\\n\")\n    return(NULL)\n  }\n\n  fl &lt;- ftn(xl)\n  fr &lt;- ftn(xr)\n\n  if (fl == 0) {\n    return(xl)\n  } else if (fr == 0) {\n    return(xr)\n  } else if (fl * fr &gt; 0) {\n    cat(\"error: ftn(xl) * ftn(xr) &gt; 0\\n\")\n    return(NULL)\n  }\n\n  # successively refine xl and xr\n  n &lt;- 0\n  while ((xr - xl) &gt; tol) {\n    xm &lt;- (xl + xr) / 2.0\n    fm &lt;- ftn(xm)\n    if (fm == 0) {\n      return(fm)\n    } else if (fl * fm &lt; 0) {\n      xr &lt;- xm\n      fr &lt;- fm\n    } else {\n      xl &lt;- xm\n      fl &lt;- fm\n    }\n    n &lt;- n + 1\n    cat(\"at iteration: \", n, \" the root lies between \", xl, \" and \", xr, \"\\n\")\n  }\n  # return (approximate) root\n  return((xl + xr) / 2.0)\n}\n\n\n\n\nWe next calculate the root of the function calling 'bisection' method:\n\n\nPython Code\nR Code\n\n\n\n\nmyRoot = bisection(f_func, 1,2)\n\nprint('--------------------------------')\nprint('My Root is at {:8.4f}'.format(myRoot))\nprint('--------------------------------')\n\nat iteration: 1 the root lies between 1 and 1.5\nat iteration: 2 the root lies between 1.25 and 1.5\nat iteration: 3 the root lies between 1.25 and 1.375\nat iteration: 4 the root lies between 1.25 and 1.3125\nat iteration: 5 the root lies between 1.28125 and 1.3125\nat iteration: 6 the root lies between 1.296875 and 1.3125\nat iteration: 7 the root lies between 1.3046875 and 1.3125\nat iteration: 8 the root lies between 1.30859375 and 1.3125\nat iteration: 9 the root lies between 1.30859375 and 1.310546875\nat iteration: 10 the root lies between 1.3095703125 and 1.310546875\nat iteration: 11 the root lies between 1.3095703125 and 1.31005859375\nat iteration: 12 the root lies between 1.3095703125 and 1.309814453125\nat iteration: 13 the root lies between 1.3096923828125 and 1.309814453125\nat iteration: 14 the root lies between 1.30975341796875 and 1.309814453125\nat iteration: 15 the root lies between 1.309783935546875 and 1.309814453125\nat iteration: 16 the root lies between 1.3097991943359375 and 1.309814453125\nat iteration: 17 the root lies between 1.3097991943359375 and 1.3098068237304688\nat iteration: 18 the root lies between 1.3097991943359375 and 1.3098030090332031\nat iteration: 19 the root lies between 1.3097991943359375 and 1.3098011016845703\nat iteration: 20 the root lies between 1.3097991943359375 and 1.309800148010254\nat iteration: 21 the root lies between 1.3097991943359375 and 1.3097996711730957\nat iteration: 22 the root lies between 1.3097994327545166 and 1.3097996711730957\nat iteration: 23 the root lies between 1.3097995519638062 and 1.3097996711730957\nat iteration: 24 the root lies between 1.3097995519638062 and 1.309799611568451\nat iteration: 25 the root lies between 1.3097995817661285 and 1.309799611568451\nat iteration: 26 the root lies between 1.3097995817661285 and 1.3097995966672897\nat iteration: 27 the root lies between 1.3097995817661285 and 1.3097995892167091\nat iteration: 28 the root lies between 1.3097995854914188 and 1.3097995892167091\nat iteration: 29 the root lies between 1.3097995854914188 and 1.309799587354064\nat iteration: 30 the root lies between 1.3097995854914188 and 1.3097995864227414\n--------------------------------\nMy Root is at   1.3098\n--------------------------------\n\n\n\n\n\nmyRoot &lt;- bisection(f_func, 1, 2)\ncat('--------------------------------\\n')\ncat('My Root is at ', sprintf(\"%.4f\", myRoot), '\\n')\ncat('--------------------------------\\n')\n\nat iteration:  1  the root lies between  1  and  1.5 \nat iteration:  2  the root lies between  1.25  and  1.5 \nat iteration:  3  the root lies between  1.25  and  1.375 \nat iteration:  4  the root lies between  1.25  and  1.3125 \nat iteration:  5  the root lies between  1.28125  and  1.3125 \nat iteration:  6  the root lies between  1.296875  and  1.3125 \nat iteration:  7  the root lies between  1.304688  and  1.3125 \nat iteration:  8  the root lies between  1.308594  and  1.3125 \nat iteration:  9  the root lies between  1.308594  and  1.310547 \nat iteration:  10  the root lies between  1.30957  and  1.310547 \nat iteration:  11  the root lies between  1.30957  and  1.310059 \nat iteration:  12  the root lies between  1.30957  and  1.309814 \nat iteration:  13  the root lies between  1.309692  and  1.309814 \nat iteration:  14  the root lies between  1.309753  and  1.309814 \nat iteration:  15  the root lies between  1.309784  and  1.309814 \nat iteration:  16  the root lies between  1.309799  and  1.309814 \nat iteration:  17  the root lies between  1.309799  and  1.309807 \nat iteration:  18  the root lies between  1.309799  and  1.309803 \nat iteration:  19  the root lies between  1.309799  and  1.309801 \nat iteration:  20  the root lies between  1.309799  and  1.3098 \nat iteration:  21  the root lies between  1.309799  and  1.3098 \nat iteration:  22  the root lies between  1.309799  and  1.3098 \nat iteration:  23  the root lies between  1.3098  and  1.3098 \nat iteration:  24  the root lies between  1.3098  and  1.3098 \nat iteration:  25  the root lies between  1.3098  and  1.3098 \nat iteration:  26  the root lies between  1.3098  and  1.3098 \nat iteration:  27  the root lies between  1.3098  and  1.3098 \nat iteration:  28  the root lies between  1.3098  and  1.3098 \nat iteration:  29  the root lies between  1.3098  and  1.3098 \nat iteration:  30  the root lies between  1.3098  and  1.3098 \n--------------------------------\nMy Root is at  1.3098 \n--------------------------------\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThe bisection method will not work if the function just touches the horizontal axis. The Newton-Raphson method, however, will still work in that case.\n\n\nMore comprehensive root finding algorithms will first use some sort of bracketing algorithm to get into a neighborhood of the root point and then switch over to a Newton-Raphson type method to then quickly converge to this root point.",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Root Finding</span>"
    ]
  },
  {
    "objectID": "Root.html#using-built-in-unit-root-function",
    "href": "Root.html#using-built-in-unit-root-function",
    "title": "\n19  Root Finding\n",
    "section": "\n19.5 Using Built in Unit-Root Function",
    "text": "19.5 Using Built in Unit-Root Function\nThe built in functions are part of the scipy.optimize library. The functions work very similar to the ones that we just wrote ourselves.\nIt usually requires that we first define our function. We then hand it to the solver algorithm with a starting guess of the root position.\nThe first root finding algorithm is called root\n\n\nPython Code\nR Code\n\n\n\n\nfrom scipy.optimize import root\nguess = 2\nprint(\" \")\nprint(\" -------------- Root ------------\")\nresult = root(f_func, guess) # starting from x = 2\nmyroot = result.x  # Grab number from result dictionary\nprint(\"The root of func is at {}\".format(myroot))\n\n \n -------------- Root ------------\nThe root of func is at [1.30979959]\n\n\n\n\nYou will have to install the package rootSolve using install.packages(\"rootSolve\") before you can load the library.\n\nlibrary(rootSolve)\n\n# Initial guess\nguess &lt;- 2\n\n# Find the root\nresult &lt;- uniroot(f_func, interval = c(1, 3))\n\n# Extract the roots\nmyroots &lt;- result$root\n\ncat(\" \")\ncat(\" -------------- Root ------------\\n\")\ncat(\"The roots of func are at \", myroots, \"\\n\")\n\n  -------------- Root ------------\nThe roots of func are at  1.309803 \n\n\n\n\n\nThe second root finding algorithm is called fsolve\n\nfrom scipy.optimize import fsolve\n\nguess = 2\nprint(\" \")\nprint(\" -------------- Fsolve ------------\")\nresult = fsolve(f_func, guess) # starting from x = 2\nmyroot = result[0] # Grab number from result dictionary\nprint(\"The root is at {}\".format(result))\n\n \n -------------- Fsolve ------------\nThe root is at [1.30979959]\n\n\n\n\n\n\n\n\nKey Concepts and Summary\n\n\n\n\nRoot finding algorithms\n\nNewton-Raphson\nSecant method\nBisection method\n\n\nBuilt in root finding methods\n\n\n\n\n\n\n\n\n\nSelf-check questions\n\n\n\n\n\n\nSolve for the root of function \\[f(x) = -20+2*x^2-ln(x)\\]\n\n\n\nPlot this function\nUse bisection method to solve for the root(s) of this function\nConfirm the root with a built-in method of your choice\n\n\n\n\n\n\n\nFigure 19.1: The Newton-Raphson Algorithm\nFigure 19.2: The Newton-Raphson Algorithm with Bad Starting Value\nFigure 19.3: The Secant Algorithm\nFigure 19.4: The Bisection Algorithm",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Root Finding</span>"
    ]
  },
  {
    "objectID": "Optimization-1.html",
    "href": "Optimization-1.html",
    "title": "\n20  Optimization\n",
    "section": "",
    "text": "20.1 Univariate Function Optimization\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport math as m\nimport time  # Imports system time module to time your script\n\nplt.close('all')  # close all open figures\nHere we want to optimize a univariate function:\n\\[f(x) = 4x^2e^{-2x}\\]\nThink of it as a profit function of a company, where the argument of the function, the \\(x\\), is the amount of goods produced and subsequently sold. The more you produce and sell i.e., the larger the \\(x\\) gets, the more profit you will make. But only up to a point. If you overdo it and start to produce too much, inefficiencies in production start to creep in possibly due to congestion in the production process or not enough demand so that production becomes wasteful and costlier the more you keep on producing. In other words, there is a sweet spot that you should not cross and if you do your profits will actually go down.\nIn Python we first define the function:\nNotice that I put a check into the function that returns zero for negative \\(x\\) values. You cannot produce negative amounts, so we need to take care of this here.\nSecond I put a check in for zero value. Since you have a negative exponent, and x of zero would lead to a division by zero which usually breaks the code and returns a \"division-by-zero\" error. Mathematically a division by zero result in infinity. Infinity is not a problem for mathematical theory but it is a problem for numerical computation. We want to avoid it.\nPlotting the function is always a good idea!\nFrom the plot we see that this function seems to have a maximum around when \\(x \\approx 1.0\\). It also seems to be the only maximum which would make it a global maximum.",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Optimization</span>"
    ]
  },
  {
    "objectID": "Optimization-1.html#univariate-function-optimization",
    "href": "Optimization-1.html#univariate-function-optimization",
    "title": "\n20  Optimization\n",
    "section": "",
    "text": "Python Code\nR Code\n\n\n\n\ndef f_profit(x):\n    if (x &lt; 0):\n        return (0)\n    if (x == 0):\n        return (np.nan)\n    y = np.exp(-2*x)\n    return (4 * x**2 * y)\n\n\n\n\nf_profit &lt;- function(x) {\n  if (x &lt; 0) {\n    return (0)\n  }\n  if (x == 0) {\n    return (NaN)\n  }\n  y &lt;- exp(-2 * x)\n  return (4 * x^2 * y)\n}\n\n# Test the R function with some values\nresult &lt;- f_profit(2)\nprint(result)\n\n[1] 0.2930502\n\n\n\n\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nxmin = 0.0\nxmax = 6.0\nxv = np.arange(xmin, xmax, (xmax - xmin)/200.0)\nfx = np.zeros(len(xv),float) # define column vector\nfor i in range(len(xv)):\n    fx[i] = f_profit(xv[i])\n\nfig, ax = plt.subplots()\nax.plot(xv, fx)\nax.plot(xv, np.zeros(len(xv)))\nax.set_xlabel('x')\nax.set_ylabel('f(x)')\nax.set_title('Profit Function')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# Define the x values\nxmin &lt;- 0.0\nxmax &lt;- 6.0\nxv &lt;- seq(xmin, xmax, length.out = 200)\n\n# Calculate the corresponding y values using the profit function\nfx &lt;- sapply(xv, f_profit)\n\n# Create the plot\nplot(xv, fx, type = \"l\", xlab = \"x\", ylab = \"f(x)\", main = \"Profit Function\")\nabline(h = 0, col = \"red\")  # Add a horizontal line at y = 0 (red for emphasis)",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Optimization</span>"
    ]
  },
  {
    "objectID": "Optimization-1.html#optimization-methods",
    "href": "Optimization-1.html#optimization-methods",
    "title": "\n20  Optimization\n",
    "section": "\n20.2 Optimization Methods",
    "text": "20.2 Optimization Methods\n\n\n20.2.1 Newton's Method\nWhat do we know is true at the maximum? If you draw tangent lines along the function, we know that the tangent line at the maximum (or peak) of the function is a flat line. Like so:\n\n\nPython Code\nR Code\n\n\n\n\nxmin = 0.0\nxmax = 6.0\nxv = np.linspace(xmin, xmax, 200)\nfx = np.zeros(len(xv),float) # define column vector\nfor i in range(len(xv)):\n    fx[i] = f_profit(xv[i])\n\nfig, ax = plt.subplots()\nax.plot(xv, fx)\nax.plot(xv, f_profit(1)*np.ones(len(xv)))\nax.set_xlabel('x')\nax.set_ylabel('f(x)')\nax.set_title('Profit Function')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nxmin &lt;- 0.0\nxmax &lt;- 6.0\nxv &lt;- seq(xmin, xmax, length.out = 200)\nfx &lt;- rep(0, length(xv))\n\nfor (i in 1:length(xv)) {\n  fx[i] &lt;- f_profit(xv[i])\n}\n\n# Create the plot\nplot(xv, fx, type = 'l', xlab = 'x', ylab = 'f(x)', main = 'Profit Function')\nabline(h = f_profit(1), col = 'red')\n\n\n\n\n\n\n\n\n\n\nIs there a mathematical expression for a tangent line? Yes there is, it is called the first derivative. This means that at the peak (i.e., maximum) of the function, the slope of the derivative is zero, right?\nIn other words, if we can find the \\(x\\) value where the derivate of the function evaluates to zero, or \\(f'(x) = 0\\), then we would have found the \\(x\\) value where the function is at its maximum value.\nLet's plot the derivative then and see where its value is zero. Calculus first. Derive the function and you will have:\n\\[f'(x) = 4(2 \\times x \\times e^{-2x} +(-2)x^2e^{-2x}) = 8e^{-2x}x(1 - x)\\]\nDerive it again (you will see shortly why) and you will get the second derivative:\n\\[f''(x) = 8e^{-2x}(1-4x+2x^2)\\]\nNext we define another Python function that returns all three, the function value \\(f(x)\\), the value of the derivative \\(f'(x)\\), and the value of the second derivative \\(f''(x)\\). Those are required by some of the algorithms that you are going to see shortly.\n\n\nPython Code\nR Code\n\n\n\n\ndef f_profit_plus_deriv(x):\n    # gamma(2,3) density\n    if (x &lt; 0):\n        return np.array([0, 0, 0])\n    if (x == 0):\n        return np.array([0, 0, np.nan])\n    y = np.exp(-2.0*x)\n    return np.array([4.0 * x**2.0 * np.exp(-2.0*x), \\\n      8.0 * np.exp(-2.0*x) * x*(1.0-x), \\\n      8.0 * np.exp(-2.0*x) * (1 - 4*x + 2 * x**2)])\n\n\n\n\nf_profit_plus_deriv &lt;- function(x) {\n  if (x &lt; 0) {\n    return(c(0, 0, 0))\n  }\n  if (x == 0) {\n    return(c(0, 0, NA))\n  }\n  y &lt;- exp(-2 * x)\n  return(c(4 * x^2 * exp(-2 * x), 8 * exp(-2 * x) * x * (1 - x), 8 * exp(-2 * x) * (1 - 4 * x + 2 * x^2)))\n}\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\nxmin = 0.0\nxmax = 6.0\nxv = np.linspace(xmin, xmax, 200)\ndfx = np.zeros(len(xv),float) # define column vector\nfor i in range(len(xv)):\n\n    # The derivate value is in the second position\n    dfx[i] = f_profit_plus_deriv(xv[i])[1]\n\nfig, ax = plt.subplots()\nax.plot(xv, dfx)\nax.plot(xv, 0*np.ones(len(xv)))\nax.set_xlabel('x')\nax.set_ylabel('f\\'(x)')\nax.set_title('Derivative of Profit Function')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nxmin &lt;- 0.0\nxmax &lt;- 6.0\nxv &lt;- seq(from = xmin, to = xmax, length.out = 200)\ndfx &lt;- numeric(length(xv)) # Initialize a numeric vector\n\nfor (i in 1:length(xv)) {\n    # The derivative value is in the second position of the output vector\n    dfx[i] &lt;- f_profit_plus_deriv(xv[i])[2]\n}\n\nplot(xv, dfx, type = \"l\", xlab = \"x\", ylab = \"f'(x)\", main = \"Derivative of Profit Function\")\nabline(h = 0, col = \"red\")\n\n\n\n\n\n\n\n\n\n\nFrom this plot we see that the derivate function crosses the horizontal axis at and \\(x\\) value of, well, one. So I gave it away, the maximum of the function is at \\(x=1\\).\nLet us pretend for a minute that we do not know that or are not entirely sure whether this is really our maximum value and let us therefore use the Newton algorithm from the previous chapter to make sure that the root of the derivative function is really at one. In order to implement the Newton method we basically look for the root of a first derivative so that \\(f'(x) = 0\\).\n\n\nPython Code\nR Code\n\n\n\n\nmyOpt = 1.0\nfmaxval = f_profit(myOpt)\n\nxmin = 0.0\nxmax = 6.0\nxv = np.linspace(xmin, xmax, 200)\nfx = np.zeros(len(xv),float) # define column vector\nfor i in range(len(xv)):\n    fx[i] = f_profit_plus_deriv(xv[i])[0]\n\nfig, ax = plt.subplots()\nax.plot(xv, fx)\nax.plot(xv, fmaxval*np.ones(len(xv)))\nax.axvline(x = myOpt, ymin=0.0, color='r', linestyle='--')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nmyOpt &lt;- 1.0\nfmaxval &lt;- f_profit(myOpt)\n\nxmin &lt;- 0.0\nxmax &lt;- 6.0\nxv &lt;- seq(from = xmin, to = xmax, length.out = 200)\nfx &lt;- numeric(length(xv)) # Initialize a numeric vector\n\nfor (i in 1:length(xv)) {\n    fx[i] &lt;- f_profit_plus_deriv(xv[i])[1]\n}\n\nplot(xv, fx, type = \"l\", xlab = \"x\", ylab = \"f(x)\", main = \"Profit Function and Maximum\")\nabline(h = fmaxval, col = \"red\")\nabline(v = myOpt, col = \"blue\", lty = 2)\n\n\n\n\n\n\n\n\n\n\nWe then use the root finding algorithm from the previous chapter to find this point, or:\n\n\n\n\n\n\nNote\n\n\n\nNewthon-Raphson Root Finding Algorithm\n\\[x_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}\\]\n\n\nWe have to adjust this of course because the function we search the foot for is already the first derivative of a function, so that we have:\n\n\\[x_{n+1} = x_n - \\frac{f'(x_n)}{f''(x_n)}\\]\n\n\n\nPython Code\nR Code\n\n\n\n\ndef newton(f3, x0, tol = 1e-9, nmax = 100):\n    # Newton's method for optimization, starting at x0\n    # f3 is a function that given x returns the vector\n    # (f(x), f'(x), f''(x)), for some f\n    x = x0\n    f3v = f3(x)\n    n = 0\n    while ((abs(f3v[1]) &gt; tol) and (n &lt; nmax)):\n        # 1st derivative value is the second return value\n        # 2nd derivative value is the third return value\n        x = x - f3v[1]/f3v[2]\n        f3v = f3(x)\n        n = n + 1\n    if (n == nmax):\n        print(\"newton failed to converge\")\n    else:\n        return(x)\n\n\n\n\nnewton &lt;- function(f3, x0, tol = 1e-9, nmax = 100) {\n    # Newton's method for optimization, starting at x0\n    # f3 is a function that given x returns the vector\n    # (f(x), f'(x), f''(x)), for some f\n    x &lt;- x0\n    f3v &lt;- f3(x)\n    n &lt;- 0\n    while (abs(f3v[2]) &gt; tol && n &lt; nmax) {\n        x &lt;- x - f3v[2] / f3v[3]\n        f3v &lt;- f3(x)\n        n &lt;- n + 1\n    }\n    if (n == nmax) {\n        cat(\"Newton failed to converge\\n\")\n    } else {\n        return(x)\n    }\n}\n\n\n\n\nWe next use these algorithms to find the maximum point of our function f_profit_plus_deriv and f_profit. Note that if we use the Newton algorithm we will need the first and second derivatives of the functions. This is why we use function f_profit_plus_deriv that returns f, f' and f'' via an array/vector as return value.\n\n\nPython Code\nR Code\n\n\n\n\nprint(\" -----------------------------------\")\nprint(\" Newton results \")\nprint(\" -----------------------------------\")\nprint(newton(f_profit_plus_deriv, 0.25))\nprint(newton(f_profit_plus_deriv, 0.5))\nprint(newton(f_profit_plus_deriv, 0.75))\nprint(newton(f_profit_plus_deriv, 1.75))\n\n -----------------------------------\n Newton results \n -----------------------------------\n-1.25\n1.0\n0.9999999999980214\n14.42367881581733\n\n\n\n\n\ncat(\" -----------------------------------\\n\")\ncat(\" Newton results \\n\")\ncat(\" -----------------------------------\\n\")\ncat(\"Optimized value for x when starting at 0.25: \", newton(f_profit_plus_deriv, 0.25), \"\\n\")\ncat(\"Optimized value for x when starting at 0.5: \", newton(f_profit_plus_deriv, 0.5), \"\\n\")\ncat(\"Optimized value for x when starting at 0.75: \", newton(f_profit_plus_deriv, 0.75), \"\\n\")\ncat(\"Optimized value for x when starting at 1.75: \", newton(f_profit_plus_deriv, 1.75), \"\\n\")\n\n -----------------------------------\n Newton results \n -----------------------------------\nOptimized value for x when starting at 0.25:  -1.25 \nOptimized value for x when starting at 0.5:  1 \nOptimized value for x when starting at 0.75:  1 \nOptimized value for x when starting at 1.75:  14.42368 \n\n\n\n\n\n\n\n20.2.2 Golden Section Method\nThe golden-section method works in one dimension only, but does not need the derivatives of the function. However, the function still needs to be continuous. In order to determine whether there is a local maximum we need two starting points. For any midpoint \\(x_m\\) we can then establish the following:\n\n\n\n\n\n\nNote\n\n\n\nIf \\(x_l&lt;x_m&lt;x_r\\) and\n\n\n\\(f(x_l) \\leq f(x_m)\\) and\n\n\\(f(x_r) \\leq f(x_m)\\) then there\n\nmust be a local maximum in the interval between \\([x_l,x_r].\\)\n\n\nFigure 20.1 illustrates this case with a maximum point. A similar “statement” can be derived for a minimum, but we focus on maximums for now.\n\n\n\n\n\nFigure 20.1: Maximization using the Golden Ratio Algorithm\n\n\nThe method operates by successively narrowing the range of values on the specified interval \\(x_l\\) to \\(x_r\\) by “moving in” the brackets (or boundary points) and thereby narrowing the interval around the maximum point. This is very similar to the bisection algorithm we saw in the last chapter.\n\n\n\n\n\nFigure 20.2: Maximization using the Golden Ratio Algorithm\n\n\nGiven that the function value \\(f(y)\\) is below the function value \\(f(x_m)\\) we conclude the maximum must be in the interval \\([x_l, y]\\) (as opposed to the equally large interval \\([x_m,x_r]\\)). We therefore move the “right” bracket inwards and declare value \\(y\\) as our new upper bound x-value \\(x_r\\). The algorithm then proceeds with the newly established (smaller) interval and finds a new \\(y\\) and \\(f(y)\\) value until the lower bracket \\(x_l\\) and upper bracket \\(x_r\\) are very close to each other.\nThe Golden Section Search then proceeds as follows:\n\nStart with \\(x_l&lt;x_m&lt;x_r\\) such that \\(f(x_l) \\leq f(x_m)\\) and \\(f(x_r) \\leq f(x_m)\\).\n\nIf \\(x_r - x_l \\le \\epsilon\\) then stop\n\nIf \\(x_r-x_m &gt; x_m-x_l\\) then do \\((a)\\) otherwise do \\((b)\\)\n\nChoose a point \\(y \\in (x_m,x_r)\\) If \\(f(y) \\geq  f(x_m)\\) then put \\(x_l=x_m\\) and \\(x_m=y\\) otherwise put \\(x_r=y\\)\nChoose a point \\(y \\in (x_l,x_m)\\) If \\(f(y) \\geq  f(x_m)\\) then put \\(x_r=x_m\\) and \\(x_m=y\\) otherwise put \\(x_l=y\\)\n\n\nGo back to step 1\n\n\nNote that we have not yet explained how to choose \\(y\\)! Let us do a quick detour first but we will come back to it after this note.\n\n\n\n\n\n\nNote\n\n\n\nIn mathematics, two quantities \\(a\\) and \\(b\\) are in the golden ratio if their ratio is the same as the ratio of their sum to the larger of the two quantities. Assume \\(a&gt;b\\) then the ratio:\n\\[\\frac{a}{b} = \\frac{a+b}{a} = \\varphi\\]\nFigure 20.3 illustrates this geometric relationship.\n\n\n\n\n\nFigure 20.3: Line segments in the golden ratio\n\n\nThe golden ratio is the solution to:\n\\[\\left(\\frac{a}{b}\\right)^2 - \\left(\\frac{a}{b}\\right) -1 = 0,\\]\nso that\n\\[\\left(\\frac{a}{b}\\right) = \\varphi = \\frac{1+\\sqrt{5}}{2}.\\]\nRemember that the solution to a quadratic equation of the form \\[a \\times x^2 + b \\times x + c = 0\\] is \\[ x_{1,2} = \\frac{-b \\pm \\sqrt{b^2 - 4\\times a \\times c}}{2a}\\]\nIn the quadratic above we therefore have: \\[1 \\times \\left(\\frac{a}{b}\\right)^2 - 1\\times \\left(\\frac{a}{b}\\right) -1 = 0,\\]\nso that the solution for the “variable” \\(\\frac{a}{b}\\) becomes \\[\\left(\\frac{a}{b}\\right)_{1,2} = \\frac{-(-1) \\pm \\sqrt{(-1)^2 - 4 \\times 1 \\times(-1)}}{2\\times 1},\\]\nwhich can be simplified to\n\\[\\left(\\frac{a}{b}\\right)_{1,2} = \\frac{1 \\pm \\sqrt{5}}{2} = 1.618033988...,\\]\nWe only use the “positive” of the two possible solutions.\n\n\nThe Golden Rule search method uses this principle and attempts to narrow a lower and upper bracket around a maximum by sequentially ruling out intervals on the x-axis where the maximum cannot be. These successively narrower intervals follow a specific pattern where the ratio of the three intervals (defined by 4 points on the x-axis) stays constant as shown in Figure 20.4. This ensures stable convergence properties.\nIndependent of how you initially choose \\(x_m\\), the interval ratio that is maintained in this way is eventually fixed at \\(\\varphi:1:\\varphi\\), where \\(\\varphi\\) is the golden ratio (the number from the note box above). These ratios are maintained for each iteration and can be shown to follow the “optimal” rate of convergence.\nFigure 20.4 illustrates this for a maximization problem which we set up according to the golden ratio algorithm. The graph shows that the ratio of the intervals I,II, and III follow the fixed ratio established by the golden rule section search.\n\n\n\n\n\nFigure 20.4: Maximization using the Golden Ratio Algorithm\n\n\nIn the picture we started with 3! candidate values \\(x_l\\) and \\(x_r\\) as the outer boundary points that need to contain the maximum and one suitably chosen point in the interval \\(x_m\\).\nThe issue is now how to choose point \\(y\\). We pick the new candidate point \\(y\\) in the graph to maintain this fixed ratio so that if the new bracketing interval is \\([x_l,y]\\) then the ratios satisfy: \\[\\frac{a}{c} = \\frac{b}{a},\\] while if the new bracketing interval is \\([x_m,x_r]\\) then the ratios satisfy: \\[\\frac{b-c}{c} = \\frac{b}{a}.\\]\nWe can now go back to the note box of the Golden Rule and establish that the ratio \\(\\frac{b}{a} = \\varphi\\) by solving the two equations above for \\(\\frac{b}{a}\\). Eliminating \\(c\\) from the 2-equation system results in \\[\\left(\\frac{b}{a}\\right)^2 - \\left(\\frac{b}{a}\\right) -1 = 0,\\]\nwhich can be solved for:\n\\[\\left(\\frac{b}{a}\\right)_{1,2}  = \\varphi = \\frac{1 \\pm \\sqrt{5}}{2} = 1.618033988...\\]\nNote that here the fraction \\(\\frac{b}{a}\\) is reversed (compared to the discussion in the note box for the golden rule) because in our graph \\(b &gt; a\\).\nFrom the solution to this problem we also get \\(a=b-c\\) and \\(c=b/(1+\\varphi)\\) which we can use to calculate a candidate point \\[y = x_m +c = x_m + (x_r-x_m)/(1+\\varphi),\\] and expression you will see in the final algorithm below.\n\n\n\n\n\n\nNote\n\n\n\nStart with \\(x_l&lt;x_m&lt;x_r\\) such that\n\\[f(x_l) \\le (x_m)\\]\nand\n\\[f(x_r) \\le f(x_m)\\]\nand the golden ratio\n\\[\\varphi = \\frac{1+\\sqrt{5}}{2}.\\]\nIn the algorithm we then check the following:\n\n\nIf \\(x_r - x_l \\le \\epsilon\\) then stop\n\nIf \\(x_r-x_m &gt; x_m-x_l\\) then do \\((a)\\) otherwise do \\((b)\\)\n\n\nLet \\(y=x_m+(x_r-x_m)/(1+\\varphi)\\) if \\(f(y) \\ge  f(x_m)\\) then put \\(x_l=x_m\\) and \\(x_m=y\\) otherwise put \\(x_r=y\\)\n\nLet \\(y=x_m+(x_m-x_l)/(1+\\varphi)\\) if \\(f(y) \\ge  f(x_m)\\) then put \\(x_r=x_m\\) and \\(x_m=y\\) otherwise put \\(x_l=y\\)\n\n\n\n\nGo back to step 1\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\n\ndef gsection(ftn, xl, xm, xr, tol = 1e-9):\n    # applies the golden-section algorithm to maximise ftn\n    # we assume that ftn is a function of a single variable\n    # and that x.l &lt; x.m &lt; x.r and ftn(x.l), ftn(x.r) &lt;= ftn(x.m)\n    #\n    # the algorithm iteratively refines x.l, x.r, and x.m and\n    # terminates when x.r - x.l &lt;= tol, then returns x.m\n    # golden ratio plus one\n    gr1 = 1 + (1 + np.sqrt(5))/2\n    #\n    # successively refine x.l, x.r, and x.m\n    fl = ftn(xl)\n    fr = ftn(xr)\n    fm = ftn(xm)\n    while ((xr - xl) &gt; tol):\n        if ((xr - xm) &gt; (xm - xl)):\n            y = xm + (xr - xm)/gr1\n            fy = ftn(y)\n            if (fy &gt;= fm):\n                xl = xm\n                fl = fm\n                xm = y\n                fm = fy\n            else:\n                xr = y\n                fr = fy\n        else:\n            y = xm - (xm - xl)/gr1\n            fy = ftn(y)\n            if (fy &gt;= fm):\n                xr = xm\n                fr = fm\n                xm = y\n                fm = fy\n            else:\n                xl = y\n                fl = fy\n    return(xm)\n\n\n\n\ngsection &lt;- function(ftn, xl, xm, xr, tol = 1e-9) {\n  # Applies the golden-section algorithm to maximize ftn\n  # Assumes that ftn is a function of a single variable\n  # and that xl &lt; xm &lt; xr and ftn(xl), ftn(xr) &lt;= ftn(xm)\n  #\n  # The algorithm iteratively refines xl, xr, and xm and\n  # terminates when xr - xl &lt;= tol, then returns xm\n  # Golden ratio plus one\n  gr1 &lt;- 1 + (1 + sqrt(5))/2\n  #\n  # Successively refine xl, xr, and xm\n  fl &lt;- ftn(xl)\n  fr &lt;- ftn(xr)\n  fm &lt;- ftn(xm)\n  while ((xr - xl) &gt; tol) {\n    if ((xr - xm) &gt; (xm - xl)) {\n      y &lt;- xm + (xr - xm)/gr1\n      fy &lt;- ftn(y)\n      if (fy &gt;= fm) {\n        xl &lt;- xm\n        fl &lt;- fm\n        xm &lt;- y\n        fm &lt;- fy\n      } else {\n        xr &lt;- y\n        fr &lt;- fy\n      }\n    } else {\n      y &lt;- xm - (xm - xl)/gr1\n      fy &lt;- ftn(y)\n      if (fy &gt;= fm) {\n        xr &lt;- xm\n        fr &lt;- fm\n        xm &lt;- y\n        fm &lt;- fy\n      } else {\n        xl &lt;- y\n        fl &lt;- fy\n      }\n    }\n  }\n  return(xm)\n}\n\n\n\n\nThe Golden section algorithm does not require the derivates of the function, so we just call the f_profit function that only returns the functional value.\n\n\nPython Code\nR Code\n\n\n\n\nprint(\" -----------------------------------\")\nprint(\" Golden section results \")\nprint(\" -----------------------------------\")\nmyOpt = gsection(f_profit, 0.1, 0.25, 1.3)\nprint(gsection(f_profit, 0.1, 0.25, 1.3))\nprint(gsection(f_profit, 0.25, 0.5, 1.7))\nprint(gsection(f_profit, 0.6, 0.75, 1.8))\nprint(gsection(f_profit, 0.0, 2.75, 5.0))\n\n -----------------------------------\n Golden section results \n -----------------------------------\n1.0000000117853984\n1.0000000107340477\n0.9999999921384167\n1.0000000052246139\n\n\n\n\n\n# Print results using gsection\ncat(\" -----------------------------------\\n\")\ncat(\" Golden section results \\n\")\ncat(\" -----------------------------------\\n\")\nmyOpt &lt;- gsection(f_profit, 0.1, 0.25, 1.3)\ncat(\"Optimal value for myOpt: \", myOpt, \"\\n\")\ncat(\"Optimal value for (0.1, 0.25, 1.3): \", gsection(f_profit, 0.1, 0.25, 1.3), \"\\n\")\ncat(\"Optimal value for (0.25, 0.5, 1.7): \", gsection(f_profit, 0.25, 0.5, 1.7), \"\\n\")\ncat(\"Optimal value for (0.6, 0.75, 1.8): \", gsection(f_profit, 0.6, 0.75, 1.8), \"\\n\")\ncat(\"Optimal value for (0.0, 2.75, 5.0): \", gsection(f_profit, 0.0, 2.75, 5.0), \"\\n\")\n\n -----------------------------------\n Golden section results \n -----------------------------------\nOptimal value for myOpt:  1 \nOptimal value for (0.1, 0.25, 1.3):  1 \nOptimal value for (0.25, 0.5, 1.7):  1 \nOptimal value for (0.6, 0.75, 1.8):  1 \nOptimal value for (0.0, 2.75, 5.0):  1 \n\n\n\n\n\n\n\n20.2.3 Use Built-In Method to Maximize Function\nFinally, we can also use a built in function minimizer. The built in function fmin is in the scipy.optimize library. We need to import it first. So if we want to maximize our function we have to define it as a negated function, that is:\n\\[g(x) = -f(x)\\]\nthen\n\\[min \\ g(x)\\]\nis the same as\n\\[max \\ f(x).\\]\nSince we want to find the maximum of the function, we need to \"trick\" the minimization algorithm. We therefore need to redefine the function as\n\n\nPython Code\nR Code\n\n\n\n\ndef f_profitNeg(x):\n    # gamma(2,3) density\n    if (x &lt; 0):\n        return (0)\n    if (x == 0):\n        return (np.nan)\n    y = np.exp(-2*x)\n    return (-(4 * x**2 * y))\n\n\n\n\nf_profitNeg &lt;- function(x) {\n  if (x &lt; 0) {\n    return(0)\n  }\n  if (x == 0) {\n    return(NA)\n  }\n  y &lt;- exp(-2 * x)\n  return(-(4 * x^2 * y))\n}\n\n\n\n\nHere we simply return negative values of this function. If we now minimize this function, we actually maximize the original function\n\\[f(x) = 4x^2e^{-2x}\\]\n\n\nPython Code\nR Code\n\n\n\n\nfrom scipy.optimize import fmin\n\nprint(\" -----------------------------------\")\nprint(\" fmin results \")\nprint(\" -----------------------------------\")\nprint(fmin(f_profitNeg, 0.25))\nprint(fmin(f_profitNeg, 0.5))\nprint(fmin(f_profitNeg, 0.75))\nprint(fmin(f_profitNeg, 1.75))\n\n -----------------------------------\n fmin results \n -----------------------------------\nOptimization terminated successfully.\n         Current function value: -0.541341\n         Iterations: 18\n         Function evaluations: 36\n[1.]\nOptimization terminated successfully.\n         Current function value: -0.541341\n         Iterations: 16\n         Function evaluations: 32\n[1.]\nOptimization terminated successfully.\n         Current function value: -0.541341\n         Iterations: 14\n         Function evaluations: 28\n[0.99997559]\nOptimization terminated successfully.\n         Current function value: -0.541341\n         Iterations: 16\n         Function evaluations: 32\n[1.00001221]\n\n\n\n\nIn R, you can use the optim function for optimization tasks similar to fmin in Python. The par parameter is the initial guess for the optimum, and fn is the function to be minimized. The results are accessed through $par.\n\n# Example usage\nprint(\" -----------------------------------\")\nprint(\" optim results \")\nprint(\" -----------------------------------\")\n\nresult1 &lt;- optim(par = 0.25, fn = f_profitNeg)\n\nWarning in optim(par = 0.25, fn = f_profitNeg): one-dimensional optimization by Nelder-Mead is unreliable:\nuse \"Brent\" or optimize() directly\n\nprint(result1$par)\n\nresult2 &lt;- optim(par = 0.5, fn = f_profitNeg)\n\nWarning in optim(par = 0.5, fn = f_profitNeg): one-dimensional optimization by Nelder-Mead is unreliable:\nuse \"Brent\" or optimize() directly\n\nprint(result2$par)\n\nresult3 &lt;- optim(par = 0.75, fn = f_profitNeg)\n\nWarning in optim(par = 0.75, fn = f_profitNeg): one-dimensional optimization by Nelder-Mead is unreliable:\nuse \"Brent\" or optimize() directly\n\nprint(result3$par)\n\nresult4 &lt;- optim(par = 1.75, fn = f_profitNeg)\n\nWarning in optim(par = 1.75, fn = f_profitNeg): one-dimensional optimization by Nelder-Mead is unreliable:\nuse \"Brent\" or optimize() directly\n\nprint(result4$par)\n\n[1] \" -----------------------------------\"\n[1] \" optim results \"\n[1] \" -----------------------------------\"\n[1] 1\n[1] 1\n[1] 1.000049\n[1] 0.9999268",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Optimization</span>"
    ]
  },
  {
    "objectID": "Optimization-1.html#finding-the-root-of-a-function-using-minimization",
    "href": "Optimization-1.html#finding-the-root-of-a-function-using-minimization",
    "title": "\n20  Optimization\n",
    "section": "\n20.3 Finding the Root of a Function using Minimization",
    "text": "20.3 Finding the Root of a Function using Minimization\nIn a previous chapter on root searching of a function we used various methods like the built in fsolve or root functions from the scipy.optimize library. Here's the example from the Root finding chapter again:\nThe example function for which we calculate the root, i.e., find \\(x\\) so that \\(f(x) = 0\\) is defined as:\n\n\nPython Code\nR Code\n\n\n\n\ndef func(x):\n    s = np.log(x) - np.exp(-x)  # function: f(x)\n    return s\n\n\n\n\nfunc &lt;- function(x) {\n  s &lt;- log(x) - exp(-x)  # function: f(x)\n  return(s)\n}\n\n\n\n\nWe can solve for the zero (root) position with:\n\n\nPython Code\nR Code\n\n\n\n\nfrom scipy.optimize import root\n\nguess = 2\nresult = root(func, guess) # starting from x = 2\nprint(\" \")\nprint(\" -------------- Root ------------\")\nmyroot = result.x  # Grab number from result dictionary\nprint(\"The root of d_func is at {}\".format(myroot))\nprint(\"The max value of the function is {}\".format(myOpt))\n\n \n -------------- Root ------------\nThe root of d_func is at [1.30979959]\nThe max value of the function is 1.0000000117853984\n\n\n\n\n\nlibrary(rootSolve)\n\nguess &lt;- 2\nresult &lt;- uniroot(func, interval = c(0.7, guess))  # Starting from x = 2\n\ncat(\" \\n\")\ncat(\" -------------- Root ------------\\n\")\nmyroot &lt;- result$root  # Extract the root value\ncat(\"The root of d_func is at\", myroot, \"\\n\")\ncat(\"The max value of the function is\", myOpt, \"\\n\")\n\n \n -------------- Root ------------\nThe root of d_func is at 1.309803 \nThe max value of the function is 1 \n\n\n\n\n\nIn this section we set up the root finding problem as an optimization problem. In order to do this we change the return value of the function slightly to\n\\[\\text{residual-error} = (f(x) - 0)^2.\\]\nSo we are trying to find the value of x so that the residual error between \\(f(x)\\) and its target value of \\(0\\) is as small as possible. The new function is defined as:\n\n\nPython Code\nR Code\n\n\n\n\ndef func_root_min(x):\n    s = np.log(x) - np.exp(-x)  # function: f(x)\n    return (s**2)\n\n\n\n\nfunc_root_min &lt;- function(x) {\n  s &lt;- log(x) - exp(-x)  # function: f(x)\n  return(s^2)\n}\n\n\n\n\nWe now invoke a minimizing algorithm to find this value of \\(x\\)\n\n\nPython Code\nR Code\n\n\n\n\nfrom scipy.optimize import minimize\n\nguess = 2 # starting guess x = 2\nresult_min = minimize(func_root_min, guess, method='Nelder-Mead')\n\nprint(\" \")\nprint(\"-------------- Root ------------\")\nmyroot = result_min.x  # Grab number from result dictionary\nprint(\"The root of func is at {}\".format(myroot))\n\n \n-------------- Root ------------\nThe root of func is at [1.30976562]\n\n\n\n\n\n# Starting guess\nguess &lt;- 2\n\n# Perform the minimization\nresult_min &lt;- optim(guess, func_root_min, method = \"Nelder-Mead\")\n\nWarning in optim(guess, func_root_min, method = \"Nelder-Mead\"): one-dimensional optimization by Nelder-Mead is unreliable:\nuse \"Brent\" or optimize() directly\n\ncat(\"\\n\")\ncat(\"-------------- Root ------------\\n\")\nmyroot &lt;- result_min$par  # Extract the minimizer from the result\ncat(paste(\"The root of func is at\", myroot), \"\\n\")\n\n\n-------------- Root ------------\nThe root of func is at 1.309765625",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Optimization</span>"
    ]
  },
  {
    "objectID": "Optimization-1.html#multivariate-optimization",
    "href": "Optimization-1.html#multivariate-optimization",
    "title": "\n20  Optimization\n",
    "section": "\n20.4 Multivariate Optimization",
    "text": "20.4 Multivariate Optimization\n\n\n20.4.1 Function\nHere we want to optimize the following function f3\n\n\nPython Code\nR Code\n\n\n\n\ndef f3simple(x):\n    a = x[0]**2/2.0 - x[1]**2/4.0\n    b = 2*x[0] - np.exp(x[1])\n    f = np.sin(a)*np.cos(b)\n    return(f)\n\n\n\n\nf3simple &lt;- function(x) {\n  a &lt;- x[1]^2/2 - x[2]^2/4\n  b &lt;- 2*x[1] - exp(x[2])\n  f &lt;- sin(a) * cos(b)\n  return(f)\n}\n\n\n\n\nIts negative version:\n\n\nPython Code\nR Code\n\n\n\n\ndef f3simpleNeg(x):\n    a = x[0]**2/2.0 - x[1]**2/4.0\n    b = 2*x[0] - np.exp(x[1])\n    f = -np.sin(a)*np.cos(b)\n    return(f)\n\n\n\n\nf3simpleNeg &lt;- function(x) {\n  a &lt;- x[1]^2/2 - x[2]^2/4\n  b &lt;- 2*x[1] - exp(x[2])\n  f &lt;- -sin(a) * cos(b)\n  return(f)\n}\n\n\n\n\nAnd the version that returns \\(f(x)\\), \\(f'(x)\\) (i.e., the gradient), and \\(f''(x)\\) (i.e., the Hessian matrix):\n\n\nPython Code\nR Code\n\n\n\n\ndef f3(x):\n    a = x[0]**2/2.0 - x[1]**2/4.0\n    b = 2*x[0] - np.exp(x[1])\n    f = np.sin(a)*np.cos(b)\n    f1 = np.cos(a)*np.cos(b)*x[0] - np.sin(a)*np.sin(b)*2\n    f2 = -np.cos(a)*np.cos(b)*x[1]/2 + np.sin(a)*np.sin(b)*np.exp(x[1])\n    f11 = -np.sin(a)*np.cos(b)*(4 + x[0]**2) + np.cos(a)*np.cos(b) \\\n        - np.cos(a)*np.sin(b)*4*x[0]\n    f12 = np.sin(a)*np.cos(b)*(x[0]*x[1]/2.0 + 2*np.exp(x[1])) \\\n        + np.cos(a)*np.sin(b)*(x[0]*np.exp(x[1]) + x[1])\n    f22 = -np.sin(a)*np.cos(b)*(x[1]**2/4.0 + np.exp(2*x[1])) \\\n        - np.cos(a)*np.cos(b)/2.0 - np.cos(a)*np.sin(b)*x[1]*np.exp(x[1]) \\\n        + np.sin(a)*np.sin(b)*np.exp(x[1])\n    # Function f3 returns: f(x), f'(x), and f''(x)\n    return (f, np.array([f1, f2]), np.array([[f11, f12], [f12, f22]]))\n\n\n\n\nf3 &lt;- function(x) {\n  a &lt;- x[1]^2/2 - x[2]^2/4\n  b &lt;- 2*x[1] - exp(x[2])\n  f &lt;- sin(a) * cos(b)\n  f1 &lt;- cos(a) * cos(b) * x[1] - sin(a) * sin(b) * 2\n  f2 &lt;- -cos(a) * cos(b) * x[2]/2 + sin(a) * sin(b) * exp(x[2])\n  f11 &lt;- -sin(a) * cos(b) * (4 + x[1]^2) + cos(a) * cos(b) - cos(a) * sin(b) * 4 * x[1]\n  f12 &lt;- sin(a) * cos(b) * (x[1] * x[2]/2 + 2 * exp(x[2])) + cos(a) * sin(b) * (x[1] * exp(x[2]) + x[2])\n  f22 &lt;- -sin(a) * cos(b) * (x[2]^2/4 + exp(2 * x[2])) - cos(a) * cos(b)/2 - cos(a) * sin(b) * x[2] * exp(x[2]) + sin(a) * sin(b) * exp(x[2])\n  # Function f3 returns: f(x), f'(x), and f''(x)\n  return (list(f, c(f1, f2), matrix(c(f11, f12, f12, f22), nrow = 2, ncol = 2)))\n}\n\n\n\n\nWe next plot the function:\n\n\nPython Code\nR Code\n\n\n\n\nX = np.arange(-3, 3, .1)\nY = np.arange(-3, 3, .1)\nX, Y = np.meshgrid(X, Y)\n\nZ = np.zeros((len(X),len(Y)),float)\nfor i in range(len(X)):\n    for j in range(len(Y)):\n        Z[i][j] = f3simple([X[i][j],Y[i][j]])\n\nax = plt.figure(figsize=(6, 7)).add_subplot(projection='3d')\nax.plot_surface(X, Y, Z, rstride=1, cstride=1, \\\n    cmap=plt.cm.jet, linewidth=0, antialiased=False)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# Load the rgl package\nlibrary(rgl)\n\n# Define the range for X and Y values\nX &lt;- seq(-3, 3, by = 0.1)\nY &lt;- seq(-3, 3, by = 0.1)\n\n# Create a grid of X and Y values\nXY &lt;- expand.grid(X, Y)\n\n# Calculate Z values using f3simple\nZ &lt;- sapply(1:nrow(XY), function(i) {\n  f3simple(c(XY[i, 1], XY[i, 2]))\n})\n\n# Reshape Z into a matrix\nZ_matrix &lt;- matrix(Z, nrow = length(X), ncol = length(Y), byrow = TRUE)\n\n# Create a 3D plot\nplot3d(X, Y, Z_matrix, type = \"surface\", color = \"jet\")\n\n# Adjust plot settings if needed\nrgl.postscript(\"3d_plot.png\", fmt = \"png\")\n\nError in rgl.enum(postscripttype, ps = 0, eps = 1, tex = 2, pdf = 3, svg = 4, : Symbolic value must be chosen from: c(\"ps\", \"eps\", \"tex\", \"pdf\", \"svg\", \"pgf\")\n\n# To rotate the plot interactively in RStudio, use:\n# rglwidget()\n\n\n\n\n\n\n20.4.2 Multivariate Newton Method\n\n\nPython Code\nR Code\n\n\n\n\ndef newtonMult(f3, x0, tol = 1e-9, nmax = 100):\n    # Newton's method for optimization, starting at x0\n    # f3 is a function that given x returns the list\n    # {f(x), grad f(x), Hessian f(x)}, for some f\n    x = x0\n    f3x = f3(x)\n    n = 0\n    while ((max(abs(f3x[1])) &gt; tol) and (n &lt; nmax)):\n        x = x - np.linalg.solve(f3x[2], f3x[1])\n        f3x = f3(x)\n        n = n + 1\n    if (n == nmax):\n        print(\"newton failed to converge\")\n    else:\n        return(x)\n\n\n\n\nnewtonMult &lt;- function(f3, x0, tol = 1e-9, nmax = 100) {\n  # Newton's method for optimization, starting at x0\n  # f3 is a function that given x returns the list\n  # {f(x), grad f(x), Hessian f(x)}, for some f\n  x &lt;- x0\n  f3x &lt;- f3(x)\n  n &lt;- 0\n  while (max(abs(f3x[[2]])) &gt; tol && n &lt; nmax) {\n    x &lt;- x - solve(f3x[[3]], f3x[[2]])\n    f3x &lt;- f3(x)\n    n &lt;- n + 1\n  }\n  if (n == nmax) {\n    cat(\"newton failed to converge\\n\")\n  } else {\n    return(x)\n  }\n}\n\n# Example usage:\n# x0 &lt;- c(0, 0)  # Initial guess\n# result &lt;- newtonMult(f3, x0)\n# print(result)\n\n\n\n\nCompare the Newton method with the built in fmin method in scipy.optimize. We use various starting values to see whether we can find more than one optimum.\n\n\nPython Code\nR Code\n\n\n\n\nfrom scipy.optimize import fmin\n\nfor x0 in np.arange(1.4, 1.6, 0.1):\n    for y0 in np.arange(0.4, 0.7, 0.1):\n        # This algorithm requires f(x), f'(x), and f''(x)\n        print(\"Newton: f3  \" + str([x0,y0]) + ' --&gt; ' + str(newtonMult(f3, \\\n            np. array([x0,y0]))))\n\n        print(\"fmin: f3 \" + str([x0,y0]) + ' --&gt; ' \\\n            + str(fmin(f3simpleNeg, np.array([x0,y0]))))\n\n        print(\" ----------------------------------------- \")\n\nNewton: f3  [1.4, 0.4] --&gt; [ 0.04074437 -2.50729047]\nOptimization terminated successfully.\n         Current function value: -1.000000\n         Iterations: 47\n         Function evaluations: 89\nfmin: f3 [1.4, 0.4] --&gt; [2.0307334  1.40155445]\n ----------------------------------------- \nNewton: f3  [1.4, 0.5] --&gt; [0.11797341 3.34466147]\nOptimization terminated successfully.\n         Current function value: -1.000000\n         Iterations: 50\n         Function evaluations: 93\nfmin: f3 [1.4, 0.5] --&gt; [2.03072555 1.40154756]\n ----------------------------------------- \nNewton: f3  [1.4, 0.6] --&gt; [-1.5531627  6.0200129]\nOptimization terminated successfully.\n         Current function value: -1.000000\n         Iterations: 43\n         Function evaluations: 82\nfmin: f3 [1.4, 0.6] --&gt; [2.03068816 1.40151998]\n ----------------------------------------- \nNewton: f3  [1.5, 0.4] --&gt; [2.83714224 5.35398196]\nOptimization terminated successfully.\n         Current function value: -1.000000\n         Iterations: 48\n         Function evaluations: 90\nfmin: f3 [1.5, 0.4] --&gt; [2.03067611 1.40149298]\n ----------------------------------------- \nNewton: f3  [1.5, 0.5] --&gt; [ 0.04074437 -2.50729047]\nOptimization terminated successfully.\n         Current function value: -1.000000\n         Iterations: 42\n         Function evaluations: 82\nfmin: f3 [1.5, 0.5] --&gt; [2.03071509 1.40155165]\n ----------------------------------------- \nNewton: f3  [1.5, 0.6] --&gt; [9.89908350e-10 1.36639196e-09]\nOptimization terminated successfully.\n         Current function value: -1.000000\n         Iterations: 43\n         Function evaluations: 82\nfmin: f3 [1.5, 0.6] --&gt; [2.0307244  1.40153761]\n ----------------------------------------- \nNewton: f3  [1.6, 0.4] --&gt; [-0.55841026 -0.78971136]\nOptimization terminated successfully.\n         Current function value: -1.000000\n         Iterations: 47\n         Function evaluations: 88\nfmin: f3 [1.6, 0.4] --&gt; [2.0307159  1.40150964]\n ----------------------------------------- \nNewton: f3  [1.6, 0.5] --&gt; [-0.29022131 -0.23047994]\nOptimization terminated successfully.\n         Current function value: -1.000000\n         Iterations: 44\n         Function evaluations: 80\nfmin: f3 [1.6, 0.5] --&gt; [2.03074135 1.40151521]\n ----------------------------------------- \nNewton: f3  [1.6, 0.6] --&gt; [-1.55294692 -3.33263763]\nOptimization terminated successfully.\n         Current function value: -1.000000\n         Iterations: 42\n         Function evaluations: 80\nfmin: f3 [1.6, 0.6] --&gt; [2.03069759 1.40155333]\n ----------------------------------------- \n\n\n\n\n\nfor (x0 in seq(1.4, 1.6, by = 0.1)) {\n  for (y0 in seq(0.4, 0.7, by = 0.1)) {\n    # This algorithm requires f(x), f'(x), and f''(x)\n    cat(\"Newton: f3  \", c(x0, y0), \" --&gt; \", newtonMult(f3, c(x0, y0)), \"\\n\")\n\n    result_min &lt;- optim(c(x0, y0), f3simpleNeg)\n    cat(\"optim: f3 \", c(x0, y0), \" --&gt; \", result_min$par, \"\\n\")\n\n    cat(\" -----------------------------------------\\n\")\n  }\n}\n\nNewton: f3   1.4 0.4  --&gt;  0.04074437 -2.50729 \noptim: f3  1.4 0.4  --&gt;  2.03071 1.401523 \n -----------------------------------------\nNewton: f3   1.4 0.5  --&gt;  0.1179734 3.344661 \noptim: f3  1.4 0.5  --&gt;  2.03071 1.401541 \n -----------------------------------------\nNewton: f3   1.4 0.6  --&gt;  -1.553163 6.020013 \noptim: f3  1.4 0.6  --&gt;  2.030687 1.401515 \n -----------------------------------------\nNewton: f3   1.4 0.7  --&gt;  -0.7731558 -3.709705 \noptim: f3  1.4 0.7  --&gt;  2.030682 1.401522 \n -----------------------------------------\nNewton: f3   1.5 0.4  --&gt;  2.837142 5.353982 \noptim: f3  1.5 0.4  --&gt;  2.030681 1.401512 \n -----------------------------------------\nNewton: f3   1.5 0.5  --&gt;  0.04074437 -2.50729 \noptim: f3  1.5 0.5  --&gt;  2.030674 1.401523 \n -----------------------------------------\nNewton: f3   1.5 0.6  --&gt;  9.899083e-10 1.366392e-09 \noptim: f3  1.5 0.6  --&gt;  2.030682 1.401527 \n -----------------------------------------\nNewton: f3   1.5 0.7  --&gt;  2.585751e-17 3.053722e-17 \noptim: f3  1.5 0.7  --&gt;  2.030694 1.401503 \n -----------------------------------------\nNewton: f3   1.6 0.4  --&gt;  -0.5584103 -0.7897114 \noptim: f3  1.6 0.4  --&gt;  2.030685 1.401521 \n -----------------------------------------\nNewton: f3   1.6 0.5  --&gt;  -0.2902213 -0.2304799 \noptim: f3  1.6 0.5  --&gt;  2.030696 1.401522 \n -----------------------------------------\nNewton: f3   1.6 0.6  --&gt;  -1.552947 -3.332638 \noptim: f3  1.6 0.6  --&gt;  2.030685 1.401525 \n -----------------------------------------\nNewton: f3   1.6 0.7  --&gt;  6.886167e-10 8.21652e-10 \noptim: f3  1.6 0.7  --&gt;  2.03068 1.401506 \n -----------------------------------------\n\n\n\n\n\n\n\n\n\n\n\nKey Concepts and Summary\n\n\n\n\nIntroduction to basic optimization algorithms\n\n\n\n\n\n\n\n\n\nSelf-check questions\n\n\n\n\n\n\nSolve the following maximization problem.\n\n\n\n\n\n\n\nFigure 20.1: Maximization using the Golden Ratio Algorithm\nFigure 20.2: Maximization using the Golden Ratio Algorithm\nFigure 20.3: Line segments in the golden ratio\nFigure 20.4: Maximization using the Golden Ratio Algorithm",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Optimization</span>"
    ]
  },
  {
    "objectID": "Optimization-2-Cake.html",
    "href": "Optimization-2-Cake.html",
    "title": "\n21  Constrained Optimization\n",
    "section": "",
    "text": "21.1 The Cake Eating Problem\nOnce upon a time there was a little girl who got a cake. The girl decided to eat the cake all alone. But she was not sure when she wanted to eat the cake. First, she thought of eating the whole cake right away. But then, nothing would be left for tomorrow and the day after tomorrow.\nWell, on the one hand, eating cake today is better than eating it tomorrow. But then, eating too much at the same time might not be the best either. She imagined that the first mouthful of cake is a real treat, the second is great, the third is also nice. But the more you eat, the less you enjoy it.\nSo, she decided to eat only a bit of the cake everyday. Then, she could eat everyday another first mouthful of cake. The girl knew that the cake would be spoiled if she kept it more than nine days. Therefore, she would eat the cake in the first ten days. Yet, how much should she eat everyday?",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Constrained Optimization</span>"
    ]
  },
  {
    "objectID": "Optimization-2-Cake.html#solution",
    "href": "Optimization-2-Cake.html#solution",
    "title": "\n21  Constrained Optimization\n",
    "section": "\n21.2 Solution",
    "text": "21.2 Solution\n\nShe thought of eating everyday a piece of the same size.\nBut if eating cake today is better than waiting for tomorrow, how can it possibly be the best to do the same today as tomorrow?\nIf I ate just a little bit less tomorrow and a little bit more today I would be better off, she concluded.\nAnd she would eat everyday a bit less than the previous day and the cake would last ten days long and nothing would be left in the end",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Constrained Optimization</span>"
    ]
  },
  {
    "objectID": "Optimization-2-Cake.html#formally",
    "href": "Optimization-2-Cake.html#formally",
    "title": "\n21  Constrained Optimization\n",
    "section": "\n21.3 Formally",
    "text": "21.3 Formally\n\nAssume preferences in every period \\(t\\) follow: \\(u(c_t) = ln(c_t)\\)\n\n\n\\(c_t\\) is the amount of cake consumed in period \\(t\\)\n\nFuture consumption is discounted with the time-preference factor \\(\\beta&lt; 1\\).\nThe present value in period 0 of the whole consumption path is:\n\n\\[V(c_0, c_1 ,c_2 ,...,c_T ) = \\sum_{t=0}^{T} \\beta^{t} U(c_t)\\]\n\nThe person tries to maximize this by choosing her consumption in every period \\(t=0,..,T\\)\n\nThe cake size in the next period \\(t+1\\) is the size today less the consumption today\n\n\\[k_{t+1} = k_{t} - c_{t}\\]\n\nTherefore, the cake size must be non-negative in any period, so that\n\n\\[k_t \\ge 0\\]\nThe maximization problem can be written as\n\\[\\max_{c_0,c_1,...,c_T} \\sum_{t=0}^{T} \\beta^{t} U(c_t)\\]\\[s.t.\\]\\[c_0 + c_1 + ... + c_T = k_0\\]\nIt is a constrained maximization problem with one constraint.",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Constrained Optimization</span>"
    ]
  },
  {
    "objectID": "Optimization-2-Cake.html#analytical-solution",
    "href": "Optimization-2-Cake.html#analytical-solution",
    "title": "\n21  Constrained Optimization\n",
    "section": "\n21.4 Analytical Solution",
    "text": "21.4 Analytical Solution\n\nWe can express consumption in period \\(t\\) from the budget constraint as\n\n\\[c_t = k_t - k_{t+1}\\]\nand similarly we can express consumption in other periods, say \\(t-1\\), \\(t\\), or \\(t+1\\) as\n\\[c_{t-1} = k_{t-1} - k_{t}\\]\\[c_{t} = k_{t} - k_{t+1}\\]\\[c_{t+1} = k_{t+1} - k_{t+2}\\]\n\nSubstituting these consumption expressions into the life-time consumption path we get:\n\n\\[U(k_{0} - k_{1})+ \\beta U(k_{1} - k_{2})+...+ \\beta^{t-1} U(k_{t-1} - k_{t}) + \\beta^{t}  U(k_{t} - k_{t+1}) + \\beta^{t+1}  U(k_{t+1} - k_{t+2}) ...\\]\n\n\nDeriving this objective function w.r.t. \\(k_t\\) and setting is equal to zero as it is a first order condition we get:\n\\[\\beta^{t-1} U'(k_{t-1} - k_{t})\\times (-1) + \\beta^{t}  U'(k_{t} - k_{t+1}) = 0.\\]\nThis can be rearranged to\n\\[U'(k_{t-1} - k_{t}) = \\frac{\\beta^{t}}{\\beta^{t-1}} U'(k_{t} - k_{t+1})\\]\nor with the budget constraints plugged back in\n\n\n\\[U'(c_{t-1}) = \\beta U'(c_{t})\\]\n\nThis is the so called Euler Equation. It relates the marginal utility of consumption today to the marginal utility of consumption tomorrow. It is an inter-temporal optimality condition.\nThe Euler equation links two periods together. For the solution (the consumption path we are looking for) to be an optimum, this equation has to hold in every period.\n\n\\[U'(c_{t}) = \\beta U'(c_{t+1})\\]\n\n\n\n\n\n\nImportant\n\n\n\nThe Euler Equation has an intuitive interpretation:\n\nAt a utility maximum, the consumer cannot gain from feasible shifts of consumption between periods\nA one-unit reduction in period \\(t\\) consumption lowers \\(U_t\\) by \\(U'_t\\)\n\nThis unit saved can be shifted to period \\(t+1\\) where it raises utility by \\(U'_{t+1}\\) which needs to be discounted back one period so the marginal utility values become comparable \\(t\\), that is: \\(\\beta \\times U'_{t+1}\\)\n\nIn the optimum these two quantities must be equal!",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Constrained Optimization</span>"
    ]
  },
  {
    "objectID": "Optimization-2-Cake.html#solving-the-problem",
    "href": "Optimization-2-Cake.html#solving-the-problem",
    "title": "\n21  Constrained Optimization\n",
    "section": "\n21.5 Solving the Problem",
    "text": "21.5 Solving the Problem\n\n\nPlugging the functional form for the utility function into the Euler equation we get:\n\n\\[\\frac{1}{c_{t}} = \\frac{\\beta}{c_{t+1}}\\]\nor\n\\[c_{t+1} = \\beta c_{t}\\]\nor reformulated again and expressed as \\(c_{t}\\)\n\\[c_{t} = \\frac{1}{\\beta}\\times c_{t+1}\\]\n\n\nIn the optimum we know that: \\(k_{T+1} = 0\\). After the last period \\(T\\) we won't have any leftover cake. It would not be optimal to have leftover cake.\nRecursively plugging the budget constraint into the Euler equation we get:\n\n\\[\\boxed{c_0=\\frac{1-\\beta}{(1-\\beta)^{T+1}}k_0}\\]\n\nWe can now map out the optimal consumption for any size cake: \\(k_0\\)\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe solution above (in the box) was found by solving the problem backwards, starting in the last period \\(T\\):\n\n\\(c_T = k_T\\) in the last period, eat rest of cake you still have and do not leave anything for period \\(T+1\\)\n\n\\(c_{T-1}\\) we get by:\n\n\n\nSubstituting the solution we got above into the Euler equation that connects period \\(T-1\\) to the last period \\(T\\) we have:\n\\[c_{T-1}=\\frac{1}{\\beta} c_T=\\frac{1}{\\beta} k_T\\]\nWe now have an expression for \\(c_{T-1}\\) as a funciton of cake in the last period \\(k_T\\). However, we need an expression that tells us how much to consume in period \\(T-1\\) as a function of the amount of cake in \\(T-1\\) that is \\(k_{T-1}\\)\n\n\nWe use the the budget constraint in period \\(T-1\\)\n\\[c_{T-1} = k_{T-1} - k_{T}\\]\nsolve it for \\(k_T\\) and replace \\(k_T\\) in the Euler equation above so that we get\n\\[c_{T-1}=\\frac{1}{\\beta} (k_{T-1} - c_{T-1})\\]\n\n\nWhich can be solved for \\(c_{T-1}\\) which is\n\\[c_{T-1}=\\frac{1}{1+\\beta} k_{T-1}\\]\nThis is now an expression of optimal consumption in \\(T-1\\) as a function of the amount of cake in the same period, that is \\(k_{T-1}\\)\n\n\n\n\n\nWe next solve for: \\(c_{T-2}=\\frac{1}{\\beta} c_{T-1}\\), which after substituting for \\(c_{T-1}=\\frac{1}{1+\\beta} k_{T-1}\\) we get\n\n\\(c_{T-2}=\\frac{1}{\\beta +\\beta^{2}} k_{T-1}\\). We again substitute the budget constraint \\(k_{T-1} = k_{T-2} - c_{T-2}\\) and get \\(c_{T-2}=\\frac{1}{\\beta +\\beta^{2}} (k_{T-2} - c_{T-2})\\) which we can solve for \\(c_{T-2}\\) which becomes: \\(c_{T-2}=\\frac{1}{1 + \\beta +\\beta^{2}} k_{T-2}\\)\n\n\nContinue with this and find: \\(c_{T-T} = \\frac{1}{1+\\beta + \\beta^2 +...+\\beta^T} k_{T-T}\\)\nUsing the summation formulat for a finite series \\(\\sum_{t=0}^{T}\\beta^t = \\frac{1-\\beta^{T+1}}{1-\\beta}\\), we get\n\\(\\boxed{c_0=\\frac{1-\\beta}{(1-\\beta)^{T+1}}k_0}\\)\n\nOnce we have this, we can solve the problem for any amount of starting cake \\(k_0\\). Using the optimal consumption in the first period \\(c_0\\) we can immediately use the Euler equation to solve for next period's optimal consumption\n\\[c_1 = \\beta \\times c_0\\]\netc.",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Constrained Optimization</span>"
    ]
  },
  {
    "objectID": "Optimization-2-Cake.html#plotting-the-solution",
    "href": "Optimization-2-Cake.html#plotting-the-solution",
    "title": "\n21  Constrained Optimization\n",
    "section": "\n21.6 Plotting the Solution",
    "text": "21.6 Plotting the Solution\n\nFor any size \\(k+0\\) and time horizon \\(T\\) we can now calculate the optimal consumption in each period\nExample: \\(k_0 = 100\\), \\(T=10\\), and \\(\\beta = 0.96\\)\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport math as m\nfrom scipy import stats as st\nfrom scipy import optimize\nimport time            # Imports system time module to time your script\n\nplt.close('all')  # close all open figures\n\nWe next calculate the solutions following the analytical procedure introduced above and plot the optimal consumption path over time.\n\n\n\n\n\n\nNote\n\n\n\nSince we defined the problem above as t=0,t=1,...,t=T-1, t=T. A 10 period problem goes from t=0, t=1, ..., t=9 so that T=9.\n\n\n\n\nPython Code\nR Code\n\n\n\n\nT = 9\nbeta = 0.96\nkv = np.zeros(T+1,float)\ncv = np.zeros(T+1,float)\nuv = np.zeros(T+1,float)\nkv[0] = 100  # k0\ncv[0] = (1.0-beta)/(1.0-beta**(T+1)) * kv[0]  # c0\nuv[0] = np.log(cv[0])\n\nfor i in range(1,T+1):\n    #print \"i=\" + str(i)\n    cv[i] = beta * cv[i-1]\n    kv[i] = kv[i-1] - cv[i-1]\n\n    # Period utility with discounting\n    uv[i] = beta**i *np.log(cv[i])\n\nnp.sum(uv)  # total utility\n\ncoptv = cv\nkoptv = kv\n\nprint(\"coptv = \" + str(coptv))\nprint(\"koptv = \" + str(koptv))\n\n19.351141994352123\ncoptv = [11.93433618 11.45696274 10.99868423 10.55873686 10.13638738  9.73093189\n  9.34169461  8.96802683  8.60930576  8.26493353]\nkoptv = [100.          88.06566382  76.60870108  65.61001685  55.05127999\n  44.91489261  35.18396072  25.84226611  16.87423928   8.26493353]\n\n\n\n\n\nT &lt;- 9\nbeta &lt;- 0.96\nkv &lt;- numeric(T + 1)\ncv &lt;- numeric(T + 1)\nuv &lt;- numeric(T + 1)\nkv[1] &lt;- 100  # k0\ncv[1] &lt;- (1 - beta) / (1 - beta^(T + 1)) * kv[1]  # c0\nuv[1] &lt;- log(cv[1])\n\nfor (i in 2:(T + 1)) {\n    cv[i] &lt;- beta * cv[i - 1]\n    kv[i] &lt;- kv[i - 1] - cv[i - 1]\n\n    # Period utility with discounting\n    uv[i] &lt;- beta^(i - 1) * log(cv[i])\n}\n\ntotal_utility &lt;- sum(uv)  # total utility\n\ncoptv &lt;- cv\nkoptv &lt;- kv\n\ncat(\"coptv = \", coptv, \"\\n\")\ncat(\"koptv = \", koptv, \"\\n\")\n\ncat(\"Total Utility = \", total_utility, \"\\n\")\n\ncoptv =  11.93434 11.45696 10.99868 10.55874 10.13639 9.730932 9.341695 8.968027 8.609306 8.264934 \nkoptv =  100 88.06566 76.6087 65.61002 55.05128 44.91489 35.18396 25.84227 16.87424 8.264934 \nTotal Utility =  19.35114 \n\n\n\n\n\nPlotting the function is achieved via:\n\n\nPython Code\nR Code\n\n\n\n\nfig, ax = plt.subplots(2,1)\nplt.subplots_adjust(wspace=0.4, hspace=0.8)\n#\nax[0].plot(coptv, '-o')\nax[0].set_ylabel(r'$c^*_t$')\nax[0].set_xlabel('Period t')\nax[0].set_title('Optimal Consumption')\n#\nax[1].plot(koptv, '-o')\nax[1].set_ylabel(r'$k_t$')\nax[1].set_xlabel('Period t')\nax[1].set_title('Cake size')\n#\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# Create a 2x1 subplot\npar(mfrow = c(2, 1))\n\n# Plot optimal consumption\nplot(coptv, type = 'o', ylab = expression('c[t]'), xlab = 'Period t', main = 'Optimal Consumption')\n\n# Plot cake size\nplot(koptv, type = 'o', ylab = expression('k[t]'), xlab = 'Period t', main = 'Cake Size')",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Constrained Optimization</span>"
    ]
  },
  {
    "objectID": "Optimization-2-Cake.html#numerical-solution-in-python",
    "href": "Optimization-2-Cake.html#numerical-solution-in-python",
    "title": "\n21  Constrained Optimization\n",
    "section": "\n21.7 Numerical Solution in Python",
    "text": "21.7 Numerical Solution in Python\n\nFor a numerical solution we use the optimize package\nThe routine fmin_slsqp minimizes constrained non-linear functions. More specifically it minimizes a function using Sequential Least SQuares Programming hence the name _slsqp.\n\n\n\n\n\n\n\nImportant\n\n\n\n\nI recommend getting into the habit of reading the documentation for functions of libraries so that you learn how to use them correctly as well as the different ways of their application.\nHere is the link: Scipy Documentation for fmin_slsqp\n\n\n\n\n\nThe constraints can be equality or inequality constraints\nOur problem has one equality constraint:\nWe start by defining the functions that we would like to optimize, which is basically present value welfare, or the present value of all future utilities added up. We define this welfare stream from consumption as f_welf.\n\n\\[\\sum_{t=0}^{T}\\beta^{t} U(c_t)\\]\n\n\nPython Code\nR Code\n\n\n\n\ndef f_welf(cv):\n    T = len(cv)\n    uv= np.zeros(T,float)\n    for i in range(T):\n        beta = 0.96\n        # Period utility with discounting\n        uv[i] = (beta**i) * np.log(cv[i])\n\n    # We want to maximize this welfare,\n    # so we need to 'negate' the result\n    return (-np.sum(uv))\n\n\n\n\n# Welfare function to be maximized\nf_welf &lt;- function(cv) {\n  T &lt;- length(cv)\n  uv &lt;- rep(0, T)\n  for (i in 1:T) {\n    beta &lt;- 0.96\n    # Period utility with discounting\n    uv[i] &lt;- (beta^i) * log(cv[i])\n  }\n\n  # Maximize the welfare by minimizing the negative sum\n  return(-sum(uv))\n}\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nWe want to maximize welfare. Since the routine we will be calling is a minimization routine, we need to define the negative welfare function. Minimizing this negative function, will maximize welfare.\n\n\nThe constraint needs to be defined as function as well. We therefore define the constraint as f_const1. This basically states that you cannot eat more than the cake itself.\n\\[c_0+c_1+...+c_T=k_0\\]\n\n\nPython Code\nR Code\n\n\n\n\n# The constraint\ndef f_constr1(cv):\n    k0 = 100\n    z1 = np.sum(cv) - k0\n    return np.array([z1])\n\n\n\n\nf_constr1 &lt;- function(cv) {\n  k0 &lt;- 100\n  z1 &lt;- sum(cv) - k0\n  return(z1)\n}\n\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\nNote that the constraint function has the same input argument (i.e., the vector of consumptions for each period) as the welfare function that we want to maximize.\n\n\nWe finally call the optimizer routine fmin_slsqp handing in the function we want to maximize f_welf, the starting values (guesses) for consumption in each period c0v and the constraints function f_constr1.\n\n\nPython Code\nR Code\n\n\n\n\nT = 10\n\n# Starting guesses for the optimal consumption vector\nc0v = np.ones(T,float)*0.1\n\ncopt_numv = optimize.fmin_slsqp(f_welf, c0v, f_eqcons = f_constr1)\n\nOptimization terminated successfully    (Exit mode 0)\n            Current function value: -19.351131201280168\n            Iterations: 6\n            Function evaluations: 66\n            Gradient evaluations: 6\n\nprint(copt_numv)\n\n[11.90586733 11.44702338 11.00252664 10.57170585 10.15394251  9.74861554\n  9.35514463  8.97302557  8.60163014  8.2405184 ]\n\n\n\n\n\n# Load the `nloptr` package for optimization\nlibrary(nloptr)\n\nT &lt;- 10\n\n# Starting guesses for the optimal consumption vector\nc0v &lt;- rep(4.0, T)\n\n# Set optimization options.\nlocal_opts &lt;- list(\"algorithm\" = \"NLOPT_LN_COBYLA\",\n                   \"xtol_rel\"=1.0e-6)\n# Add top options\nopts &lt;- list(\"algorithm\" = \"NLOPT_LN_AUGLAG\",\n             \"xtol_rel\" = 1.0e-6, \"local_opts\" = local_opts, \"maxeval\" = 200)\n\n# Optimize with default settings\nopt_res &lt;- nloptr(x0 = c0v, eval_f = f_welf, eval_g_eq = f_constr1, opts = opts)\n\ncopt_numv &lt;- opt_res$solution\n\ncat(copt_numv)\n\n12.12393 11.38157 10.94359 10.54904 10.29503 9.727623 9.34719 9.09815 8.813078 8.752326\n\n\n\n\n\nAnd finally we plot the optimal consumption path coptv that we just solved for.\n\n\nPython Code\nR Code\n\n\n\n\nfig, ax = plt.subplots()\n# Plot analytical solution\nax.plot(np.arange(0,T), coptv, 'b-o')\n# Plot numerical solution\nax.plot(np.arange(0,T), copt_numv, 'r--o')\nax.set_title(\"Optimal consumption\")\nax.set_xlabel(\"Period t\")\nax.set_ylabel(r\"$c_t$\")\n# Create a legend\nax.legend(['analytical', 'numerical'], loc='best', shadow=True)\n\n\n\n\n\n\n\n\n\n\n# Create a sequence for the x-axis (periods)\nt &lt;- 1:T\n\n# Plot the analytical solution\nplot(t, coptv, type = \"o\", col = \"blue\", xlab = \"Period t\", ylab = expression(\"c\"[t]),\n     main = \"Optimal consumption\")\n\n# Add the numerical solution to the plot\nlines(t, copt_numv, type = \"o\", col = \"red\", pch = 2)\n\n# Add a legend\nlegend(\"topright\", legend = c(\"analytical\", \"numerical\"), col = c(\"blue\", \"red\"), lty = 1, pch = 2)\n\n\n\n\n\n\n\n\n\n\nWe can also print the results to see it more clearly.\n\n\nPython Code\nR Code\n\n\n\n\nnp.set_printoptions(formatter={'float': lambda x: \"{0:0.4f}\".format(x)})\nprint('-----------------------------')\nprint('Analytic solution')\nprint('-----------------------------')\nprint('coptv = {}'.format(coptv))\nprint(' ')\nprint('-----------------------------')\nprint('Numeric solution')\nprint('-----------------------------')\nprint('copt_numv = {}'.format(copt_numv))\nprint('-----------------------------')\n\n-----------------------------\nAnalytic solution\n-----------------------------\ncoptv = [11.9343 11.4570 10.9987 10.5587 10.1364 9.7309 9.3417 8.9680 8.6093\n 8.2649]\n \n-----------------------------\nNumeric solution\n-----------------------------\ncopt_numv = [11.9059 11.4470 11.0025 10.5717 10.1539 9.7486 9.3551 8.9730 8.6016\n 8.2405]\n-----------------------------\n\n\n\n\n\noptions(digits = 4)  # Set the number of digits to display\n\ncat(\"-----------------------------\\n\")\ncat(\"Analytic solution\\n\")\ncat(\"-----------------------------\\n\")\ncat(\"coptv = \", coptv, \"\\n\\n\")\n\ncat(\"-----------------------------\\n\")\ncat(\"Numeric solution\\n\")\ncat(\"-----------------------------\\n\")\ncat(\"copt_numv = \", copt_numv, \"\\n\")\ncat(\"-----------------------------\\n\")\n\n-----------------------------\nAnalytic solution\n-----------------------------\ncoptv =  11.93 11.46 11 10.56 10.14 9.731 9.342 8.968 8.609 8.265 \n\n-----------------------------\nNumeric solution\n-----------------------------\ncopt_numv =  12.12 11.38 10.94 10.55 10.3 9.728 9.347 9.098 8.813 8.752 \n-----------------------------\n\n\n\n\n\nWe can now see that the numerical solution is very close to the analytical solution we derived 'by hand' above. The optimal consumption path is decreasing. You start out eating a lot of cake and then gradually decrease your consumption. Still, you want to eat a bit of cake every period.\nLet us see whether we can increase the accuracy of the solution by allowing for more iterations and choosing a smaller optimization tolerance criteria.\n\n\nPython Code\nR Code\n\n\n\n\nT = 10\n# Starting guesses for the optimal consumption vector\nc0v = np.ones(T,float)*0.1\n\ncopt_num2v = optimize.fmin_slsqp(f_welf, c0v, f_eqcons = f_constr1, \\\n        iter=200, acc=1e-08)\n\nprint('--------------------------------------------------------')\nprint('Analytic solution: Default iterations and tolerance')\nprint('--------------------------------------------------------')\nprint('coptv = {}'.format(coptv))\nprint(' ')\nprint('--------------------------------------------------------')\nprint('Numeric solution I:')\nprint('copt_numv = {}'.format(copt_numv))\nprint(' ')\nprint('--------------------------------------------------------')\nprint('Numeric solution II: More iterations and smaller tolerance')\nprint('--------------------------------------------------------')\nprint('copt_num2v = {}'.format(copt_num2v))\nprint('--------------------------------------------------------')\n\nOptimization terminated successfully    (Exit mode 0)\n            Current function value: -19.351141900757867\n            Iterations: 14\n            Function evaluations: 154\n            Gradient evaluations: 14\n--------------------------------------------------------\nAnalytic solution: Default iterations and tolerance\n--------------------------------------------------------\ncoptv = [11.9343 11.4570 10.9987 10.5587 10.1364 9.7309 9.3417 8.9680 8.6093\n 8.2649]\n \n--------------------------------------------------------\nNumeric solution I:\ncopt_numv = [11.9059 11.4470 11.0025 10.5717 10.1539 9.7486 9.3551 8.9730 8.6016\n 8.2405]\n \n--------------------------------------------------------\nNumeric solution II: More iterations and smaller tolerance\n--------------------------------------------------------\ncopt_num2v = [11.9320 11.4575 11.0004 10.5604 10.1372 9.7305 9.3403 8.9663 8.6085\n 8.2669]\n--------------------------------------------------------\n\n\n\n\n\n# Load the `nloptr` package for optimization\nlibrary(nloptr)\n\nT &lt;- 10\n\n# Starting guesses for the optimal consumption vector\nc0v &lt;- rep(4.0, T)\n\nlocal_opts &lt;- list(\"algorithm\" = \"NLOPT_LN_COBYLA\",\n                   \"xtol_rel\"=1.0e-8)\n\n# Set optimization options.\nopts &lt;- list(\"algorithm\" = \"NLOPT_LN_AUGLAG\",\n             \"xtol_rel\" = 1.0e-8, \"local_opts\" = local_opts, \"maxeval\" = 400)\n\n\n# Optimize with default settings\nopt_res &lt;- nloptr(x0 = c0v, eval_f = f_welf, eval_g_eq = f_constr1, opts = opts)\n\ncopt_num2v &lt;- opt_res$solution\n\n# Display results\ncat('--------------------------------------------------------\\n')\ncat('Analytic solution: \\n')\ncat('--------------------------------------------------------\\n')\ncat('coptv = ', coptv, '\\n')\ncat('--------------------------------------------------------\\n')\ncat('Numeric solution I:\\n')\ncat('copt_numv = ', copt_numv, '\\n')\ncat('--------------------------------------------------------\\n')\ncat('Analytic solution: More iterations and smaller tolerance\\n')\ncat('--------------------------------------------------------\\n')\ncat('copt_num2v = ', copt_num2v, '\\n')\ncat('--------------------------------------------------------\\n')\n\n--------------------------------------------------------\nAnalytic solution: \n--------------------------------------------------------\ncoptv =  11.93 11.46 11 10.56 10.14 9.731 9.342 8.968 8.609 8.265 \n--------------------------------------------------------\nNumeric solution I:\ncopt_numv =  12.12 11.38 10.94 10.55 10.3 9.728 9.347 9.098 8.813 8.752 \n--------------------------------------------------------\nAnalytic solution: More iterations and smaller tolerance\n--------------------------------------------------------\ncopt_num2v =  11.94 11.47 11.01 10.57 10.13 9.729 9.362 8.967 8.596 8.305 \n--------------------------------------------------------\n\n\n\n\n\nWe can see that our numerical solution is now more accurate and much closer to the analytic solution.\n\n\n\n\n\n\nImportant\n\n\n\nThere is a trade off between accuracy and computational time. Here it is not an issue, but in bigger (large scale) optimization problems, computation time is often a factor.\n\n\n\n\n\n\n\n\nKey Concepts and Summary\n\n\n\n\nCake eating dynamic problem\n\n\n\n\n\n\n\n\n\nSelf-check questions\n\n\n\n\n\n\nChange the number of periods in the model and plot the optimal path of cake consumption",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Constrained Optimization</span>"
    ]
  },
  {
    "objectID": "OLG-I.html",
    "href": "OLG-I.html",
    "title": "\n22  A Simple OLG Model\n",
    "section": "",
    "text": "22.1 Formal Definition of the Model\nPreferences\n\\[V(c_y, c_o) = u(c_y) + \\beta \\times u(c_o)\\]\nTechnology\n\\[Y = F(K,L) = A \\times K^{\\alpha} \\times L^{(1-\\alpha)}\\]\nThis equation represents revenue minus the cost of production.\nGovernment\nHousehold problem\nwhere \\(R = (1 +(1-\\tau_K) \\times r)\\) is the after tax gross interest rate.",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>A Simple OLG Model</span>"
    ]
  },
  {
    "objectID": "OLG-I.html#formal-definition-of-the-model",
    "href": "OLG-I.html#formal-definition-of-the-model",
    "title": "\n22  A Simple OLG Model\n",
    "section": "",
    "text": "Agents live for 2 periods: young and old\nThere are \\(N_y\\) young households and \\(N_o\\) old households\nThey value consumption when young \\(c_y\\) and consumption when old \\(c_o\\)\n\nTheir preferences are given via utility functions: \\(u_t(c_t)\\)\n\nIndividuals have a time preference parameter (often referred to as time discount factor) \\(\\beta\\)\n\nTheir life-time utility is:\n\n\n\n\nFirms produce output \\(Y\\) using input capital \\(K\\) and labor \\(L\\):\n\n\n\n\nFirms maximize profits:\n\\[\\max_{K,L} \\{F(K,L) - w \\times L - q \\times K \\}\\]\n\n\n\n\n\nRevenue in dollars is \\(\\$1 \\times F(K,L)\\) where the \\(\\$1\\) is the normalized price of the consumption good.\nThe cost of production is the wage cost and the capital rental cost where \\(w\\) are wages and \\(q\\) is the factor price (or rental rate) of capital\n\n\n\n\nThe government collects taxes on labor \\(\\tau_L\\) and capital interest \\(\\tau_K\\)\n\nThe government pays for gov't consumption \\(G\\) and transfers to households \\(T_y\\) and \\(T_o\\)\n\\[G + T_y + T_o =  \\tau_L \\times w \\times L + \\tau_K \\times r \\times K\\]\n\n\n\n\n\nHHs maximize \\(V(c_y,c_o)\\) subject to their budget constraint in each period\n\\[\\max_{c_y, c_o, s}  \\{ u(c_y) + \\beta \\times u(c_o) \\}\\]\\[s.t.\\]\\[c_y + s = (1-\\tau_L) w + t_y\\]\\[c_o = R \\times s + t_o\\]",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>A Simple OLG Model</span>"
    ]
  },
  {
    "objectID": "OLG-I.html#equilibrium-definition",
    "href": "OLG-I.html#equilibrium-definition",
    "title": "\n22  A Simple OLG Model\n",
    "section": "\n22.2 Equilibrium Definition",
    "text": "22.2 Equilibrium Definition\nThe definition of the competitive equilibrium is:\n\n\nGiven sequences of\n\n\nprices \\(\\left\\{w_t, R_t \\right\\}\\)\n\ngovernment policies \\(\\left\\{\\tau_K, \\tau_{L} \\right\\}\\) a\n\ncompetitive equilibrium is defined as an allocation of:\n\n\n\n\n\n\nsequences of \\(\\left\\{c_{y,t},c_{o,t},s_t\\right\\}\\) so that\n\n\nthe HH max problem is solved\nthe firm maximization problem is solved, so that\nthe gov't budget constraint clears\n\nMarkets clear:\n\n\n\\(K=S = N_y * s^*\\)\n\\(ARC: C + S +G = Y + (1-\\delta) K\\)",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>A Simple OLG Model</span>"
    ]
  },
  {
    "objectID": "OLG-I.html#functional-forms-and-solutions",
    "href": "OLG-I.html#functional-forms-and-solutions",
    "title": "\n22  A Simple OLG Model\n",
    "section": "\n22.3 Functional Forms and Solutions",
    "text": "22.3 Functional Forms and Solutions\n\nPreferences are given as: \\(u(c_y) = \\ln(c_y)\\) and \\(u(c_o)=\\ln(c_o)\\)\n\nWe can either set up a Lagrangian with two constraints or simply substitute consumption out of the utilities using the BC.\nWe follow the second approach, since the form of the utility functions guarantees interior solutions\nTherefore we don't have to worry about corner solutions a la Kuhn-Tucker\n\nStep 1: Substitute the budget set into preferences\n\n\\[max_s \\ln( (1-\\tau_L)w + t_y - s)  + \\beta  \\ln(R s + t_o)\\]\n\nThis is now a function in 1 choice variable \\(s\\)\n\nDerive this function w.r.t. \\(s\\)\n\n\n\\[\\frac{\\partial V}{\\partial s}: \\frac{1}{ (1-\\tau_L)w + t_y - s} =\n\\frac{\\beta R}{R  s + t_o}\\]\n\nStep 2: Solve for optimal household savings \\(s^*\\)**\n\n\\[s^* = \\frac{\\beta R ((1-\\tau_L)w + t_y) - t_o}{(1+\\beta)R}\\]\n\nIn equilibrium household savings equals the capital stock: \\(S = K\\)\n\nAggregate capital stock is therefore: \\(K = S = N_y \\times s^*\\)\n\nGiven parameter \\(\\beta\\), gov't policies \\(\\tau_K, \\tau_L, t_y, t_o\\)\n\nMeasures of young and old agents \\(N_y, N_o\\) we can now solve for a steady state equilibrium\nThe solution is represented by the following equation system\n\n\nStep 3: Solve the firm problem for demands of labor and capital\n\n\\[\\max_{K,L} \\{F(K,L) - w \\times L - q \\times K \\}\\]\n\n\nDerive w.r.t. \\(L\\) and \\(K\\) and get:\n\n\n\\(q = F_K\\)\n\\(w = F_L\\)\n\n\nwhich given the Cobb-Douglas form of the production function (\\(Y = F(K,L) =\nA \\times K^{\\alpha} \\times L^{1-\\alpha}\\)) is:\n\n\n\\(q = \\alpha \\times A \\times K^{\\alpha-1} \\times L^{(1-\\alpha)} = \\alpha \\times Y/K\\)\n\\(w =  (1-\\alpha) \\times A \\times K^{\\alpha} \\times * L^{(1-\\alpha-1)} = (1-\\alpha) \\times Y/L\\)\n\n\n\n\nFrom the equilibrium conditions we also know that households receive an effective return on lending their capital to the firms of\n\n\n\n\\(r = q - \\delta\\) is the interest rate\n\n\nas capital also depreciates when it is lent to firms for production. From this return (or interest) the government wants its share as well, so that the after tax interest rate for the household in the household problem above is\n\n\n\n\\(R = (1 +(1-\\tau_K)(q - \\delta))\\) is the after tax gross interest rate\n\n\n\n\n\nStep 4: Equation system\n\n\nAssume \\(L=1\\) we have the following unknowns: \\(K,Y,R,w,q\\) and the following equation.\nA solution exists if the number of unknowns is equal to the number of equations!\n\n\\[K=N_y s^* = N_y \\frac{\\beta R ((1-\\tau_L)w + t_y) - t_o}{(1+\\beta)R}\\]\n\\[\\alpha \\times Y/K = q\\]\n\\[(1-\\alpha) \\times Y/L = w\\]\n\\[Y = A \\times K^{\\alpha} L^{(1-\\alpha)}\\]\n\\[R = (1 + (1-\\tau_K)(q - \\delta))\\]\n\nWe will try to reduce the equation system into as few equations as possible, ideally into one non-linear equation that we can then solve with a Newton Algorithm\n\nFor starters we assume that government is completely exogenous.",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>A Simple OLG Model</span>"
    ]
  },
  {
    "objectID": "OLG-I.html#method-1-substituting-everything",
    "href": "OLG-I.html#method-1-substituting-everything",
    "title": "\n22  A Simple OLG Model\n",
    "section": "\n22.4 Method 1: Substituting Everything",
    "text": "22.4 Method 1: Substituting Everything\n\n\n\n\n\n\nNote\n\n\n\nNote that \\(L=1\\) because household time endowments are \\(l=1\\) and we have \\(L = N_y \\times l\\) and \\(N_y\\) is also normalized to be one.\n\n\n\n\nSubstitute \\(Y\\) out of the system of equations and get\n\\[q(K) = \\alpha \\times \\frac{A \\times  K^{\\alpha} L^{(1-\\alpha)}}{K}\\]\n\\[w(K) = (1-\\alpha) \\times \\frac{A \\times  K^{\\alpha} L^{(1-\\alpha)}}{L}\\]\n\n\nAfter using \\(q(K)\\) in the expression for \\(R\\) above and some simplifications we get two expressions for prices \\(w\\) and \\(R\\):\n\\[w = (1-\\alpha) \\times A \\times K^{\\alpha}\\]\\[R = 1 + (1-\\tau_K)(\\alpha \\times A \\times K^{\\alpha-1} - \\delta)\\]\n\n\nWe have now effectively reduced the equation system of 5 equations in 5 unknown variables into a 3 equations system with only 3 unknown variables \\(K,w,q\\):\n\\[K = N_y \\frac{\\beta R ((1-\\tau_L)w + t_y) - t_o}{(1+\\beta)R}\\]\\[w = (1-\\alpha) \\times A \\times K^{\\alpha}\\]\\[R = 1 + (1-\\tau_K)(\\alpha \\times A \\times K^{\\alpha-1} - \\delta)\\]\n\nWe further substitute \\(w(K)\\) and \\(R(K)\\) into \\(K\\)-equation and now have one equation in one unknown \\(K\\)\n\n\n\n\n\n\n\nNote\n\n\n\nThis is a non-linear equation in \\(K\\) that can be solved with a root-finding algorithm!\n\\[K= N_y \\frac{\\beta (1 + (1-\\tau_K)(\\alpha A K^{\\alpha-1} - \\delta))\n((1-\\tau_L)((1-\\alpha) A K^{\\alpha}) + t_y) - t_o}\n{(1+\\beta)(1 + (1-\\tau_K)(\\alpha A K^{\\alpha-1} - \\delta))}\\]\nDefine the following function \\(F(K)\\)\n\\[F(K) = -K + N_y \\frac{\\beta (1 + (1-\\tau_K)(\\alpha A K^{\\alpha-1} - \\delta))\n((1-\\tau_L)((1-\\alpha) A K^{\\alpha}) + t_y) - t_o}\n{(1+\\beta)(1 + (1-\\tau_K)(\\alpha A K^{\\alpha-1} - \\delta))}\\]\nand search for the \\(K\\) so that this function is \\(F(K) = 0\\).\n\n\nModel Parameters\n\nIn order to find the root of this function we first have to set the parameters of the model.\nModel parameters: \\(N_y=N_o=1\\), \\(\\alpha=0.3\\), \\(A=1\\), \\(\\beta = 0.9\\), \\(\\delta=0.1\\)\n\nWe assumed that government was exogenous, so here are some government parameters: \\(\\tau_L=0.2\\), \\(\\tau_K=0.15\\), \\(T_y=T_o=t_y=t_o=0\\)\n\nSolve for \\(K^*\\) and then back out \\(q^*(K^*),w^*(K^*),R^*(K^*), Y^*(K^*)\\) which are all functions of \\(K^*\\)\n\n\nAggregate resource constraint (ARC)\n\n\nAggregate consumption is:\n\\[C = N_y \\times c_y + N_o \\times c_o\\]\n\n\nAggregate government consumption is:\n\\[G = \\tau_L \\times w \\times L + \\tau_K \\times r \\times K - N_y \\times t_y - N_o \\times t_o\\]\n\nThe aggregate resource constraint (ARC) or goods market clearing condition is: \\[C + N_y \\times s + G = Y + (1-\\delta)K\\]\n\n\n\n\n\n\n\nWarning\n\n\n\n\nWhile the ARC is not part of the solution algorithm directly, it is good practice to always check whether the ARC holds!\nIf it doesn't, there's something wrong with your solution!\n\n\n\nPython Program 1\n\n\nPython Code\nR Code\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport math as m\nfrom scipy import stats as st\nimport time            # Imports system time module to time your script\n\nplt.close('all')  # close all open figures\n\n\n# -----------------------------------------------\n# Root finding\n# -----------------------------------------------\n\n# Set parameter values\nN_y     = 1.0\nN_o     = 1.0\nalpha   = 0.3\nA       = 1\nbeta    = 0.9\ndelta   = 0.0\ntau_L   = 0.2\ntau_K   = 0.15\nt_y     = 0.0\nt_o     = 0.0\n#\nL       = 1\n\n# -------------------------------------------------------------\n# Method 1: Root finding\n# -------------------------------------------------------------\n# Find x so that f(x) = 0\n\n# Define function of capital K so that f_func(K) = 0\n\ndef f_func(K):\n    s = - K + N_y\\\n    *((beta*(1+(1-tau_K)*(alpha*A*K**(alpha-1) - delta))* \\\n    ((1-tau_L)*((1-alpha)*A*K**alpha) + t_y) - t_o) \\\n    /((1+beta)*(1. + (1-tau_K)*(alpha*A*K**(alpha-1) - delta))))\n\n    return s\n\n# Plot the function to see whether it has a root-point\nKmin = 0.0001\nKmax = 0.3\n\n# Span grid with gridpoints between Kmin and Kmax\nKv = np.linspace(Kmin, Kmax, 200)\n\n# Output vector prefilled with zeros\nfKv = np.zeros(len(Kv),float) # define column vector\n\nfor i,K in enumerate(Kv):\n    fKv[i] = f_func(K)\n\n#print(\"fK=\", fK)\n\n\n\n\n# Load required libraries\nlibrary(ggplot2)\n\n# -----------------------------------------------\n# Root finding\n# -----------------------------------------------\n\n# Set parameter values\nN_y &lt;- 1.0\nN_o &lt;- 1.0\nalpha &lt;- 0.3\nA &lt;- 1\nbeta &lt;- 0.9\ndelta &lt;- 0.0\ntau_L &lt;- 0.2\ntau_K &lt;- 0.15\nt_y &lt;- 0.0\nt_o &lt;- 0.0\nL &lt;- 1\n\n# -------------------------------------------------------------\n# Method 1: Root finding\n# -------------------------------------------------------------\n# Find x so that f(x) = 0\n\n# Define function of capital K so that f_func(K) = 0\nf_func &lt;- function(K) {\n    s &lt;- -K + N_y * ((beta * (1 + (1 - tau_K) * (alpha * A * K^(alpha - 1) - delta)) *\n        ((1 - tau_L) * ((1 - alpha) * A * K^alpha) + t_y) - t_o) /\n        ((1 + beta) * (1 + (1 - tau_K) * (alpha * A * K^(alpha - 1) - delta))))\n    return(s)\n}\n\n# Plot the function to see whether it has a root-point\nKmin &lt;- 0.0001\nKmax &lt;- 0.3\n\n# Create a grid of gridpoints between Kmin and Kmax\nKv &lt;- seq(Kmin, Kmax, length = 200)\n\n# Initialize a vector with zeros\nfKv &lt;- rep(0, length(Kv))\n\nfor (i in 1:length(Kv)) {\n    fKv[i] &lt;- f_func(Kv[i])\n}\n\n\n\n\nLet us plot this function now for different values of capital \\(K\\) to see where the root of this function is:\n\n\nPython Code\nR Code\n\n\n\n\nfig, ax = plt.subplots()\nax.plot(Kv, fKv)\n# Plot horizontal line at zero in red\nax.plot(Kv, np.zeros(len(Kv)), 'r')\nax.set_title('Capital')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# Create a data frame for plotting\ndf &lt;- data.frame(K = Kv, fK = fKv)\n\n# Plot the function\nggplot(df, aes(x = K, y = fK)) +\n    geom_line() +\n    labs(title = \"Function for Root Finding\", x = \"K\", y = \"f(K)\") +\n    theme_minimal()\n\n\n\n\n\n\n\n\n\n\nFrom the graph we see that optimal capital is roughly around 0.15. We next use the fsolve root finding algorithm from the scipy.optimize library.\nGo back to the chapter on root finding and review the various root finding algorithms such as Newton-Raphson, Secant Method, Bracketing as well as the built in root and fsolve.\n\n\nPython Code\nR Code\n\n\n\n\nfrom scipy.optimize import fsolve\n\n# Use built in 'fsolve'\nprint(\" \")\nprint(\" -------------- Fsolve ------------\")\n\nk_guess = 2  # our starting guess\nsolutionK = fsolve(f_func, k_guess) # starting from K = 2\n\n# Kstar is a numpy array which does not print well\n# We therefore change it into a 'pure' number\n# so we can use the print format to create a nice\n# looking output\nKstar = solutionK[0]\n\nYstar = A*Kstar**alpha*L**(1-alpha)\nqstar = alpha*A*Kstar**(alpha-1)\nrstar = qstar - delta\nRstar = 1. + (1-tau_K)*(qstar - delta)\nwstar = (1.-alpha)*A*Kstar**alpha\n\n# Back out solutions for the rest of the Economy\n# ----------------------------------------------\n# Household values\nsstar = Kstar/N_y\ncystar= (1.-tau_L)*wstar + t_y - sstar\ncostar= Rstar*sstar + t_o\n\n# Residual gov't consumption, thrown in the ocean\nGstar = N_y*tau_L*wstar + N_o*tau_K*rstar*sstar\n\n# Aggregate consumption\nCstar = N_y*cystar + N_o*costar\n\n# Check the goods market condition or Aggregate resource constraint\nARC = Ystar - delta*Kstar - Cstar - Gstar\n\n# Print results\nprint(\" -------------------------------------\")\nprint(\" Root finding \")\nprint(\" -------------------------------------\")\nprint(\"K* = {:6.4f}\".format(Kstar))\nprint(\"Y* = {:6.4f}\".format(Ystar))\nprint(\"q* = {:6.4f}\".format(qstar))\nprint(\"r* = {:6.4f}\".format(rstar))\nprint(\"R* = {:6.4f}\".format(Rstar))\nprint(\"w* = {:6.4f}\".format(wstar))\nprint(\" -------------------------------------\")\nprint(\"ARC = {:6.4f}\".format(ARC))\n\n \n -------------- Fsolve ------------\n -------------------------------------\n Root finding \n -------------------------------------\nK* = 0.1502\nY* = 0.5662\nq* = 1.1310\nr* = 1.1310\nR* = 1.9613\nw* = 0.3964\n -------------------------------------\nARC = 0.0000\n\n\n\n\n\nlibrary(rootSolve)\n\n# Initial guess\ninit_low = 0.1\ninit_high = 0.6\n\n# Find the root\nsolutionK &lt;- uniroot(f_func, interval = c(init_low, init_high))\n\n# Extract the roots\nKstar &lt;- solutionK$root\n\nYstar &lt;- A * Kstar^alpha * L^(1 - alpha)\nqstar &lt;- alpha * A * Kstar^(alpha - 1)\nrstar &lt;- qstar - delta\nRstar &lt;- 1 + (1 - tau_K) * (qstar - delta)\nwstar &lt;- (1 - alpha) * A * Kstar^alpha\n\n# Back out solutions for the rest of the Economy\n# ----------------------------------------------\n# Household values\nsstar &lt;- Kstar / N_y\ncystar &lt;- (1 - tau_L) * wstar + t_y - sstar\ncostar &lt;- Rstar * sstar + t_o\n\n# Residual gov't consumption, thrown in the ocean\nGstar &lt;- N_y * tau_L * wstar + N_o * tau_K * rstar * sstar\n\n# Aggregate consumption\nCstar &lt;- N_y * cystar + N_o * costar\n\n# Check the goods market condition or Aggregate resource constraint\nARC &lt;- Ystar - delta * Kstar - Cstar - Gstar\n\n# Print results\ncat(\" -------------------------------------\\n\")\ncat(\" Root finding\\n\")\ncat(\" -------------------------------------\\n\")\ncat(sprintf(\"K* = %6.4f\\n\", Kstar))\ncat(sprintf(\"Y* = %6.4f\\n\", Ystar))\ncat(sprintf(\"q* = %6.4f\\n\", qstar))\ncat(sprintf(\"r* = %6.4f\\n\", rstar))\ncat(sprintf(\"R* = %6.4f\\n\", Rstar))\ncat(sprintf(\"w* = %6.4f\\n\", wstar))\ncat(\" -------------------------------------\\n\")\ncat(sprintf(\"ARC = %6.4f\\n\", ARC))\n\n -------------------------------------\n Root finding\n -------------------------------------\nK* = 0.1502\nY* = 0.5662\nq* = 1.1310\nr* = 1.1310\nR* = 1.9613\nw* = 0.3964\n -------------------------------------\nARC = 0.0000",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>A Simple OLG Model</span>"
    ]
  },
  {
    "objectID": "OLG-I.html#method-2-gauss-seidl-algorithm",
    "href": "OLG-I.html#method-2-gauss-seidl-algorithm",
    "title": "\n22  A Simple OLG Model\n",
    "section": "\n22.5 Method 2: Gauss-Seidl Algorithm",
    "text": "22.5 Method 2: Gauss-Seidl Algorithm\nInstead of substituting and solving for one equation in one unknown we can use the so called Gauss-Seidl method.\nIt is an iterative method where we guess a starting value for capital. We then use this starting guess as if it was a solution to the model and back out all the other endogenous variables.\nWe then use these \"solutions\" of endogenous variables and calculate the new capital that would be the result of household savings and consumption decisions.\nWe then update our first guess of capital K, with this new and better guess and do it all over again.\nWe repeat this until the guess of capital at the beginning of the algorithm is roughly the same as the calculated capital at the end of the algorithm. This is a referred to as a fixed point (once Knew = Kold).\nHere is the algorithm in more detail:\n\n\n\n\n\n\nGauss-Seidl Algorithm\n\n\n\n\nStep 1.\n\nFor this method we start with a guess for capital \\(K_{old}\\)\n\nStep 2.\n\nWe then solve for prices \\(w,R,q\\)\n\\[w = (1-\\alpha)*K_{old}^{\\alpha} \\times L^{-\\alpha}\\]\n\\[q = \\alpha \\times A \\times K_{old}^{(\\alpha-1)} \\times L^{1-\\alpha}\\]\n\\[R = 1 + (1-\\tau_K)(q - \\delta)\\]\n\nStep 3.\n\nWe then solve for optimal household savings \\(s^*\\)\n\\[s^* = N_y \\frac{\\beta R ((1-\\tau_L)w + t_y) - t_o}{(1+\\beta)R}\\]\n\nStep 4.\n\nWe then aggregate over all households and get the new capital stock \\(K_{new}\\)\n\\[K_{new}=N_y \\times s^*\\]\n\nStep 5.\n\nCalculate error and check whether algorithm has converged\n\\[\\text{error} = (K_{old} - K_{new})/K_{old}\\]\n\nStep 6.\n\nWe then update capital \\(K_{old} = \\lambda * K_{new} + (1-\\lambda) *\nK_{old}\\) and repeat from Step 2 above. Note that \\(0 &lt; \\lambda &lt; 1\\) is an updating parameter.\n\n\n\n\nPython Program 2\n\n\nPython Code\nR Code\n\n\n\n\n# Guess capital stock\nglamda  = 0.5   # updating parameter\nKold    = 0.4\njerror  = 100\niter    = 1\nwhile (iter&lt;200) or (jerror&gt;0.001):\n    # Solve for prices using expressions for w(K) and q(K)\n    q = alpha*A*Kold**(alpha-1)\n    w = (1-alpha)*A*Kold**alpha\n    R = 1 + (1-tau_K)*(q - delta)\n    Knew = N_y* (beta*R*((1-tau_L)*w + t_y) - t_o)/((1+beta)*R)\n    # Calculate discrepancy between old and new capital stock\n    jerror = abs(Kold-Knew)/Kold\n    # Update capital stock\n    Kold    = glamda*Knew + (1-glamda)*Kold\n    iter = iter +1\n\n# Print results\nKstar = Knew\nYstar = A*Kstar**alpha*L**(1-alpha)\nwstar = w\nqstar = q\nRstar = R\nrstar = qstar - delta\n\n# ------------------------------------\n# Back out solutions for the rest of the Economy\n\n# Household values\nsstar = Kstar/N_y\ncystar= (1-tau_L)*wstar + t_y - sstar\ncostar= Rstar*sstar + t_o\n\n# Residual gov't consumption, thrown in the ocean\nGstar = N_y*tau_L*wstar + N_o*tau_K*rstar*sstar\n\n# Aggregate consumption\nCstar = N_y*cystar + N_o*costar\n\n# Check the goods market condition or Aggregate resource constraint\nARC = Ystar - delta*Kstar - Cstar - Gstar\n\nprint(\" -------------------------------------\")\nprint(\" Gauss-Seidl \")\nprint(\" -------------------------------------\")\nprint(\"Nr. of iterations = \" +str(iter))\nprint(\"K* = {:6.4f}\".format(Kstar))\nprint(\"Y* = {:6.4f}\".format(Ystar))\nprint(\"q* = {:6.4f}\".format(qstar))\nprint(\"r* = {:6.4f}\".format(rstar))\nprint(\"R* = {:6.4f}\".format(Rstar))\nprint(\"w* = {:6.4f}\".format(wstar))\nprint(\" -------------------------------------\")\nprint(\"ARC = {:6.4f}\".format(ARC))\n\n -------------------------------------\n Gauss-Seidl \n -------------------------------------\nNr. of iterations = 200\nK* = 0.1502\nY* = 0.5662\nq* = 1.1310\nr* = 1.1310\nR* = 1.9613\nw* = 0.3964\n -------------------------------------\nARC = 0.0000\n\n\n\n\n\n# Guess capital stock\nglamda &lt;- 0.5   # updating parameter\nKold &lt;- 0.4\njerror &lt;- 100\niter &lt;- 1\nwhile (iter &lt; 200 || jerror &gt; 0.001) {\n    # Solve for prices using expressions for w(K) and q(K)\n    q &lt;- alpha * A * Kold^(alpha - 1)\n    w &lt;- (1 - alpha) * A * Kold^alpha\n    R &lt;- 1 + (1 - tau_K) * (q - delta)\n    Knew &lt;- N_y * (beta * R * ((1 - tau_L) * w + t_y) - t_o) / ((1 + beta) * R)\n    # Calculate the discrepancy between old and new capital stock\n    jerror &lt;- abs(Kold - Knew) / Kold\n    # Update capital stock\n    Kold &lt;- glamda * Knew + (1 - glamda) * Kold\n    iter &lt;- iter + 1\n}\n\n# Print results\nKstar &lt;- Knew\nYstar &lt;- A * Kstar^alpha * L^(1 - alpha)\nwstar &lt;- w\nqstar &lt;- q\nRstar &lt;- R\nrstar &lt;- qstar - delta\n\n# Back out solutions for the rest of the Economy\n# Household values\nsstar &lt;- Kstar / N_y\ncystar &lt;- (1 - tau_L) * wstar + t_y - sstar\ncostar &lt;- Rstar * sstar + t_o\n\n# Residual gov't consumption, thrown in the ocean\nGstar &lt;- N_y * tau_L * wstar + N_o * tau_K * rstar * sstar\n\n# Aggregate consumption\nCstar &lt;- N_y * cystar + N_o * costar\n\n# Check the goods market condition or Aggregate resource constraint\nARC &lt;- Ystar - delta * Kstar - Cstar - Gstar\n\ncat(\" -------------------------------------\\n\")\ncat(\" Gauss-Seidl \\n\")\ncat(\" -------------------------------------\\n\")\ncat(\"Nr. of iterations = \", iter, \"\\n\")\ncat(\"K* = \", Kstar, \"\\n\")\ncat(\"Y* = \", Ystar, \"\\n\")\ncat(\"q* = \", qstar, \"\\n\")\ncat(\"r* = \", rstar, \"\\n\")\ncat(\"R* = \", Rstar, \"\\n\")\ncat(\"w* = \", wstar, \"\\n\")\ncat(\" -------------------------------------\\n\")\ncat(\"ARC = \", ARC, \"\\n\")\n\n -------------------------------------\n Gauss-Seidl \n -------------------------------------\nNr. of iterations =  200 \nK* =  0.1502039 \nY* =  0.566245 \nq* =  1.130952 \nr* =  1.130952 \nR* =  1.96131 \nw* =  0.3963715 \n -------------------------------------\nARC =  6.938894e-17",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>A Simple OLG Model</span>"
    ]
  },
  {
    "objectID": "OLG-I.html#tax-policy-simulation",
    "href": "OLG-I.html#tax-policy-simulation",
    "title": "\n22  A Simple OLG Model\n",
    "section": "\n22.6 Tax Policy Simulation",
    "text": "22.6 Tax Policy Simulation\nNow that we have solved the model for an equilibrium we can use this model to conduct policy simulations such as a tax policy reform. When we first solved this model the tax on labor was \\(\\tau_L = 20\\%\\). What would happen if the government were to raise the labor tax to \\(\\tau_L = 25\\%\\)?\nWell, just plug it in and resolve the model. Then compare the prior GDP (i.e. variable Y) to the new GDP.\n\nWhat has happened?\nMake before and after graphs (maybe a bar chart that shows Y, C, K before and after the tax increase) and discuss your results.\n\nPython Program 3: Gauss-Seidl after tax increase from 20 to 25%\n\n\nPython Code\nR Code\n\n\n\n\n# Set new parameter values\nN_y     = 1.0\nN_o     = 1.0\nalpha   = 0.3\nA       = 1\nbeta    = 0.9\ndelta   = 0.0\ntau_L   = 0.25  #Old value: tau_L   = 0.2\ntau_K   = 0.15\nt_y     = 0.0\nt_o     = 0.0\n#\nL       = 1\n\n# Guess capital stock\nglamda  = 0.5   # updating parameter\nKold    = 0.4\njerror  = 100\niter    = 1\nwhile (iter&lt;200) or (jerror&gt;0.001):\n    # Solve for prices using expressions for w(K) and q(K)\n    q = alpha*A*Kold**(alpha-1)\n    w = (1-alpha)*A*Kold**alpha\n    R = 1 + (1-tau_K)*(q - delta)\n    Knew = N_y* (beta*R*((1-tau_L)*w + t_y) - t_o)/((1+beta)*R)\n    # Calculate discrepancy between old and new capital stock\n    jerror = abs(Kold-Knew)/Kold\n    # Update capital stock\n    Kold    = glamda*Knew + (1-glamda)*Kold\n    iter = iter +1\n\n# Print results\nKstar_new = Knew\nYstar_new  = A*Kstar_new**alpha*L**(1-alpha)\nwstar_new  = w\nqstar_new  = q\nRstar_new  = R\nrstar_new  = q - delta\n\n# ------------------------------------\n# Back out solutions for the rest of the Economy\n\n# Household values\nsstar_new = Kstar_new/N_y\ncystar_new= (1-tau_L)*wstar_new + t_y - sstar_new\ncostar_new= Rstar_new*sstar_new + t_o\n\n# Residual gov't consumption, thrown in the ocean\nGstar_new = N_y*tau_L*wstar_new + N_o*tau_K*rstar_new*sstar_new\n\n# Aggregate consumption\nCstar_new = N_y*cystar_new + N_o*costar_new\n\n# Check the goods market condition or Aggregate resource constraint\nARC_new = Ystar_new - delta*Kstar_new - Cstar_new - Gstar_new\n\nprint(\" -------------------------------------\")\nprint(\" Gauss-Seidl: tau_L = 25% \")\nprint(\" -------------------------------------\")\nprint(\"Nr. of iterations = \" +str(iter))\nprint(\"K* = {:6.4f}\".format(Kstar_new))\nprint(\"Y* = {:6.4f}\".format(Ystar_new))\nprint(\"q* = {:6.4f}\".format(qstar_new))\nprint(\"r* = {:6.4f}\".format(rstar_new))\nprint(\"R* = {:6.4f}\".format(Rstar_new))\nprint(\"w* = {:6.4f}\".format(wstar_new))\nprint(\" -------------------------------------\")\nprint(\"ARC = {:6.4f}\".format(ARC_new))\n\n -------------------------------------\n Gauss-Seidl: tau_L = 25% \n -------------------------------------\nNr. of iterations = 200\nK* = 0.1370\nY* = 0.5508\nq* = 1.2063\nr* = 1.2063\nR* = 2.0254\nw* = 0.3856\n -------------------------------------\nARC = 0.0000\n\n\n\n\n\n# Set new parameter values\nN_y &lt;- 1.0\nN_o &lt;- 1.0\nalpha &lt;- 0.3\nA &lt;- 1\nbeta &lt;- 0.9\ndelta &lt;- 0.0\ntau_L &lt;- 0.25  # Old value: tau_L &lt;- 0.2\ntau_K &lt;- 0.15\nt_y &lt;- 0.0\nt_o &lt;- 0.0\nL &lt;- 1\n\n# Guess capital stock\nglamda &lt;- 0.5   # updating parameter\nKold &lt;- 0.4\njerror &lt;- 100\niter &lt;- 1\nwhile (iter &lt; 200 || jerror &gt; 0.001) {\n    # Solve for prices using expressions for w(K) and q(K)\n    q &lt;- alpha * A * Kold^(alpha - 1)\n    w &lt;- (1 - alpha) * A * Kold^alpha\n    R &lt;- 1 + (1 - tau_K) * (q - delta)\n    Knew &lt;- N_y * (beta * R * ((1 - tau_L) * w + t_y) - t_o) / ((1 + beta) * R)\n    # Calculate the discrepancy between old and new capital stock\n    jerror &lt;- abs(Kold - Knew) / Kold\n    # Update capital stock\n    Kold &lt;- glamda * Knew + (1 - glamda) * Kold\n    iter &lt;- iter + 1\n}\n\n# Print results\nKstar_new &lt;- Knew\nYstar_new &lt;- A * Kstar_new^alpha * L^(1 - alpha)\nwstar_new &lt;- w\nqstar_new &lt;- q\nRstar_new &lt;- R\nrstar_new &lt;- q - delta\n\n# Back out solutions for the rest of the Economy\n# Household values\nsstar_new &lt;- Kstar_new / N_y\ncystar_new &lt;- (1 - tau_L) * wstar_new + t_y - sstar_new\ncostar_new &lt;- Rstar_new * sstar_new + t_o\n\n# Residual gov't consumption, thrown in the ocean\nGstar_new &lt;- N_y * tau_L * wstar_new + N_o * tau_K * rstar_new * sstar_new\n\n# Aggregate consumption\nCstar_new &lt;- N_y * cystar_new + N_o * costar_new\n\n# Check the goods market condition or Aggregate resource constraint\nARC_new &lt;- Ystar_new - delta * Kstar_new - Cstar_new - Gstar_new\n\ncat(\" -------------------------------------\\n\")\ncat(\" Gauss-Seidl: tau_L = 25% \\n\")\ncat(\" -------------------------------------\\n\")\ncat(\"Nr. of iterations = \", iter, \"\\n\")\ncat(\"K* = \", Kstar_new, \"\\n\")\ncat(\"Y* = \", Ystar_new, \"\\n\")\ncat(\"q* = \", qstar_new, \"\\n\")\ncat(\"r* = \", rstar_new, \"\\n\")\ncat(\"R* = \", Rstar_new, \"\\n\")\ncat(\"w* = \", wstar_new, \"\\n\")\ncat(\" -------------------------------------\\n\")\ncat(\"ARC = \", ARC_new, \"\\n\")\n\n -------------------------------------\n Gauss-Seidl: tau_L = 25% \n -------------------------------------\nNr. of iterations =  200 \nK* =  0.1369747 \nY* =  0.5507977 \nq* =  1.206349 \nr* =  1.206349 \nR* =  2.025397 \nw* =  0.3855584 \n -------------------------------------\nARC =  8.326673e-17 \n\n\n\n\n\nDiscuss results.\n\n\nPython Code\nR Code\n\n\n\n\nprint(\" -------------------------------------\")\nprint(\" Gauss-Seidl: tau_L = 20% \")\nprint(\" -------------------------------------\")\nprint(\"K* = {:6.4f}\".format(Kstar))\nprint(\"Y* = {:6.4f}\".format(Ystar))\nprint(\"q* = {:6.4f}\".format(qstar))\nprint(\"r* = {:6.4f}\".format(rstar))\nprint(\"R* = {:6.4f}\".format(Rstar))\nprint(\"w* = {:6.4f}\".format(wstar))\n\nprint(\" -------------------------------------\")\nprint(\" Gauss-Seidl: tau_L = 25% \")\nprint(\" -------------------------------------\")\nprint(\"K* = {:6.4f}\".format(Kstar_new))\nprint(\"Y* = {:6.4f}\".format(Ystar_new))\nprint(\"q* = {:6.4f}\".format(qstar_new))\nprint(\"r* = {:6.4f}\".format(rstar_new))\nprint(\"R* = {:6.4f}\".format(Rstar_new))\nprint(\"w* = {:6.4f}\".format(wstar_new))\nprint(\" -------------------------------------\")\n\n -------------------------------------\n Gauss-Seidl: tau_L = 20% \n -------------------------------------\nK* = 0.1502\nY* = 0.5662\nq* = 1.1310\nr* = 1.1310\nR* = 1.9613\nw* = 0.3964\n -------------------------------------\n Gauss-Seidl: tau_L = 25% \n -------------------------------------\nK* = 0.1370\nY* = 0.5508\nq* = 1.2063\nr* = 1.2063\nR* = 2.0254\nw* = 0.3856\n -------------------------------------\n\n\n\n\n\ncat(\" -------------------------------------\\n\")\ncat(\" Gauss-Seidl: tau_L = 20%\\n\")\ncat(\" -------------------------------------\\n\")\ncat(sprintf(\"K* = %6.4f\\n\", Kstar))\ncat(sprintf(\"Y* = %6.4f\\n\", Ystar))\ncat(sprintf(\"q* = %6.4f\\n\", qstar))\ncat(sprintf(\"r* = %6.4f\\n\", rstar))\ncat(sprintf(\"R* = %6.4f\\n\", Rstar))\ncat(sprintf(\"w* = %6.4f\\n\", wstar))\n\ncat(\" -------------------------------------\\n\")\ncat(\" Gauss-Seidl: tau_L = 25%\\n\")\ncat(\" -------------------------------------\\n\")\ncat(sprintf(\"K* = %6.4f\\n\", Kstar_new))\ncat(sprintf(\"Y* = %6.4f\\n\", Ystar_new))\ncat(sprintf(\"q* = %6.4f\\n\", qstar_new))\ncat(sprintf(\"r* = %6.4f\\n\", rstar_new))\ncat(sprintf(\"R* = %6.4f\\n\", Rstar_new))\ncat(sprintf(\"w* = %6.4f\\n\", wstar_new))\ncat(\" -------------------------------------\\n\")\n\n -------------------------------------\n Gauss-Seidl: tau_L = 20%\n -------------------------------------\nK* = 0.1502\nY* = 0.5662\nq* = 1.1310\nr* = 1.1310\nR* = 1.9613\nw* = 0.3964\n -------------------------------------\n Gauss-Seidl: tau_L = 25%\n -------------------------------------\nK* = 0.1370\nY* = 0.5508\nq* = 1.2063\nr* = 1.2063\nR* = 2.0254\nw* = 0.3856\n -------------------------------------\n\n\n\n\n\n\n\n\n\n\n\nKey Concepts and Summary\n\n\n\n\nIntroduction of OLG model\nDeriving optimality conditions in OLG model\nIntroduction of non-linear function solution\nGauss-Seidl Algorithm\n\n\n\n\n\n\n\n\n\nSelf-check questions\n\n\n\n\n\n\nUse either one of the models above and resolve the model for \\(\\tau_K = [0.01, 0.02, 0.03,...,0.1]\\) and track output, agggregate capital and tax revenue from capital as well as labor taxes.\nRepeat the exercise above but this time change the labor tax parameter and resolve the model for \\(\\tau_L = [0.11, 0.12, 0.13,...,0.2]\\)",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>A Simple OLG Model</span>"
    ]
  },
  {
    "objectID": "OLG-II.html",
    "href": "OLG-II.html",
    "title": "23  An OLG Model with Labor-Leisure Choice",
    "section": "",
    "text": "23.1 Preferences\n\\(V(c_y, l,c_o) = u(c_y,l) + \\beta \\times u(c_o)\\)",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>An OLG Model with Labor-Leisure Choice</span>"
    ]
  },
  {
    "objectID": "OLG-II.html#preferences",
    "href": "OLG-II.html#preferences",
    "title": "23  An OLG Model with Labor-Leisure Choice",
    "section": "",
    "text": "Agents live for 2 periods: young and old\nThey value consumption when young \\(c_y\\), leisure when young \\(1-l\\) and consumption when old \\(c_o\\)\nTheir preferences are given via utility functions: \\(u_t(c_t)\\)\nAgents discount time with factor \\(\\beta\\)\nTheir life-time utility is:",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>An OLG Model with Labor-Leisure Choice</span>"
    ]
  },
  {
    "objectID": "OLG-II.html#technology",
    "href": "OLG-II.html#technology",
    "title": "23  An OLG Model with Labor-Leisure Choice",
    "section": "23.2 Technology",
    "text": "23.2 Technology\n\nFirms produce output \\(Y\\) using input capital \\(K\\) and labor \\(L\\):\n\n\\(Y(K,L) = A \\times K^{0.3} \\times L^{0.7}\\)",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>An OLG Model with Labor-Leisure Choice</span>"
    ]
  },
  {
    "objectID": "OLG-II.html#government",
    "href": "OLG-II.html#government",
    "title": "23  An OLG Model with Labor-Leisure Choice",
    "section": "23.3 Government",
    "text": "23.3 Government\n\nThe government collects lump sum taxes from households \\(\\tau_{Lump}\\), taxes on labor \\(\\tau_L\\) and capital \\(\\tau_K\\)\nThe government pays for gov't consumption \\(G\\) and transfers to households T_y and \\(T_o\\)\n\n\\(G + T_y + T_o = L \\times \\tau_L + K \\times \\tau_K + \\tau_{Lump}\\)",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>An OLG Model with Labor-Leisure Choice</span>"
    ]
  },
  {
    "objectID": "OLG-II.html#household-problem",
    "href": "OLG-II.html#household-problem",
    "title": "23  An OLG Model with Labor-Leisure Choice",
    "section": "23.4 Household Problem",
    "text": "23.4 Household Problem\n\nHHs maximize \\(V(c_y,l,c_o)\\) subject to their budget constraint in each period\n\n\\(c_y + s = w  l + T_y\\) \\(c_o     = R  s + T_o\\)",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>An OLG Model with Labor-Leisure Choice</span>"
    ]
  },
  {
    "objectID": "OLG-II.html#equilibrium-definition",
    "href": "OLG-II.html#equilibrium-definition",
    "title": "23  An OLG Model with Labor-Leisure Choice",
    "section": "23.5 Equilibrium Definition",
    "text": "23.5 Equilibrium Definition\n\n* Given sequences of\n\n\nprices \\(\\left\\{w_t, R_t \\right\\}\\)\ngovernment policies \\(\\left\\{\\tau_L, \\tau_K, \\tau_{Lump} \\right\\}\\) and equilibrium is defined as an allocation of:\n\n\n* sequences of \\(\\left\\{c_{y,t},l_t,c_{o,t},s_t\\right\\}\\) so that\n\n\nthe HH max problem is solved\nthe firm maximization problem is solve\nthe gov't budget constraint clears",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>An OLG Model with Labor-Leisure Choice</span>"
    ]
  },
  {
    "objectID": "OLG-II.html#functional-forms-and-solutions",
    "href": "OLG-II.html#functional-forms-and-solutions",
    "title": "23  An OLG Model with Labor-Leisure Choice",
    "section": "23.6 Functional Forms and Solutions",
    "text": "23.6 Functional Forms and Solutions\n\nPreferences are given as: \\(u(c_y,l) = log(c_y)+log(l)\\) and \\(u(c_o)=log(c_o)\\)\nWe can either set up a Lagrangian with two constraints or simply substitute consumption out of the utilities using the BC.\nWe follow the second approach, since the form of the utility functions guarantees interior solutions\nTherefor we don't have to worry about corner solutions a la Kuhn-Tucker",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>An OLG Model with Labor-Leisure Choice</span>"
    ]
  },
  {
    "objectID": "OLG-II.html#substitute-in-preferences",
    "href": "OLG-II.html#substitute-in-preferences",
    "title": "23  An OLG Model with Labor-Leisure Choice",
    "section": "23.7 Substitute in Preferences",
    "text": "23.7 Substitute in Preferences\n\\(max_s log(w  l + T_y - s) + log(1-l) + \\beta  log(R  s + T_o)\\)\n\nThis is now a function in 2 choice variables \\(s\\) and labor \\(l\\)\nDerive this function w.r.t. \\(s\\) and labor \\(l\\)\n\n\\(\\frac{\\partial V}{\\partial s}: \\frac{1}{w  l + T_y - s} =\n\\frac{\\beta R}{R  s + T_o}\\)\n\\(\\frac{\\partial V}{\\partial l}: \\frac{w}{w  l + T_y - s} =\n\\frac{1}{1-l}\\)",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>An OLG Model with Labor-Leisure Choice</span>"
    ]
  },
  {
    "objectID": "OLG-II.html#solve-for-optimal-s-and-l",
    "href": "OLG-II.html#solve-for-optimal-s-and-l",
    "title": "23  An OLG Model with Labor-Leisure Choice",
    "section": "23.8 Solve for Optimal \\(s^*\\) and \\(l^*\\)",
    "text": "23.8 Solve for Optimal \\(s^*\\) and \\(l^*\\)",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>An OLG Model with Labor-Leisure Choice</span>"
    ]
  },
  {
    "objectID": "Growth.html",
    "href": "Growth.html",
    "title": "\n24  Growth Models\n",
    "section": "",
    "text": "25 The Solow Growth Models\nThe Solow growth model is an economic framework that explains the long-run economic growth and its implications. Developed by Robert Solow, this model focuses on the relationships between capital accumulation, population growth, and technological progress as drivers of economic growth.",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Growth Models</span>"
    ]
  },
  {
    "objectID": "Assignments.html",
    "href": "Assignments.html",
    "title": "Appendix A — Homework Assignments",
    "section": "",
    "text": "A.1 Module 1\nHomework 1: First Steps\nHomework 2: Branching and Looping\nHomework 3: Vectors and Matrices\nHomework 4: Plotting Vectors and Functions",
    "crumbs": [
      "Appendices",
      "**ASSIGNMENTS**",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Homework Assignments</span>"
    ]
  },
  {
    "objectID": "Assignments.html#module-2",
    "href": "Assignments.html#module-2",
    "title": "Appendix A — Homework Assignments",
    "section": "A.2 Module 2",
    "text": "A.2 Module 2\nHomework 5: Functions\nHomework 6: Data\nHomework 7: Object Oriented Programming",
    "crumbs": [
      "Appendices",
      "**ASSIGNMENTS**",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Homework Assignments</span>"
    ]
  },
  {
    "objectID": "Assignments.html#module-3",
    "href": "Assignments.html#module-3",
    "title": "Appendix A — Homework Assignments",
    "section": "A.3 Module 3",
    "text": "A.3 Module 3\nHomework 8: Random Numbers\nHomework 9: Root Finding\nHomework 10: Optimization",
    "crumbs": [
      "Appendices",
      "**ASSIGNMENTS**",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Homework Assignments</span>"
    ]
  },
  {
    "objectID": "Lecture_Basics/Homework/Homework_Basics.html",
    "href": "Lecture_Basics/Homework/Homework_Basics.html",
    "title": "Appendix B — Homework: First Steps",
    "section": "",
    "text": "B.1 Exercise 1:\nMake two lists having the following numbers as content:\nDefine the two lists as listA and listB.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Homework: First Steps</span>"
    ]
  },
  {
    "objectID": "Lecture_Basics/Homework/Homework_Basics.html#exercise-1",
    "href": "Lecture_Basics/Homework/Homework_Basics.html#exercise-1",
    "title": "Appendix B — Homework: First Steps",
    "section": "",
    "text": "\\((1, 2, 3, 4, 5, 6, 7, 8, 7, 6, 5, 4, 3, 2, 1)\\)\n\\((1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5)\\)\n\n\n\nPrint the 3. element of listA using list indexing.\nPrint elements 5-8 of listB with a one line command using list slicing.\nAdd the 3. element of listA to the 8. element of listB and print the sum of these two numbers. Use list indexing to \"extract\" the numbers from the list.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Homework: First Steps</span>"
    ]
  },
  {
    "objectID": "Lecture_Basics/Homework/Homework_Basics.html#exercise-2",
    "href": "Lecture_Basics/Homework/Homework_Basics.html#exercise-2",
    "title": "Appendix B — Homework: First Steps",
    "section": "B.2 Exercise 2:",
    "text": "B.2 Exercise 2:\nCompute the growth of money in a bank. Let \\(r\\) be a bank's interest rate in percent per year. An initial amount \\(A\\) will then grow to:\n\\(A(1+\\frac{r}{100})^n\\),\nafter \\(n\\) years.\nNow, make a program (or script) for computing how much money you have if you take 1,000 dollars and invest it for three years according to the formula above. Assume that your interest rate is \\(5\\) percent.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Homework: First Steps</span>"
    ]
  },
  {
    "objectID": "Lecture_Basics/Homework/Homework_Basics.html#exercise-3",
    "href": "Lecture_Basics/Homework/Homework_Basics.html#exercise-3",
    "title": "Appendix B — Homework: First Steps",
    "section": "B.3 Exercise 3:",
    "text": "B.3 Exercise 3:\nThe following program calculates the\n\narea of a parallelogram\n\n\\[Area = base \\times height\\]\n\narea of a square\n\n\\[Area = base^2\\]\n\narea of a circle\n\n\\[Area = \\pi \\times radius^2\\]\n\nvolume of a cone\n\n\\[Volume = \\frac{(\\pi \\times r^2 \\times h)}{3}\\]\n\n\nType the following program in your Spyder editor and execute it. It won't run. Debug it and make sure it all runs through correctly. Try to update it to the newest Python syntax (e.g., .format() function, ...):\nimport numpy as np\nh = 5.0 # height\nb = 2.0 # base\nr = 1.5 # radius\n#\narea_parallelogram = h*b\nprint \"The area of the parallelogram is %.3f\" % area_parallelogram\n#\narea_square = b**2\nprint \"The area of the square is %g\" % area_square\n#\narea_circle = pi*r**2\nprint \"The area of the circle is %.3f\" % area_circle\n#\nvolume_cone = 1.0/3*npp.pi*r**2*h\nprint 'The volume of the cone is %.3f' % volume_cone",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Homework: First Steps</span>"
    ]
  },
  {
    "objectID": "Lecture_Basics/Homework/Homework_Basics.html#exercise-4",
    "href": "Lecture_Basics/Homework/Homework_Basics.html#exercise-4",
    "title": "Appendix B — Homework: First Steps",
    "section": "B.4 Exercise 4:",
    "text": "B.4 Exercise 4:\nType these short programs in your editor and execute them. When they do not work, identify and correct the erroneous statements.\n\nThe following code checks whether \\(sin(x)^2  + cos(x)^2 = 1\\). Make sure it runs through and make sure the code verifies that the left hand side value equal the right hand side value of the equation above.\n\nCode:\nfrom math import sin, cos\nx = pi/4\n1_val = sin(x)**2 + cos2(x)**2\nprint 1_VAL\n\nSecond, fix the following script that implements the formulas below. Hint: Some variables are used before they are defined. Make up some values for undefined variables m, s etc. and add them to your script and make sure it all runs through without any more errors. The respective formulas are:\n\n\\[\\begin{aligned}\n\\begin{eqnarray*}\nv_0 = 3 \\left(\\frac{m}{s}\\right), \\\\\nt = 1 \\times s, \\\\\na = 2 \\left(\\frac{m}{s}\\right)^2, \\\\\nk = v_0\\times t + \\left(\\frac{1}{2}\\right)a\\times t^2. \\\\\n\\end{eqnarray*}\n\\end{aligned}\\]\nCode:\nv0 = 3 m/s\nt = 1 s\na = 2 m/s**2\nk = v0*t + 1/2 a*t**2\nprint k\n\nThe next code chunk verifies these equations:\n\n\\[\\begin{aligned}\n\\begin{eqnarray*}\n(a + b)^2 &=& a^2 + 2ab + b^2 \\\\\n(a - b)^2 &=& a^2 - 2ab + b^2\n\\end{eqnarray*}\n\\end{aligned}\\]\nCode:\na = 3,3 b = 5,3\na2 = a**2\nb2 = b**2\neq1_sum = a2 + 2ab + b2\neq2_sum = a2 - 2ab + b2\neq1_pow = (a + b)**2\neq2_pow = (a - b)**2\nprint 'First equation: %h = %' % (eq2_sum, eq2_sum)\nprint 'Second equation: %h = %' % (eq2_pow, eq2_pow)",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Homework: First Steps</span>"
    ]
  },
  {
    "objectID": "Lecture_Basics/Homework/Homework_Basics.html#exercise-5",
    "href": "Lecture_Basics/Homework/Homework_Basics.html#exercise-5",
    "title": "Appendix B — Homework: First Steps",
    "section": "B.5 Exercise 5:",
    "text": "B.5 Exercise 5:\nFind errors in the coding of a formula. Given a quadratic equation, \\(ax^2 + bx + c = 0\\), the two roots (i.e., the x values that would make the left hand side equal to zero) are: \\(x_1 = \\frac{-b + \\sqrt{b^2 - 4ac}}{2a},  x_2 = \\frac{-b - \\sqrt{b^2 - 4ac}}{2a}\\)\nWhat are the problems with the following program:\na = 2; b = 10; c = 2\nfrom math import sqrt\nq = sqrt(b*b - 4*a*c)\nx1 = (-b + q)/2*a\nx2 = (-b - q)/2*a\nprint x1, x2\nHint: Compute all terms in the math expression above with the aid of a calculator (you can use the command line in Spyder to do that, no need to find a pocket calculator), and compare with the corresponding intermediate results computed in the program. You need to add some print statements to see the result of q, -b+q, and 2*a, etc.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Homework: First Steps</span>"
    ]
  },
  {
    "objectID": "Lecture_Loop/Homework/Homework_Loop.html",
    "href": "Lecture_Loop/Homework/Homework_Loop.html",
    "title": "Appendix C — Homework: Branching and Looping",
    "section": "",
    "text": "C.1 Exercise 1\nWrite a program that generates all odd numbers from \\(1\\) to \\(n\\). Set n in the beginning of the program and use a while loop to compute the numbers. Make sure that if \\(n\\) is an even number, the largest generated odd number is \\(n-1\\). So if \\(n=10\\) you need to generate numbers \\(1,3,...,9\\)\nI'm fully aware that there are solutions out there that do not use a loop structure. However, the point of this exercise is for you to learn what loops do. So please use the while command.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Homework: Branching and Looping</span>"
    ]
  },
  {
    "objectID": "Lecture_Loop/Homework/Homework_Loop.html#exercise-2",
    "href": "Lecture_Loop/Homework/Homework_Loop.html#exercise-2",
    "title": "Appendix C — Homework: Branching and Looping",
    "section": "C.2 Exercise 2",
    "text": "C.2 Exercise 2\nYou are given the following program:\na = [1, 3, 5, 7, 11]\nb = [13, 17]\nc = a + b\nprint(c)\nb[0] = -1\nd = [e+1 for e in a]\nprint(d)\nd.append(b[0] + 1)\nd.append(b[-1] + 1)\nprint(d[-2:])\nExplain what each line of code does! Just add it as a comment/note with the # symbol in between the code lines.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Homework: Branching and Looping</span>"
    ]
  },
  {
    "objectID": "Lecture_Loop/Homework/Homework_Loop.html#exercise-3",
    "href": "Lecture_Loop/Homework/Homework_Loop.html#exercise-3",
    "title": "Appendix C — Homework: Branching and Looping",
    "section": "C.3 Exercise 3",
    "text": "C.3 Exercise 3\nThe following code is supposed to compute the sum of fractions as: \\(s = \\sum_{k=1}^{M}\\frac{1}{k}\\)\nwhere the formula explicitly means the following: \\(s = \\sum_{k=1}^{M}\\frac{1}{k} = \\frac{1}{1} + \\frac{1}{2} + ... +\\frac{1}{M}\\)\nHere is the code:\ns = 0; k = 1; M = 100\nwhile k &lt; M:\n    s += 1/k\nprint s\nThis program does not work correctly. What are the errors? (If you try to run the program, nothing will happen on the screen. Type Ctrl-C, i.e., hold down the Control Ctrl key and then type the c key, to stop a program. Fix the program so it runs through and calculates the sum correctly. There are two basic ways to find errors in a program:\n\n\nread the program carefully and think about the consequences of each statement, and\nprint out intermediate results and compare with calculations you did by hand.\n\n\nFirst, try method (1) and find as many errors as you can. Then, try method (2) for \\(M = 3\\) and compare the evolution of \\(s\\) with your calculations by hand.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Homework: Branching and Looping</span>"
    ]
  },
  {
    "objectID": "Lecture_Loop/Homework/Homework_Loop.html#exercise-4",
    "href": "Lecture_Loop/Homework/Homework_Loop.html#exercise-4",
    "title": "Appendix C — Homework: Branching and Looping",
    "section": "C.4 Exercise 4",
    "text": "C.4 Exercise 4\nRewrite the corrected version of the program in Exercise 3 using a for loop over \\(k\\) values instead of a while loop.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Homework: Branching and Looping</span>"
    ]
  },
  {
    "objectID": "Lecture_Loop/Homework/Homework_Loop.html#exercise-5",
    "href": "Lecture_Loop/Homework/Homework_Loop.html#exercise-5",
    "title": "Appendix C — Homework: Branching and Looping",
    "section": "C.5 Exercise 5",
    "text": "C.5 Exercise 5\nWe define the following nested list: q = [['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h']]\n\nIndex this list to extract:\n\n\nthe letter a;\nthe list ['d', 'e', 'f'];\nthe last element h;\nthe d element.\nExplain why q[-1][-2] has the value g.\n\n\n\nNOTE: You can skip this for the R-component of the course. Nested lists are tricky to do in R.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Homework: Branching and Looping</span>"
    ]
  },
  {
    "objectID": "Lecture_Loop/Homework/Homework_Loop.html#exercise-6",
    "href": "Lecture_Loop/Homework/Homework_Loop.html#exercise-6",
    "title": "Appendix C — Homework: Branching and Looping",
    "section": "C.6 Exercise 6",
    "text": "C.6 Exercise 6\nBuilding a list. Start with the following list of students:\nll = ['john', 'james', 'jim', 'jason', 'jill', 'jane', 'jinn']\nHere are their student numbers:\nstud_numbers = [345, 123, 876, 234, 198, 456, 876]\nWrite a program with a loop (for or while that's up to you) that generates a new list so that you have each student name, followed by her/his student number, i.e.:\ndatabase = ['john', 345, 'james', 124, ... , 'jinn', 876]\nOnce you have generated the new database list write another loop that prints the following output:\n------------------------------\nStudent Database\n------------------------------\nName:            ID number:\n------------------------------\njohn             345\njames            124\n...\njinn             876\n------------------------------\nTry to make it look as close as possible to this table. This may require the .format() function.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Homework: Branching and Looping</span>"
    ]
  },
  {
    "objectID": "Lecture_Arrays/Homework/Homework_Arrays.html",
    "href": "Lecture_Arrays/Homework/Homework_Arrays.html",
    "title": "Appendix D — Homework: Vectors and matrices",
    "section": "",
    "text": "D.1 Exercise 1\nDefine the following matrices as A and B\n\\[\\begin{aligned}\n\\left( \\begin{array}{ccc}\n0 & 1 & 1 \\\\\n1 & 0 & 1 \\\\\n1 & 1 & 0 \\end{array} \\right)\n\\end{aligned}\\]\n\\[\\begin{aligned}\n\\left( \\begin{array}{ccc}\n0 & 2 & 3 \\\\\n0 & 5 & 0 \\\\\n7 & 0 & 0 \\end{array} \\right)\n\\end{aligned}\\]",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Homework: Vectors and matrices</span>"
    ]
  },
  {
    "objectID": "Lecture_Arrays/Homework/Homework_Arrays.html#exercise-1",
    "href": "Lecture_Arrays/Homework/Homework_Arrays.html#exercise-1",
    "title": "Appendix D — Homework: Vectors and matrices",
    "section": "",
    "text": "Multiply A and B element by element.\nAdd A and B element by element.\nTranspose matrix A to A'.\nExtract the second row of matrix A, that is 1 0 1 and print it.\nUse matrix slicing to define vector a as the last column of matrix A and vector b as the last row of matrix B. Do not simply hard code the numbers of these vectors but use slicing, like you did in the previous question. Then add up a and b and print the result.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Homework: Vectors and matrices</span>"
    ]
  },
  {
    "objectID": "Lecture_Arrays/Homework/Homework_Arrays.html#exercise-2",
    "href": "Lecture_Arrays/Homework/Homework_Arrays.html#exercise-2",
    "title": "Appendix D — Homework: Vectors and matrices",
    "section": "D.2 Exercise 2",
    "text": "D.2 Exercise 2\nThe aim is to fill two vector arrays xv and yv with x and f(x) values, respectively, where\n\\(f(x) = \\frac{1}{\\sigma \\sqrt{2 \\pi}}  e^{- \\frac{1}{2} \\left( \\frac{x- \\mu}{\\sigma} \\right) ^2}\\)\nis the density of the standard normal distribution, that is a normal density with mean \\(\\mu=0\\) and standard deviation \\(\\sigma = 1\\). Let the xv values be uniformly spaced in xv = [-4, 4] with 100 grid points. Write a loop to fill in the values for \\(xv\\) and \\(yv=f(xv)\\). So at the end you should have a vector xv with the X-values and a vector yv with the function values \\(f(x)\\).\nHint: The constant pi, the square root function \\(\\sqrt{x}\\) (sqrt()) and the natural exponential function \\(e\\) (exp()) are all coded in the numpy library. No need to use the math library for these.\nBonus points: Plot yv against xv using the plot command.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Homework: Vectors and matrices</span>"
    ]
  },
  {
    "objectID": "Lecture_Arrays/Homework/Homework_Arrays.html#exercise-3",
    "href": "Lecture_Arrays/Homework/Homework_Arrays.html#exercise-3",
    "title": "Appendix D — Homework: Vectors and matrices",
    "section": "D.3 Exercise 3",
    "text": "D.3 Exercise 3\nCreate a vector array wv with values 0, 0.1, 0.2, . . ., 3 without using a loop. Write print statements to print w[:], w[:-2], w[::5], w[2:-2:6]. Explain which elements of the array are printed using these commands!",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Homework: Vectors and matrices</span>"
    ]
  },
  {
    "objectID": "Lecture_Arrays/Homework/Homework_Arrays.html#exercise-4",
    "href": "Lecture_Arrays/Homework/Homework_Arrays.html#exercise-4",
    "title": "Appendix D — Homework: Vectors and matrices",
    "section": "D.4 Exercise 4",
    "text": "D.4 Exercise 4\nCreate a \\(3 \\times 3\\) matrix with the value \\(1\\) in the main diagonal and call this matrix A. Then create a \\(5 \\times 3\\) matrix filled with the value \\(1\\) and call it B. When I say create I don't mean to simply type these matrices by hand. Use some built in numpy functions that generate these specific types of matrices automatically. Read the book carefully, the answer is right there!\nThen create a third matrix C that stacks the two earlier matrices on top of each other so that the result looks like this:\n\\[\\begin{aligned}\nC =\n\\left( \\begin{array}{ccc}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1 \\\\\n1 & 1 & 1 \\\\\n1 & 1 & 1 \\\\\n1 & 1 & 1 \\\\\n1 & 1 & 1 \\\\\n1 & 1 & 1 \\end{array} \\right)\n\\end{aligned}\\]",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Homework: Vectors and matrices</span>"
    ]
  },
  {
    "objectID": "Lecture_Arrays/Homework/Homework_Arrays.html#exercise-5",
    "href": "Lecture_Arrays/Homework/Homework_Arrays.html#exercise-5",
    "title": "Appendix D — Homework: Vectors and matrices",
    "section": "D.5 Exercise 5",
    "text": "D.5 Exercise 5\n\nUse the matrix from Exercise 4 and run a loop that extracts all the elements from the second column and prints them one by one.\nUse the matrix from Exercise 4 and run a loop that extracts all the elements from the third row and prints them one by one.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Homework: Vectors and matrices</span>"
    ]
  },
  {
    "objectID": "Lecture_Arrays/Homework/Homework_Arrays.html#exercise-6",
    "href": "Lecture_Arrays/Homework/Homework_Arrays.html#exercise-6",
    "title": "Appendix D — Homework: Vectors and matrices",
    "section": "D.6 Exercise 6",
    "text": "D.6 Exercise 6\nCreate the following matrix A by hand (just type it into the script file).\n\\[\\begin{aligned}\n\\left( \\begin{array}{ccc}\n2 & 0 & 10 \\\\\n0 & 3 & -50 \\\\\n0 & 0 & 4 \\\\\n6 & 0 & 0 \\\\\n5 & 7 & 0 \\\\\n0 & 0 & 8 \\end{array} \\right)\n\\end{aligned}\\]\nWrite a loop (or a nested loop) that extracts the diagonal elements 2,3,4,6,7,8 and prints them one by one.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Homework: Vectors and matrices</span>"
    ]
  },
  {
    "objectID": "Lecture_Plot/Homework/Homework_Plot.html",
    "href": "Lecture_Plot/Homework/Homework_Plot.html",
    "title": "Appendix E — Homework: Plotting vectors and functions",
    "section": "",
    "text": "E.1 Exercise 1:\nPlot the following function:\n\\(F(K,L) = A \\times K ^ \\alpha L ^ {(1-\\alpha)}\\)\nIn order to plot this function set: \\(A = 10, \\alpha= 0.33\\) and \\(L=20\\). Plot this function against values of \\(K \\in [0,10]\\)",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Homework: Plotting vectors and functions</span>"
    ]
  },
  {
    "objectID": "Lecture_Plot/Homework/Homework_Plot.html#exercise-2",
    "href": "Lecture_Plot/Homework/Homework_Plot.html#exercise-2",
    "title": "Appendix E — Homework: Plotting vectors and functions",
    "section": "E.2 Exercise 2:",
    "text": "E.2 Exercise 2:\nPlot the above function again into a new figure. Then change the total factor productivity \\(A\\) to \\(20\\) and plot the function again into the same graph. Repeat this for\n\\(A = 21\\), \\(A = 22\\), \\(A = 23\\), and \\(A = 24\\).\nAdd a legend and labels for the axes as well as a title. You should have 6! functions plotted inside your figure. And you should now see how total factor productivity increases output.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Homework: Plotting vectors and functions</span>"
    ]
  },
  {
    "objectID": "Lecture_Plot/Homework/Homework_Plot.html#exercise-3",
    "href": "Lecture_Plot/Homework/Homework_Plot.html#exercise-3",
    "title": "Appendix E — Homework: Plotting vectors and functions",
    "section": "E.3 Exercise 3:",
    "text": "E.3 Exercise 3:\nSuppose that queue = [\"Steve\", \"Russell\", \"Alison\", \"Liam\"] and that this queue represents a supermarket queue with Steve first in line. Update the supermarket queue successively as follows - printing the entire queue in each round:\n\n\nBarry arrives\nSteve is served\nPam talks her way to the front because she only buys one item\nBarry gets impatient and leaves\nAlison gets impatient and leaves\n\n\nFor the last case you should not assume that you know where in the queue Alison is standing.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Homework: Plotting vectors and functions</span>"
    ]
  },
  {
    "objectID": "Lecture_Plot/Homework/Homework_Plot.html#exercise-4",
    "href": "Lecture_Plot/Homework/Homework_Plot.html#exercise-4",
    "title": "Appendix E — Homework: Plotting vectors and functions",
    "section": "E.4 Exercise 4:",
    "text": "E.4 Exercise 4:\nMake a plot of the function \\(y(t) = v_0 \\times t - 0.5 \\times g \\times t^2\\) for \\(v_0 = 10, g = 9.81\\), and \\(t \\in [0, 2v_0/g]\\). The label on the x-axis should be time t and the label on the y-axis should be height m.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Homework: Plotting vectors and functions</span>"
    ]
  },
  {
    "objectID": "Lecture_Plot/Homework/Homework_Plot.html#exercise-5",
    "href": "Lecture_Plot/Homework/Homework_Plot.html#exercise-5",
    "title": "Appendix E — Homework: Plotting vectors and functions",
    "section": "E.5 Exercise 5:",
    "text": "E.5 Exercise 5:\nPlot the following functions into a single graph BUT use a subplot for each function. So your figure has 3 subplots inside. Add super title to the graph. Then for each subgraph add axes labels and a title.\n\n\n\\(f(x) = ln(x)\\) for \\(x&gt;0\\),\nThe derivative of \\(f(x)\\) that you can call \\(g(x) = f'(x)\\) for \\(x&gt;0\\) and\n\\(h(x) = |x|\\) for \\(x\\in[-4, 4]\\).\n\n\n\n\nNote\n\nThis is not a composite function! Just three separate functions. You do not need an if command for this. Just define the xv vector for the ranges given.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Homework: Plotting vectors and functions</span>"
    ]
  },
  {
    "objectID": "Lecture_Plot/Homework/Homework_Plot.html#exercise-6",
    "href": "Lecture_Plot/Homework/Homework_Plot.html#exercise-6",
    "title": "Appendix E — Homework: Plotting vectors and functions",
    "section": "E.6 Exercise 6:",
    "text": "E.6 Exercise 6:\nPlot the following composite function. You probably want to use if statements and a loop to \"build\" it. Plot the function in the interval from \\([-3, 5]\\).\n\\[\\begin{aligned}\nf(x) =\n\\begin{cases}\n    |x| & x &lt; 0 \\\\\n    -1 & 0 \\leq x &lt; 1 \\\\\n    +1 & 1 \\leq x &lt; 2 \\\\\n    ln(x) & 2 \\leq x\n\\end{cases}\n\\end{aligned}\\]",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Homework: Plotting vectors and functions</span>"
    ]
  },
  {
    "objectID": "Lecture_Functions/Homework/Homework_Functions.html",
    "href": "Lecture_Functions/Homework/Homework_Functions.html",
    "title": "Appendix F — Homework: Functions",
    "section": "",
    "text": "F.1 Exercise 1\nThe formula for converting Fahrenheit degrees to Celsius reads: \\(C = \\frac{5}{9}(F - 32)\\)\nWrite a function called myfuncCtoF that implements this formula and converts the following temperatures from F to C: \\({60, 70, 75, 80,\n85, 90, 95, 100, 105}\\).\nUse the def keyword to define your function myfuncCtoF. Then call the function to make the conversion. You have at least two options here:\nThen pretty print the results i.e. something like this:",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>Homework: Functions</span>"
    ]
  },
  {
    "objectID": "Lecture_Functions/Homework/Homework_Functions.html#exercise-1",
    "href": "Lecture_Functions/Homework/Homework_Functions.html#exercise-1",
    "title": "Appendix F — Homework: Functions",
    "section": "",
    "text": "Either define the function so you hand in a number and it spits a number back and then call the function from a loop.\nOr, you define the function so that it accepts a vector as input. Then you write a loop inside the function that converts all the numbers from the vector and spits back a results vector.\n\n\n\n60  Fahrenheit equal .. Celsius\n70  Fahrenheit equal .. Celsius\n...\n105 Fahrenheit equal .. Celsius",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>Homework: Functions</span>"
    ]
  },
  {
    "objectID": "Lecture_Functions/Homework/Homework_Functions.html#exercise-2",
    "href": "Lecture_Functions/Homework/Homework_Functions.html#exercise-2",
    "title": "Appendix F — Homework: Functions",
    "section": "F.2 Exercise 2",
    "text": "F.2 Exercise 2\nThe factorial of \\(n\\), written as \\(n!\\), is defined as \\(n! = n\n\\times (n - 1)(n - 2) ... \\times 1\\) with the special cases \\(1! = 1\\), \\(0! = 1\\).\nFor example, \\(4! = 4 \\times 3  \\times 2 \\times  1 = 24\\), and \\(2! =\n2 \\times 1 = 2\\). Write a function myfact(n) that returns \\(n!\\). Return 1 immediately if x is 1 or 0, otherwise use a loop (inside the function definition) to compute \\(n!\\).\nYou are not allowed to use the built in np.fact() function - but you can use this built in function to check the correctness of your \"hand written\" function.\nimport math as m\nimport numpy as np\nprint(m.factorial(4))\nprint(np.math.factorial(4))\n24\n24",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>Homework: Functions</span>"
    ]
  },
  {
    "objectID": "Lecture_Functions/Homework/Homework_Functions.html#exercise-3",
    "href": "Lecture_Functions/Homework/Homework_Functions.html#exercise-3",
    "title": "Appendix F — Homework: Functions",
    "section": "F.3 Exercise 3",
    "text": "F.3 Exercise 3\nThe (Euclidean) length of a vector \\(v = (a_0, a_1,\\dots, a_k)\\) is the square root of the sum of squares of its coordinates \\(\\sqrt{a_0^2 + a_1^2,\\dots,\na_k^2}\\).\nWrite a function myDistance that returns the length of a vector calculated according to the formula above. This requires a loop inside your function definition.\nThen test your function and calculate the length of vector \\(a = [3, 5, 23, 45, 12]\\) and vector \\(b = [6, -5, 20]\\).",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>Homework: Functions</span>"
    ]
  },
  {
    "objectID": "Lecture_Functions/Homework/Homework_Functions.html#exercise-4",
    "href": "Lecture_Functions/Homework/Homework_Functions.html#exercise-4",
    "title": "Appendix F — Homework: Functions",
    "section": "F.4 Exercise 4",
    "text": "F.4 Exercise 4\nThis should look familiar. Plot the following composite function. First define a function f(x) as below and call it myFunction1 and then evaluate myFunction1 on a grid of x values from \\([-3, 5]\\). Store the function values in a vector yv. Then plot this function.\n\\[\\begin{aligned}\nf(x) =\n\\begin{cases}\n    x^2 & x &lt; -1 \\\\\n    |x| & -1 \\leq x &lt; 0 \\\\\n    -1 & 0 \\leq x &lt; 0.5 \\\\\n    x^2 & 0.5 \\leq x &lt; 2 \\\\\n    \\sqrt{x} & 2 \\leq x\n\\end{cases}\n\\end{aligned}\\]",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>Homework: Functions</span>"
    ]
  },
  {
    "objectID": "Lecture_Functions/Homework/Homework_Functions.html#exercise-5-more-difficult",
    "href": "Lecture_Functions/Homework/Homework_Functions.html#exercise-5-more-difficult",
    "title": "Appendix F — Homework: Functions",
    "section": "F.5 Exercise 5 (more difficult)",
    "text": "F.5 Exercise 5 (more difficult)\nSome object is moving along a path in the X-Y plane. Maybe think of a chessboard, where the X values are the rows and the Y values are the columns.\nAt \\(n\\) points of time we have recorded the corresponding (x, y) positions of the object that moves on our \"chessboard\". Here are the coordinates for the n different positions, indexed as \\(0,1, ..., n-1\\): \\((x_0 , y_0), (x_1, y_2), ..., (x_{n-1}, y_{n-1})\\).\nThe total length \\(L\\) of the path from \\((x_0, y_0)\\) to \\((x_{n-1}, y_{n-1})\\) is the sum of all the individual line segments \\((x_{i-1}, y_{i-1})\\) to \\((x_i, y_i)\\), for \\(i = 1,..., n-1\\):\n\\(L = \\sum_{i=1}^{n-1} \\sqrt{(x_i - x_{i-1})^2 + (y_i - y_{i-1})^2}\\)\nMake a function with the name pathlength(x,y) for computing this length \\(L\\) according to the formula above.\nThe arguments \\(x\\) and \\(y\\) hold all the \\(x_0,...,x_{n-1}\\) and \\(y_0,...,y_{n-1}\\) coordinates, respectively. Test the function on a triangular path with the four points (1,1), (2,1), (1,2), and (1,1).\nHint: As the object moves from (1,1) to (2,1) calculate the length of that path and store it in an \"accumulator variable\". Then calculate the length of the path from (2,1) to (1,2) and add that to the stored value, etc. Put this into a loop so that if more points are added the function can calculate the total length traveled.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>Homework: Functions</span>"
    ]
  },
  {
    "objectID": "Lecture_Data/Homework/Homework_Data.html",
    "href": "Lecture_Data/Homework/Homework_Data.html",
    "title": "Appendix G — Homework: Data",
    "section": "",
    "text": "G.1 Exercise 1:\nImport the data into a DataFrame called: myData",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>Homework: Data</span>"
    ]
  },
  {
    "objectID": "Lecture_Data/Homework/Homework_Data.html#exercise-2",
    "href": "Lecture_Data/Homework/Homework_Data.html#exercise-2",
    "title": "Appendix G — Homework: Data",
    "section": "G.2 Exercise 2:",
    "text": "G.2 Exercise 2:\nMake summary statistics (e.g., mean, median, mode, and standard deviations) of all numerical variables. That is, print a table that says something like this:\nVariable 1:\n==========\nmean: mean(Variable 1)\nmedian: median(variable 1)\nmode: mode(variable 1)\nstandard deviation: stand.Dev.(Variable 1)\n\nVariable 2:\n==========\nmean: mean(Variable 2)\nmedian: median(variable 2)\nmode: mode(variable 2)\netc.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>Homework: Data</span>"
    ]
  },
  {
    "objectID": "Lecture_Data/Homework/Homework_Data.html#exercise-3",
    "href": "Lecture_Data/Homework/Homework_Data.html#exercise-3",
    "title": "Appendix G — Homework: Data",
    "section": "G.3 Exercise 3:",
    "text": "G.3 Exercise 3:\nMake a scatterplot of Median Income and Bachelors degree. The latter variable measures the percentage of the population in the county that has a bachelors degree.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>Homework: Data</span>"
    ]
  },
  {
    "objectID": "Lecture_Data/Homework/Homework_Data.html#exercise-4",
    "href": "Lecture_Data/Homework/Homework_Data.html#exercise-4",
    "title": "Appendix G — Homework: Data",
    "section": "G.4 Exercise 4:",
    "text": "G.4 Exercise 4:\nRun a regression model of the following form:\n\\[\\begin{aligned}\n\\text{JuvenileArrestRate} = \\beta_0 +\n\\beta_1 \\text{Population} + \\beta_2 \\text{MedianIncome} \\\\\n+ \\beta_3 \\text{Unemployment} + \\beta_4 \\text{Eduation} + \\beta_5 \\text{Poverty} + \\epsilon\n\\end{aligned}\\]\nReport a table with all coefficient estimates including p-values.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>Homework: Data</span>"
    ]
  },
  {
    "objectID": "Lecture_Data/Homework/Homework_Data.html#exercise-5",
    "href": "Lecture_Data/Homework/Homework_Data.html#exercise-5",
    "title": "Appendix G — Homework: Data",
    "section": "G.5 Exercise 5:",
    "text": "G.5 Exercise 5:\nRun the model from Exercise 4 again, but this time replace Population with a categorical variable for county size. You should make 3 categories here: small_counties, middle_counties, and large_counties.\nA small county is defined as a county with a population smaller than \\(6,500\\). A mid size county has a population between \\(6,500\\) and \\(10,000\\) and a large size county has a population larger than \\(10,000\\) people. Make dummy variables and include those into your regression. Review how to make dummies etc. from your stats notes or from the brief introduction in the lecture.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>Homework: Data</span>"
    ]
  },
  {
    "objectID": "Lecture_OOP/Homework/Homework_OOP.html",
    "href": "Lecture_OOP/Homework/Homework_OOP.html",
    "title": "Appendix H — Homework: Object Oriented Programming (OOP)",
    "section": "",
    "text": "H.1 Exercise 1\nDefine a student class. A student has the following attributes: firstname, lastname, gender which can be male or female, status which can be equal to freshman, sophomore, junior, and senior and gpa.\nThen define the following methods for the student class.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>H</span>  <span class='chapter-title'>Homework: Object Oriented Programming (OOP)</span>"
    ]
  },
  {
    "objectID": "Lecture_OOP/Homework/Homework_OOP.html#exercise-1",
    "href": "Lecture_OOP/Homework/Homework_OOP.html#exercise-1",
    "title": "Appendix H — Homework: Object Oriented Programming (OOP)",
    "section": "",
    "text": "The show_myself method will simply print all the attribute variables when called upon the object. This method has no input arguments.\nThe study_time method will increment the gpa of the student according to the following formula: ` gpa = gpa + log(study_time). The only input argument of this method is the variablestudy_time. In addition make sure that thegpa` variable never exceeds 4.0 even if the student studies for a very long time.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>H</span>  <span class='chapter-title'>Homework: Object Oriented Programming (OOP)</span>"
    ]
  },
  {
    "objectID": "Lecture_OOP/Homework/Homework_OOP.html#exercise-2",
    "href": "Lecture_OOP/Homework/Homework_OOP.html#exercise-2",
    "title": "Appendix H — Homework: Object Oriented Programming (OOP)",
    "section": "H.2 Exercise 2",
    "text": "H.2 Exercise 2\nNow define 5 student objects and store the objects in a list called student_list. The five students are: Mike Barnes, Jim Nickerson, Jack Indabox, Jane Miller and Mary Scott. Mike is a freshman, Jim a sophomore, Jack a junior, Jane and Mary are seniors. Their respective GPAs are: 4, 3, 2.5, 3.6 and 2.7. Make sure you assign the gender when you instantiate the objects.\nThen call the show_myself method on all of them. I suggest you use a loop for making the objects and a separate loop for showing the objects.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>H</span>  <span class='chapter-title'>Homework: Object Oriented Programming (OOP)</span>"
    ]
  },
  {
    "objectID": "Lecture_OOP/Homework/Homework_OOP.html#exercise-3",
    "href": "Lecture_OOP/Homework/Homework_OOP.html#exercise-3",
    "title": "Appendix H — Homework: Object Oriented Programming (OOP)",
    "section": "H.3 Exercise 3",
    "text": "H.3 Exercise 3\nUse your objects from above and let each one of the 5 students study for 60, 100, 40, 300, 1000 minutes, respectively. So the first student studies 60 minutes, the second studies 100 minutes, etc. After that call the show_myself methods on all 5 again and check whether their new gpa reflects how much they studied.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>H</span>  <span class='chapter-title'>Homework: Object Oriented Programming (OOP)</span>"
    ]
  },
  {
    "objectID": "Lecture_Random/Homework/Homework_Random.html",
    "href": "Lecture_Random/Homework/Homework_Random.html",
    "title": "Appendix I — Homework: Random Numbers",
    "section": "",
    "text": "I.1 Exercise 1\nFlip a coin N times. Make a program that simulates flipping a coin N times. Print out \"tail\" or \"head\" for each flip and let the program count the number of heads. Hint: Use r = np.random.rand() and define head as r &lt;= 0.5 or draw an integer between {1, 2} and define head when r is 1.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>I</span>  <span class='chapter-title'>Homework: Random Numbers</span>"
    ]
  },
  {
    "objectID": "Lecture_Random/Homework/Homework_Random.html#exercise-2",
    "href": "Lecture_Random/Homework/Homework_Random.html#exercise-2",
    "title": "Appendix I — Homework: Random Numbers",
    "section": "I.2 Exercise 2",
    "text": "I.2 Exercise 2\nCompute a probability. What is the probability of getting a number between 0.5 and 0.6 when drawing uniformly distributed random numbers from the interval [0, 1]?\nTo answer this question empirically, let a program draw N such random numbers using Python's standard random module. Count how many of them, M , fall in the interval (0.5, 0.6), and compute the probability as M/N .\nHint: Run the program four times with N = 100. The tricky part is to count how many of the 100 random numbers fall in the interval (0.5, 0.6). Run the program again for N = 1000 and see whether the relative frequency changes a lot. Finally run the program with N = 10,000.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>I</span>  <span class='chapter-title'>Homework: Random Numbers</span>"
    ]
  },
  {
    "objectID": "Lecture_Random/Homework/Homework_Random.html#exercise-3",
    "href": "Lecture_Random/Homework/Homework_Random.html#exercise-3",
    "title": "Appendix I — Homework: Random Numbers",
    "section": "I.3 Exercise 3",
    "text": "I.3 Exercise 3\nProbabilities of rolling dice. Simulate the rolling of a die a thousand times. How many times does the number 6 come up?",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>I</span>  <span class='chapter-title'>Homework: Random Numbers</span>"
    ]
  },
  {
    "objectID": "Lecture_Random/Homework/Homework_Random.html#exercise-4-harder-question",
    "href": "Lecture_Random/Homework/Homework_Random.html#exercise-4-harder-question",
    "title": "Appendix I — Homework: Random Numbers",
    "section": "I.4 Exercise 4: Harder question",
    "text": "I.4 Exercise 4: Harder question\nDecide if a dice game is fair. Somebody suggests the following game. You pay 1 dollar and are allowed to throw four dice. If the sum of the eyes on the dice is less than 9, you win 10 dollars, otherwise you lose your investment. Should you play this game?\nAnswer the question by making a program that simulates the game 1000 times. Count how many times, out of the 1000, you would win this game in which case you'd win 10 bucks. Compare these winnings to your investment of 1000 dollars. Do you come out ahead?",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>I</span>  <span class='chapter-title'>Homework: Random Numbers</span>"
    ]
  },
  {
    "objectID": "Lecture_Root/Homework/Homework_Root.html",
    "href": "Lecture_Root/Homework/Homework_Root.html",
    "title": "Appendix J — Homework: Root finding",
    "section": "",
    "text": "J.1 Exercise 1\nUse the Newton-Raphson method from the lecture and calculate the roots of the following functions. Please use the Newton-Raphson method that we programmed ourselves, not the built in one from the scipy.optimize library. I want to see whether you are able to correctly program a function as an input argument and then \"handle\" this function input inside of your algorithm.\nThen check your answers using the bisection method.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>J</span>  <span class='chapter-title'>Homework: Root finding</span>"
    ]
  },
  {
    "objectID": "Lecture_Root/Homework/Homework_Root.html#exercise-1",
    "href": "Lecture_Root/Homework/Homework_Root.html#exercise-1",
    "title": "Appendix J — Homework: Root finding",
    "section": "",
    "text": "\\(log(x) - exp(-x)\\) using \\(x_0 = 2\\)\n\\(x^3 - x - 3\\) using \\(x_0 = 0\\)\n\\(x^3 - 7x^2 + 14x - 8\\) using \\(x_0 = 1.1, 1.2, . . . , 1.9\\)\n\\(log(x) \\times exp(-x)\\) using \\(x_0 = 2\\)",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>J</span>  <span class='chapter-title'>Homework: Root finding</span>"
    ]
  },
  {
    "objectID": "Lecture_Root/Homework/Homework_Root.html#exercise-2",
    "href": "Lecture_Root/Homework/Homework_Root.html#exercise-2",
    "title": "Appendix J — Homework: Root finding",
    "section": "J.2 Exercise 2",
    "text": "J.2 Exercise 2\nThe bisection method can be generalized to deal with the case f(xl)f(xr) &gt; 0, by broadening the bracket. That is, we reduce xl and/or increase xr , and try again. A reasonable choice for broadening the bracket is to double the width of the interval [xl,xr], that is (in pseudo-code):\nm = (xl + xr )/2\nw = xr - xl\nxl = m - w\nxr = m + w\nIncorporate bracket broadening into the function bisection given in the lecture. Note that broadening is not guaranteed to find xl and xr such that f(xl)f(xr)&lt;= 0, so you should include a limit on the number of times it can be tried.\nNow use your modified bisection function to find a root of\n\\[f(x) = (x - 1)^3 - 2x^2 + 10 - sin(x),\\]\nstarting with xl = 1 and xr = 2.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>J</span>  <span class='chapter-title'>Homework: Root finding</span>"
    ]
  },
  {
    "objectID": "Lecture_Root/Homework/Homework_Root.html#bonus-exercise-3",
    "href": "Lecture_Root/Homework/Homework_Root.html#bonus-exercise-3",
    "title": "Appendix J — Homework: Root finding",
    "section": "J.3 Bonus: Exercise 3",
    "text": "J.3 Bonus: Exercise 3\nHow do we know \\(\\pi = 3.1415926\\) (to 7 decimal places)? One way of finding \\(\\pi\\) is to solve \\(sin(x) = 0.\\) By definition the solutions to \\(sin(x) = 0\\) are \\(k \\times \\pi\\) for \\(k = 0, \\pm 1, \\pm 2, \\dots\\), so the root closest to 3 should be \\(\\pi\\).\n\n\nUse a root-finding algorithm, such as the Newton-Raphson algorithm, to find the root of sin(x) near 3.\nHow close can you get to \\(\\pi\\)? (You may use the function \\(sin(x)\\) provided by Python.)\nThe function sin(x) is transcendental, which means that it cannot be written as a rational function of x. Instead we have to write it as an infinite sum:\n\\[sin(x) = \\sum_{k=0}^{\\infty} {(-1)^k \\frac{x^{2k+1}}{(2k + 1)!}}\\]\nThis is the infinite order Taylor expansion of sin(x) about 0. In practice, to calculate \\(sin(x)\\) numerically we have to truncate this sum, so any numerical calculation of \\(sin(x)\\) is an approximation. In particular the function sin(x) provided by Python is only an approximation of sin(x) (though a very good one).\nDefine the following function in Python (use def):\n\\[f_n(x)= \\sum_{k=0}^{n}{(-1)^k \\frac{x^{2k+1}}{(2k + 1)!}}\\]\n(Hint: in order to form this sum you should use a loop over n iterations. You do not need to program the factorial, just use m.factorial())\nThen plot \\(f_n(x)\\) over the range \\([0, 7]\\) three times. The first time choose n=7, the second time choose n=8 and for the third time choose n=9. Do you see a difference in the sine functions in your plots as you increase the n. Just plot all three functions into the same figure then any differences should be obvious. For large n your plot should look like the wavy plot of s sin() function.\n\n\nWarning\n\nDon't pick n larger than 20 or so. The factorials will explode pretty quickly.\n\nChoose a large value of n and solve \\(f_n(x) = 0\\) near 3. Can you get an approximation of the number \\(\\pi\\) that is correct up to 6 decimal places?",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>J</span>  <span class='chapter-title'>Homework: Root finding</span>"
    ]
  },
  {
    "objectID": "Lecture_Optimization/Homework/Homework_Optimization.html",
    "href": "Lecture_Optimization/Homework/Homework_Optimization.html",
    "title": "Appendix K — Homework: Optimization",
    "section": "",
    "text": "K.1 Exercise 1\nUse the golden-section search algorithm to find all of the local maxima of the function. Do not use a built-in algorithm but the one we developed last time in class. I need to see whether you are able to process functions that are \"handed into\" other functions (or algorithms).\n\\[\\begin{aligned}\nf(n) = \\left\\{\n\\begin{array}{l l}\n0 & \\quad \\text{if $x=0$} \\\\\n|x| \\times log(|x|/2)e^{-|x|} & \\quad \\text{otherwise} \\\\\n\\end{array}\n\\right.\n\\end{aligned}\\]\nwithin the interval [-10, 10]. Hint: plotting the function first will give you a good idea where to look.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>K</span>  <span class='chapter-title'>Homework: Optimization</span>"
    ]
  },
  {
    "objectID": "Lecture_Optimization/Homework/Homework_Optimization.html#exercise-2",
    "href": "Lecture_Optimization/Homework/Homework_Optimization.html#exercise-2",
    "title": "Appendix K — Homework: Optimization",
    "section": "K.2 Exercise 2",
    "text": "K.2 Exercise 2\nFind the allocation of capital \\(K\\) and labor \\(L\\) that maximizes the following profit function of a representative firm:\n\\[max_{\\{K,L\\}} A \\times (K^{0.33} \\times L^{0.67}) - w \\times L - r \\times K,\\]\nwhere the wage rate is \\(w = 1.84\\) and the cost of capital is \\(r=0.75\\) and the total factor productivity (TFP) is \\(A=4\\).\nIn order to NOT have to maximize over two dimensions, I would like you to maximize this function w.r.t. capital \\(K\\) only. You would simply set labor \\(L\\) equal to specific values such as \\(L=\\{1,1.5,2,2.5,3,3.5,4,4.5,5\\}\\). An then for each one of these labor values you would search for the optimal level of capital \\(K\\) that maximizes profits. This results in nine separate optimizations. I suggest to do this from within a loop. The result should be nine optimal \\(K^*\\) values.\nHint: I would define \\(L\\) as a global variable so you can change its value outside of the function.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>K</span>  <span class='chapter-title'>Homework: Optimization</span>"
    ]
  },
  {
    "objectID": "Lecture_Optimization/Homework/Homework_Optimization.html#harder-exercise-3",
    "href": "Lecture_Optimization/Homework/Homework_Optimization.html#harder-exercise-3",
    "title": "Appendix K — Homework: Optimization",
    "section": "K.3 Harder: Exercise 3",
    "text": "K.3 Harder: Exercise 3\nWrite a version of function golden section from class that plots intermediate results so the user can track visually how the algorithm gets closer to the optimization point in each iteration.\nMore specifically, plot the function being optimized, then at each step draw a vertical line at the positions xl , xr , xm, and y (with the line at y in a different colour). Apply this new golden section algorithm to the function in exercise 1.\nAs you run this code you should visually see how the brackets move in at each iteration and get closer and closer to the maximum.",
    "crumbs": [
      "Appendices",
      "**HOMEWORK ASSIGNMENTS**",
      "<span class='chapter-number'>K</span>  <span class='chapter-title'>Homework: Optimization</span>"
    ]
  },
  {
    "objectID": "Plot.html#d-meshplots-of-surfaces",
    "href": "Plot.html#d-meshplots-of-surfaces",
    "title": "\n8  Plotting using matplotlib\n",
    "section": "\n8.5 3D-Meshplots of Surfaces",
    "text": "8.5 3D-Meshplots of Surfaces\nIn order to plot the entire “surface” of the function \\(f(x,y)\\) we need to specify value pairs of x and y over the entire gridspace of the x/y plane. We use the command meshgrid in order to accomplish this. We then evaluate the function \\(f(x,y)\\) for each point on this “meshgrid” which results in a surface plot of the function.\n\n\nPython Code\nR Code\n\n\n\n\nimport matplotlib.pyplot as plt\n\nplt.style.use('_mpl-gallery')\n\n# Define grids in x and y dimension\nxv = np.linspace(1, 10, 10)\nyv = np.linspace(1, 10, 10)\n\n# Span meshgrid over entire x/y plane\nX, Y = np.meshgrid(xv, yv)\n\n# Evaluate function at each point in the x/y plane\nZ = 3.0 * Y**2.0 /2.0 + X - np.sqrt(X*Y) /5.0\n\n# Plot\nax = plt.figure(figsize=(6, 7)).add_subplot(projection='3d')\nax.plot_wireframe(X, Y, Z, rstride=1, cstride=1)\nax.set_xlabel('x', fontsize=18)\nax.set_ylabel('y', fontsize=18)\nax.set_zlabel('f(x,y)', fontsize=18)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# Define grids in x and y dimension\nxv &lt;- seq(1, 10, length.out = 10)\nyv &lt;- seq(1, 10, length.out = 10)\n\n# Evaluate function at each point in the x/y plane\nZ_values &lt;- function(X,Y) {\n    3.0 * Y^2 / 2 + X - sqrt(X * Y) / 5\n    }\n\nZ = outer(xv, yv, Z_values)\n\n# Create a wireframe plot\npersp(xv, yv, Z,  # Pass X, Y, Z as matrices directly\n       xlab = \"x\", ylab = \"y\", zlab = \"f(x, y)\",\n       main = \"Wireframe Plot of Function in 2 variables\")\n\n\n\n\n\n\n\n\n\n\nThe rstride and cstride command tells the function to take every point on rstride=2 then it would “downsample” the meshgrid and only take every other point in the row-dimension. It will produce a less smooth graph. Here’s the example for rstride=2.\n\n# Plot\nax = plt.figure(figsize=(6, 7)).add_subplot(projection='3d')\nax.plot_wireframe(X, Y, Z, rstride=2, cstride=1)\nax.set_xlabel('x', fontsize=18)\nax.set_ylabel('y', fontsize=18)\nax.set_zlabel('f(x,y)', fontsize=18)\nplt.show()",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Plotting using `matplotlib`</span>"
    ]
  },
  {
    "objectID": "Plot.html#contour-plots",
    "href": "Plot.html#contour-plots",
    "title": "\n8  Plotting using matplotlib\n",
    "section": "\n8.7 Contour Plots",
    "text": "8.7 Contour Plots\nWe next plot some of the indifference curves into the utility “mountain”. This is accomplished with so called contour plot functions.\n\nax = plt.figure(figsize=(6, 7)).add_subplot(projection='3d')\nax.contour(L,C, U, linewidths=3)\nax.view_init(elev=25., azim=225)\nax.set_title(r\"Indifference Curves: $U(c,\\ell)=\\sqrt{c}+\\sqrt{l}$\", fontsize=titleSize)\nax.set_xlabel('$\\ell$', fontsize=labelSize)\nax.set_xlim([0,1])\nax.set_ylim([0,1])\nax.set_ylabel('c', fontsize=labelSize)\nax.set_zlabel('$U(c,\\ell)$', fontsize=labelSize)\nplt.show()\n\n&lt;matplotlib.contour.QuadContourSet object at 0x7ff3a40cb850&gt;\n(0.0, 1.0)\n(0.0, 1.0)\n\n\n\n\n\n\n\n\nWe next show the 2-dimensional representation of the indifference curves.\n\n\nPython Code\nR Code\n\n\n\n\nfig, ax = plt.subplots(figsize=(7, 7))\nCS=ax.contour(L,C, U, linewidths=3)\nax.set_title(r'Indifference Curves: $U(c,\\ell)=\\sqrt{c}+\\sqrt{\\ell}$', fontsize=titleSize)\nax.set_xlabel('$\\ell$', fontsize=labelSize)\nax.set_ylabel('c', fontsize=labelSize)\nax.set_xlim([0,1])\nax.set_ylim([0,1])\nax.clabel(CS, inline=1, fontsize=14)\nplt.show()\n\n(0.0, 1.0)\n(0.0, 1.0)\n\n\n\n\n\n\n\n\n\n\n\nlibrary(plotly)\n\n\nAttaching package: 'plotly'\n\n\nThe following object is masked from 'package:ggplot2':\n\n    last_plot\n\n\nThe following object is masked from 'package:stats':\n\n    filter\n\n\nThe following object is masked from 'package:graphics':\n\n    layout\n\n# 2D Contour Plot\nfig = plot_ly(x=lv, y=cv, z=matrix(U, nrow=20, ncol=20), type = \"contour\")\nfig\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKey Concepts and Summary\n\n\n\n\nPlotting a vector.\nThe plot command needs two vectors that hold the coordinates of points you would like to plot\nUse titles and label the axes in your plots.\n\n\n\n\n\n\n\n\n\nSelf-check questions\n\n\n\n\n\n\nGenerate a random vector with 10 entries.\nPlot this vector.\n\n\n\n\n\n\n\nFigure 8.1: Figure with Simple Plot\nFigure 8.2: Figure with Simple Plot\nFigure 8.3: Figure with Simple Vector Based Plot\nFigure 8.4: Figure with Simple Vector Based Plot\nFigure 8.5: Figure with Multiple Plots\nFigure 8.6: Figure with Multiple Plots\nFigure 8.7: Simple Plot\nFigure 8.8: Simple Plot\nFigure 8.9: Simple Plot with Connected Dots\nFigure 8.10: Simple Plot with Connected Dots",
    "crumbs": [
      "**INTRODUCTION**",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Plotting using `matplotlib`</span>"
    ]
  },
  {
    "objectID": "Functions.html#function-basics",
    "href": "Functions.html#function-basics",
    "title": "\n9  Functions\n",
    "section": "",
    "text": "Note\n\n\n\nThis is different from a function in your math class where the “output” of a function is only one “element.”\n\n\n\n\n\nPython Code\nR Code\n\n\n\ndef functionname(input1, input2, ...):\n    statement1\n    statement2\n    obj1 = some calculation\n    obj2 = some calculation\n    ...\n    return obj1, obj2, ...\n\n\n\nfunctionname &lt;- function(input1, input2, ...) {\n  statement1\n  statement2\n  obj1 &lt;- some_calculation\n  obj2 &lt;- some_calculation\n  # ...\n  return(list(obj1, obj2, ...))\n}\n\n\n\n\n\n\n\nPython Code\nR Code\n\n\n\nout1, out2, ... = functionname(input1, input2, ...)\n\n\nc(out1, out2, ...) &lt;- functionname(input1, input2, ...)",
    "crumbs": [
      "**ADVANCED TECHNIQUES**",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "Functions.html#function-with-a-vectorarray-as-input",
    "href": "Functions.html#function-with-a-vectorarray-as-input",
    "title": "\n9  Functions\n",
    "section": "\n9.4 Function with a vector/array as input",
    "text": "9.4 Function with a vector/array as input\nI next present a simple mathematical function with one input variable. The function we want to program is \\[y(x) = \\sqrt{x} - \\frac{x^3-10}{25}\\] for positive values of \\(x\\) and the floor function for negative values. The floor function simply cuts of the decimals of a number.\nThe ultimate goal is to plot this function. There are a few ways to go about this but let’s just simply define the function in a function block and then evaluate the function from within a loop repeatedly. Note, the way we program this function. We require as input argument a scalar value, NOT a vector.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport math as m\n\nplt.close('all')  # close all open figures\n\ndef f_myfunc(x):\n    \"\"\"Function expects a scalar value as input!!\"\"\"\n    if x &lt; 0:\n        y = m.floor(x)\n    else:\n        y = m.sqrt(x) - (x**3 - 10)/25\n    return y\n\nYou can call this function now with scalar inputs. If you try to input a vector, the function will throw an error because it cannot evaluate the if statement with a vector.\n\nxv = np.linspace(-2,2,10)\nprint(f_myfunc(xv))\n\nThe truth value of an array with more than one element is ambiguous. Use\na.any() or a.all()\n\n\nAs you have just seen this will throw an error. In order to call this function and repeatedly evaluate it for all the x values in the xv vector, you either have to write a loop or you explicitly vectorize it in the call. Let’s do the loop first.\n\nxv = np.linspace(-2,2,10)\nyv = np.zeros(len(xv))\nfor i in range(len(xv)):\n    yv[i] = f_myfunc(xv[i])\n\nplt.plot(xv,yv)\n\n\n\n\n\n\n\nWe can now plot the xv against the yv vector. Another, more elegant method, uses the vectorize() method of the numpy library. My vectorizing the function you will be able to input a vector which will then result in an output vector where the function is mapped on the elements of the xv vector one-by-one. This is a technique associated with functional programming.\n\n\n\n\n\n\nNote\n\n\n\nRemember that all built in numpy functions are vectorized. So these functions such as np.sqrt(), np.abs(), etc. all allow arrays as input objects.\n\n\n\nyv = np.vectorize(f_myfunc)(xv)\nplt.plot(xv,yv)",
    "crumbs": [
      "**ADVANCED TECHNIQUES**",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "Growth.html#basic-model-structure",
    "href": "Growth.html#basic-model-structure",
    "title": "\n24  Growth Models\n",
    "section": "\n25.1 Basic Model Structure",
    "text": "25.1 Basic Model Structure\nThe model consists of the following key components:\n\nProduction Function: It describes how an economy converts inputs (capital and labor) into output.\nCapital Accumulation: The process of investment in capital goods, determining the economy’s capital stock over time.\nPopulation Growth: Changes in the labor force due to births and deaths.\nTechnological Progress: Enhancements in technology or productivity growth.\n\nThe production function expresses the relationship between the economy’s output and the inputs of capital (\\(K_t\\)) and labor (\\(N_t\\)):\n\\[ Y_t = A \\times F(K_t, N_t) \\]\n\nThe capital accumulation equation:\n\nThe change in capital per worker over time is defined by the investment in new capital (\\(sY_t\\)) and the depreciation of existing capital (\\(\\delta K_t\\)):\n\\[\n\\Delta K_t = sY_t - \\delta K_t\n\\]\n\nThe capital law of motion:\n\nThis equation characterizes the dynamic accumulation of capital per worker in each period:\n\\[\nK_{t+1} = (1 - \\delta)K_t + sF(K_t, N_t)\n\\]\nWe can express this in per capita terms by dividing both sides with \\(N_t\\) so we get \\[\nk_{t+1} \\times (1+n) =  s \\times A \\times F(k_t, 1) + (1 - \\delta)k_t\n\\]\nwhere \\(k=\\frac{K}{N}\\). After dividing by \\(1+n\\) and using $f(k_t)=F(k_t,1) we get the per capita capital law of motion:\n\\[\nk_{t+1} =  \\frac{s \\times A \\times f(k_t)}{1+n} + \\frac{(1 - \\delta)}{1+n} \\times k_t\n\\]\n\nThe steady-state condition:\n\nThe steady state occurs when the capital per worker no longer changes over time:\n\\[\nk_{t+1} = k_t = k^*\n\\]\n\nThe steady-state level of capital per worker:\n\nUsing a Cobb-Douglas production function\n\\[ Y_t = A \\times F(K_t, N_t) = A \\times K_t^\\alpha N_t^{(1-\\alpha)}\\]\nand expressing it on a per capita basis as:\n\\[ y_t = A \\times k_t^\\alpha. \\]\nWe then use the law of motion of per-capita-capital:\n\\[\nk_{t+1} =  \\frac{s \\times A \\times k_t^\\alpha}{1+n} + \\frac{(1 - \\delta)}{1+n} \\times k_t\n\\]\nand impose the steady state condition \\(k_{t+1}=k_t=k^*\\) so that the law of motion becomes\n\\[\nk^* =  \\frac{s \\times A \\times (k^*)^\\alpha}{1+n} + \\frac{(1 - \\delta)}{1+n} \\times k^*.\n\\]\nWe can now solve this for steady-state capital per capita \\(k^*\\):\n\\[\nk^* = \\left(\\frac{s \\times A}{n+\\delta}\\right)^{\\frac{1}{1-\\alpha}}\n\\]",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Growth Models</span>"
    ]
  },
  {
    "objectID": "Growth.html#python-code-for-plotting-capital-law-of-motion-and-steady-state",
    "href": "Growth.html#python-code-for-plotting-capital-law-of-motion-and-steady-state",
    "title": "\n24  Growth Models\n",
    "section": "\n25.2 Python Code for Plotting Capital Law of Motion and Steady State",
    "text": "25.2 Python Code for Plotting Capital Law of Motion and Steady State\nBelow is the Python code to visualize the capital law of motion and the steady state of per capita capital:\n\n\nPython Code\nR Code\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Parameters\nA = 1       # TFP\ns = 0.2     # savings rate\nalpha = 0.3  # output elasticity of capital\nn = 0.02  # population growth rate\nd = 0.05  # depreciation rate\n\n# Capital law of motion\ndef f_kprime(k):\n    return s *A * k**alpha/(1.+n) + (1-d)/(1+n)*k\n\n# Steady-state capital per worker\nkstar = (s*A/(n+d))**(1/(1-alpha))\n\n# Time and capital per worker\ntv = np.arange(0, 100, 1)\n\nkv = np.zeros(len(tv))\nkprimev = np.zeros(len(tv))\n\nkv[0] = 3.0  # initial capital per worker\nkprimev[0] = f_kprime(kv[0]) # capital tomorrow\n\nfor t in range(1, len(tv)):\n    kv[t] = kprimev[t-1]\n    kprimev[t] = f_kprime(kv[t])\n\nprint(kv[1:5])\n\n[3.06674297 3.13071114 3.19199422 3.2506822 ]\n\n\n\n\n\n# Parameters\nA &lt;- 1       # TFP\ns &lt;- 0.2     # savings rate\nalpha &lt;- 0.3  # output elasticity of capital\nn &lt;- 0.02  # population growth rate\nd &lt;- 0.05  # depreciation rate\n\n# Capital law of motion\nf_kprime &lt;- function(k) {\n  return(s * A * k^alpha / (1 + n) + (1 - d) / (1 + n) * k)\n}\n\n# Steady-state capital per worker\nkstar &lt;- (s * A / (n + d))^(1 / (1 - alpha))\n\n# Time and capital per worker\ntv &lt;- seq(0, 100, 1)\n\nkv &lt;- rep(0, length(tv))\nkprimev &lt;- rep(0, length(tv))\n\nkv[1] &lt;- 3.0  # initial capital per worker\nkprimev[1] &lt;- f_kprime(kv[1])  # capital tomorrow\n\nfor (t in 2:length(tv)) {\n  kv[t] &lt;- kprimev[t - 1]\n  kprimev[t] &lt;- f_kprime(kv[t])\n}\n\nprint(kv[2:5])\n\n[1] 3.066743 3.130711 3.191994 3.250682\n\n\n\n\n\nPrint capital over time.\n\n\nPython Code\nR Code\n\n\n\n\nfig, ax = plt.subplots()\nax.plot(tv, kv)\nax.axhline(y=kstar, color='r', linestyle='--', label='Steady State')\nax.set_xlabel('$t$ Time')\nax.set_ylabel('$k$ Capital per worker')\nax.set_title('Capital over time')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# Plot capital over time\nplot(tv, kv, type = \"l\", xlab = \"Time\", ylab = \"Capital per worker\",\n     main = \"Capital over time\")\nabline(h = kstar, col = \"red\", lty = 2)\n\n\n\n\n\n\n\n\n\n\nPrint the per-capita law of motion and put the capital path into it.\n\n\nPython Code\nR Code\n\n\n\n\n\nkgridv=np.linspace(0,5,50);\nknextv=f_kprime(kgridv);\nfig, ax = plt.subplots()\nax.plot(kgridv, knextv, 'b-')\nax.plot(kv[0:-2:5], kprimev[1:-1:5], 'o')\nax.axhline(y=kstar, color='r', linestyle='--', label='Steady State')\nax.axvline(x=kstar, color='r', linestyle='--', label='Steady State')\nax.set_xlabel('$k$ Capital per worker present period')\nax.set_ylabel('$k-prime$ Capital per worker next period')\nax.set_title('Capital Law of Motion and Steady State')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n# Plot the per-capita law of motion and add the capital path to it\nkgridv &lt;- seq(0, 5, length.out = 50)\nknextv &lt;- f_kprime(kgridv)\n\nplot(kgridv, knextv, type = \"l\", col = \"blue\", xlab = \"Capital per worker present period\",\n     ylab = \"Capital per worker next period\", main = \"Capital Law of Motion and Steady State\")\npoints(kv[c(1:length(kv)-1) %% 2 == 0], kprimev[c(2:length(kprimev)) %% 2 == 0], col = \"black\", pch = 20)\nabline(h = kstar, col = \"red\", lty = 2)\nabline(v = kstar, col = \"red\", lty = 2)\n\n\n\n\n\n\n\n\n\n\nThis code will produce a plot showing the evolution of capital per worker over time and the horizontal line indicating the steady-state level of capital per worker.\n\n\n\n\n\n\nKey Concepts and Summary\n\n\n\n\nSolow growth model\nSteady state\nBalanced growth path\n\n\n\n\n\n\n\n\n\nSelf-check questions",
    "crumbs": [
      "**OPTIMIZATION TECHNIQUES**",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Growth Models</span>"
    ]
  },
  {
    "objectID": "WebData.html#beautiful-soup-library",
    "href": "WebData.html#beautiful-soup-library",
    "title": "14  Working with Data from the Web I",
    "section": "",
    "text": "Note\n\n\n\nYou may have to install chardet library first using\nconda install charset-normalizer==3.1.0",
    "crumbs": [
      "**DATA ANALYSIS**",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Working with Data from the Web I</span>"
    ]
  }
]